[{"title":"Hexo博客搭建","path":"/2026/01/11/Hexo博客搭建/","content":"Hexo博客搭建下载nodejs并安装地址 :https://nodejs.org/zh-cn/download 一路下一步进行安装 全局安装hexo1npm install -g hexo-cli 初始化blog1hexo init blog 安装主题通过github等相关途径找到适合自己的主题进行安装，这里以hexo-theme-stellar-1.6.1为样例进行安装 1.从github下载相关的压缩包放至theme下 2.找到配置文件配置如下(_config.yaml) 1theme: hexo-theme-stellar-1.6.1 配置完成后即可得到一份博客啦 写完之后部署1npm install hexo-deployer-git --save","tags":["博客"]},{"title":"ssm项目经常出现的问题","path":"/2022/04/03/ssm项目经常出现的问题/","content":"SSM项目经常出现的问题1.无法转换json问题出现No converter found for return value of type: class top.timous.pojo.R这个无法转换为json字符串问题 这个问题暂时没有得到解决 2.无法读取配置数据库文件的username在设置数据库的db.properties的时候，如果前面不加其他的字段，那么程序很大程度会读取到机器的名称 下面是对应的ssm配置 会报下面的错误 这个时候在前面加一个前缀就可以成功了","tags":["小技巧"]},{"title":"SpringIoc和Aop的基本使用","path":"/2022/03/25/SpringIoc和Aop的基本使用/","content":"SpringIoc和AopSpring的重要Spring框架Java开发的行业标准，都使用Spring做项目，很优秀，把很多的东西都囊括在内。 Spring全家桶 web开发： Spring Web MVC &#x2F; SpringMVC Spring Web Flux 持久层： Spring Data &#x2F; Spring Data JPA &#x2F; Spring Data Redis&#x2F; Spring Data MongDB 安全校验： Spring Security 构建工程的脚手架： Spring Boot 微服务： Spring Cloud 各个层面的组件都是基于Ioc的，没有这个东西，上面的很多都是虚谈。 Ioc自动帮你创建好很多的东西，你可以直接去进行使用。Ioc是Spring全家桶各个功能模块的基础，是穿件对象的容器，每个模块都需要对象，Ioc就是帮我们创建这些模块。Aop是面向切面编程，抽象化的面向对象（aspect）。没有Ioc就没有Aop。 Aop的应用： 打印日志 做事务 权限处理 IOC控制反转，将对象的创建进行反转，常规情况下，对象都是开发者手动创建的，使用Ioc开发者不再需要去创建对象，而是由Ioc容器根据需要自动创建项目所需要的对象，我们不用再去new对象。 不使用ioc，所有对象开发者自己去进行创建 使用ioc对象不需要开发者自己去创建，而是交给spring框架来完成（只是帮助我们去完成对应的功能） 1.pom.xml12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 引入了对应的jar（配置一个context引入了对应的aop等核心的jar包） 使用SpringIoc创建对象的方式有哪些？（更多的是使用注解老的项目的话会使用xml方式进行ioc注入） ioc底层实现技术： xml解析 + 发射 基于xml 基于注解 基于xml：开发者需要的对象在xml中进行配置Spring读取这个配置文件，根据文件内容进行创建对象 2.xml的基本格式：123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd&quot;&gt; &lt;bean class=&quot;top.timous.ioc.DataConfig&quot; id=&quot;config&quot;&gt; &lt;property name=&quot;driverName&quot; value=&quot;driverName&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;localhost:3306/dbname&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试： 123456789101112131415161718192021package top.timous.ioc;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author Timous * @create 2022-03-27 22:05 **/public class Test &#123; public static void main(String[] args) &#123;// DataConfig dataConfig = new DataConfig();// dataConfig.setDriverName(&quot;Driver&quot;);// dataConfig.setPassword(&quot;localhost:3306/dbname&quot;);// dataConfig.setUsername(&quot;root&quot;);// dataConfig.setPassword(&quot;123456&quot;); ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); System.out.println(context.getBean(&quot;config&quot;)); &#125;&#125; 配置成功： 3.基于注解 配置类 用一个Java类来替代xml文件，把xml文件中的内容放在配置类中 123456789101112131415161718192021222324package top.timous.configuration;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import top.timous.ioc.DataConfig;/** * @author Timous * @create 2022-03-27 22:42 **/@Configuration // 表示是一个配置类//整体相当于是xml文件public class BeanConfiguration &#123; @Bean(value = &quot;config&quot;) //这的value和name的属性是一样的// 方法名是对应的id public DataConfig dataConfig()&#123; DataConfig dataConfig = new DataConfig(); dataConfig.setDriverName(&quot;Driver&quot;); dataConfig.setUrl(&quot;localhost:3306/dbname&quot;); dataConfig.setUsername(&quot;root&quot;); dataConfig.setPassword(&quot;123456&quot;); return dataConfig; &#125;&#125; 测试： 12345 ApplicationContext context = new AnnotationConfigApplicationContext(BeanConfiguration.class); //可以通过对应的bean上面的value值获取到对应的对象 System.out.println(context.getBean(&quot;dataConfig&quot;));//可以通过class获取ioc容器中的对象 System.out.println(context.getBean(DataConfig.class)); 结果： 下面的也可以获取到 1234ApplicationContext context = new AnnotationConfigApplicationContext(&quot;top.timous.configuration&quot;);System.out.println(context.getBean(&quot;config&quot;)); System.out.println(context.getBean(DataConfig.class)); 结果：也是能够获取到对应的bean值的 扫包+注解 更简单，不在需要xml或者是配置类进行，而是直接将bean的创建交给目标类，在目标类添加注解来进行创建 123456789101112131415161718192021package top.timous.ioc;import lombok.Data;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Data@Componentpublic class DataConfig &#123; @Value(&quot;localhost:3306/dbname&quot;) private String url; @Value(&quot;drivername&quot;) private String driverName; @Value(&quot;root&quot;) private String username; @Value(&quot;123456&quot;) private String password;&#125; 扫包： 12ApplicationContext context = new AnnotationConfigApplicationContext(&quot;top.timous.ioc&quot;); System.out.println(context.getBean(DataConfig.class)); 结果： 自动创建对象，依赖注入 依赖注入 12345678910111213141516171819202122package top.timous.ioc;import lombok.Data;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;/** * @author Timous * @create 2022-03-28 19:59 **/@Data@Componentpublic class GloablConfig &#123; @Value(&quot;8080&quot;) private String port; @Value(&quot;/&quot;) private String path; @Autowired private DataConfig dataConfig;&#125; 测试代码： 12ApplicationContext context = new AnnotationConfigApplicationContext(&quot;top.timous.ioc&quot;); System.out.println(context.getBean(GloablConfig.class)); 结果显示 @Autowired是通过类型来取值的，无论叫什么名字都可以获取到（默认是ByType），如何通过ByName的方式来实现@Qualifier来通过ByName来进行获取 AOP面向切面编程，是一种抽象化的面向对象编程，面向对象编程的一种补充 底层使用动态代理来实现 打印日志 业务代码和打印日志耦合起来 1234567891011121314151617181920212223242526272829303132333435363738394041package top.timous.aop;/** * @author Timous * @create 2022-03-28 20:15 **/public class CalImpl implements Cal&#123; @Override public int add(int num1, int num2) &#123; //”add方法的参数是num 1 + num 2“ System.out.println(&quot;add方法的参数是[+&quot; + num1 + &quot;,&quot; + num2 + &quot;]&quot;); int result = num1 + num2; System.out.println(&quot;add方法的结果是：&quot; + result); return result; &#125; @Override public int sub(int num1, int num2) &#123; System.out.println(&quot;sub方法的参数是[+&quot; + num1 + &quot;,&quot; + num2 + &quot;]&quot;); int result = num1 - num2; System.out.println(&quot;sub方法的结果是：&quot; + result); return result; &#125; @Override public int mul(int num1, int num2) &#123; System.out.println(&quot;mul方法的参数是[+&quot; + num1 + &quot;,&quot; + num2 + &quot;]&quot;); int result = num1 * num2; System.out.println(&quot;mul方法的结果是：&quot; + result); return result; &#125; @Override public int div(int num1, int num2) &#123; System.out.println(&quot;div方法的参数是[+&quot; + num1 + &quot;,&quot; + num2 + &quot;]&quot;); int result = num1 / num2; System.out.println(&quot;div方法的结果是：&quot; + result); return result; &#125;&#125; 如果要把日志改成英文的会很麻烦 这个时候就可以进行横切一刀，可以把参数传递到里面，抽象出来，多个方法可以抽象成对象，进行编程，代码的扩展性和可维护行就会变得很好了。 计算器方法中，日志和核心的业务代码是混合在一起的， AOP要做的就是将所有的日志代码全部抽离出去，进行统一的处理，计算器方法中只保留核心的业务代码 做到核心业务和非业务代码的解耦合 1.创建切面类12345678910111213141516171819202122232425262728package top.timous.aop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;import java.util.Arrays;@Component@Aspect//声明是一个且表面public class LoggerAspect &#123; @Before(&quot;execution(public int top.timous.aop.CalImpl.*(..)))&quot;) public void before(JoinPoint joinpoint)&#123; String name = joinpoint.getSignature().getName(); System.out.println(name + &quot;方法的参数是[+&quot; + Arrays.toString(joinpoint.getArgs()) + &quot;]&quot;); &#125; @AfterReturning(value = &quot;execution(public int top.timous.aop.CalImpl.*(..)))&quot; , returning = &quot;result&quot;)//在返回值之后拿到对应的数据 public void afterReturning(JoinPoint joinPoint , Object result)&#123; String name = joinPoint.getSignature().getName(); System.out.println(name + &quot;方法的结果是：&quot; + result); &#125;&#125; 2.实现类添加@Component注解12345678910111213141516171819202122232425262728293031package top.timous.aop;import org.springframework.stereotype.Component;@Componentpublic class CalImpl implements Cal&#123; @Override public int add(int num1, int num2) &#123; //”add方法的参数是num 1 + num 2“ int result = num1 + num2; return result; &#125; @Override public int sub(int num1, int num2) &#123; int result = num1 - num2; return result; &#125; @Override public int mul(int num1, int num2) &#123; int result = num1 * num2; return result; &#125; @Override public int div(int num1, int num2) &#123; int result = num1 / num2; return result; &#125;&#125; 3.配置自动扫包，开启自动生成代理对象1234&lt;!-- 自动扫包 --&gt; &lt;content:component-scan base-package=&quot;top.timous.aop&quot;&gt;&lt;/content:component-scan&gt; &lt;!-- 开启自动生成代理--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 4.使用12345678910111213141516171819202122package top.timous.ioc;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import top.timous.aop.Cal;import top.timous.configuration.BeanConfiguration;/** * @author Timous * @create 2022-03-27 22:05 **/public class Test &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); Cal cal = context.getBean(Cal.class); cal.add(1 , 2); cal.sub(1 , 2); cal.mul(1 , 2); cal.div(1 , 2); &#125;&#125; aop 图示 前几天的gitee的图床失效了，不知道咋回事，希望以后不要出问题。在网上搜完之后发现是gitee可能会出现防盗的问题，具体的可以去下面的文章去看（如有侵权，尽快来联系）https://cloud.tencent.com/developer/article/1964208","tags":["面试"]},{"title":"面试题集合","path":"/2022/03/14/面试题集合/","content":"1.mysql的索引会在啥时候失效 如果在查询的时候条件之中会有or条件的时候，索引会失效 对于多列索引，不是使用的第一部分的话，不会使用索引 like查询在以%开头的时候会失效 如果mysql本身觉得扫描全表比索引快的时候则索引会失效 2.在使用微服务的过程中，会有服务的顺序，服务启动的顺序是啥服务启动的顺序是进行服务注册与发现，然后才是路由 3.在mysql查询过程中如果出现时长太长，要求缩短时长，如何做使用索引，如果是查询时长比较长的话可以使用索引，索引会大大缩短使用的时长，索引使用一般是在数据量比较大的场景，还有字段不经常改动的时候使用。 索引有全文索引、主键索引、唯一索引、常规索引 4.在知道hashmap中有键值对的时候，如果让你去找到所有的值，如何去做？采用iterator进行遍历 12345Set set = map.entrySet();Iterator it = set.iterator();if(it.hasNext())&#123;Map.Entry me = (Map.Entry) it.next();System.out.println(me.getKey()+&quot;=&quot;+me.getValue()); 5.redis存储的数据类型以及redis为啥会快 String set list zset hash geospatial bitmaps hyperloglogs redis是基于内存的数据库，相对于基于磁盘的mysql数据库，省去了io读写磁盘的消耗 redis是单线程的，避免了多线程的上下文切换和竞争锁的阻塞，这些都是耗时操作 6.聊一聊你对volatile的理解volatile保证了数据的可见性，但是不保证原子性 7.线程创建的各个状态创建状态——–就绪状态——-阻塞状态——–运行状态——–死亡状态 8.mysql事务的四大特性（ACID）的具体含义&#x3D;&#x3D;原子性 Atomicity&#x3D;&#x3D; 要么都成功，要么都失败 &#x3D;&#x3D;一致性 Consistency&#x3D;&#x3D; 事务前后的数据完整性要保持一致 &#x3D;&#x3D;持久性 Durability&#x3D;&#x3D; 事务一旦提交则不可逆转，被持久化到数据库中 &#x3D;&#x3D;隔离性 Isolation&#x3D;&#x3D; 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他的操作数据干扰，事务之间要互相隔离 9.在SpringBoot中xml文件是否可以配置？可以进行配，里面一定是有对应的mapper文件，也就是对应的持久层的配置 10.mysql如何去重使用distinct字段进行去重1234567891011121314151617181920create table student (\tid int(4) primary key, name varchar(10) );insert into student(id , name) value(1 , &#x27;tus&#x27;);insert into student(id , name) value(2 , &#x27;tus3&#x27;);insert into student(id , name) value(3 , &#x27;tus3&#x27;);insert into student(id , name) value(4 , &#x27;tus3&#x27;);insert into student(id , name) value(5 , &#x27;tus1&#x27;);insert into student(id , name) value(6 , &#x27;tus1&#x27;);insert into student(id , name) value(7 , &#x27;tus2&#x27;);insert into student(id , name) value(8 , &#x27;tus2&#x27;);查询语句select name from student;明显可以看出来，是有重复的字段的，如果没有重复的字段，需要添加distinctselect distinct name from student; 查询的结果 去重之后的查询结果 mysql的limit后面的参数代表的含义？1234select name from student limit 1 , 4;limit后面的参数是 当前起始的条数 页面的大小如果是按照2行一页的话就是 limit 0 ， 2 limit 2 ， 2 limit 4 ， 2 第i页的参数是 limit （i-1）*页面的大小 ， 页面的大小 mysql的表的索引最多能建立多少个？一开始查询别人写的博客的时候是1017 ， 本来以为是1024 ， 但是innodb的引擎好像一个表只能有1017列，但是还有联合索引，不知道有多少个，后来的话在文档上查询的是最多有16个索引 在一张表里面。 https://dev.mysql.com/doc/refman/5.7/en/innodb-limits.html里面有明确的表示只能建立16个索引，否则会在建立的时候返回错误 sql语句，给定课程号和成绩，找出每一门课程最好的成绩先创建表grade 12345CREATE TABLE grade(gid INT(4) NOT NULL PRIMARY KEY,id INT(4) NOT NULL,score INT(4) NOT NULL); 插入所有的数据 123456789INSERT INTO grade VALUES(1 , 1,100);INSERT INTO grade VALUES(2 , 1,88);INSERT INTO grade VALUES(3 , 2,60);INSERT INTO grade VALUES(4 , 3,96);INSERT INTO grade VALUES(5 , 3,87); 查询所有的数据 1SELECT * FROM grade; 通过函数分组查询每一门课程的最高分 1SELECT id , MAX(score) FROM grade GROUP BY id; 另外分组的话必须要使用函数才能够查询出来对应的结果（不使用函数的话会报错） 11.你对mysql的时间字段了解不了解？？ 时间和日期 date YYYY-MM-DD 日期 time HH:mm:ss 时间格式 &#x3D;&#x3D;datetime&#x3D;&#x3D; YYYY-MM-DD HH:mm:ss 最常用的时间格式 &#x3D;&#x3D;timestamp&#x3D;&#x3D; 时间戳 1970-1-1到现在的毫秒数 year 年份表示 mysql的时间有四个： time、datetime、timestamp和year，分别表示的是时分秒、年月日时分秒、时间戳（1970-1-1到现在的毫秒数）和年份，一般用的都是datetime格式的时间，其他的用的比较少","tags":["面试"]},{"title":"Spring相关面试题","path":"/2022/03/01/Spring相关面试题/","content":"Spring相关面试题1.Spring如何创建一个Bean对象？UserService–》无参数的构造方法（推断）—》 普通对象–》依赖注入（给前面对象的属性赋值）—》初始化前（@PostConstruct）—》初始化（InitializingBean）—》初始化后（AOP）—》代理对象—》放入对应的map单例池（后面多次获取的时候就会是同一个了）–》Bean对象 2.什么是单例池，作用是什么？获取到的Bean是同一个，使用的是map来获取对应的Bean对象，就是map的key和value是一一对应的。所以每次根据名字获取的时候都是同一个Bean，不是多个Bean。这个时候的map就是对应的单例池，作用就是在获取对象的时候不会重新创建新对象。 3.Bean对象和普通对象的区别大部分的时候是一样的，普通对象经过某些东西之后就会变成Bean对象 4.@PostConstruct注解是如何工作的@PostConstruct初始化前的时候会调用对应的方法，来创建对应的拥有（数据库）数据的对象。这个时候，对应的对象就会成为JavaBean对象。 5.Bean的初始化是如何工作的？判断是不是实现某些接口，如果实现了一些接口，就会有对应的操作的处理（从后台获取数据等信息） 6.Bean的实例化和初始化的区别实例化就是通过构造方法，进行实例化。初始化就是实例化出来的对象的某个方法（具体在执行啥方法，Spring是不管的）。 7.什么是初始化后初始化后就是AOP，不需要进行AOP的话就是把普通对象放入单例池，需要进行的话就把代理对象放入单例池，使用的是代理对象的话，就相当于执行了AOP（初始化之后） 在写完有参的构造方法之后，默认的无参的方法就会没有，在都没有的时候，会默认有一个无参的构造方法。 8.构造方法的含义（推断）在有参和无参的构造方法同时有的时候，会使用无参的构造方法。为啥不使用有参的构造方法？？？在有两个有参构造方法的时候会进行报错。在单独使用的时候都是能够使用的。有两个有参的构造方法的时候就会出现问题，Spring会无法进行决策，会进行报错。一个类里面有多个构造方法的时候，如果没有告诉使用哪个构造方法的时候，就会优先进行考虑使用无参的构造方法。实际上的无参的就是我们所认为的默认的构造方法。在上面加上一个@Autowired的时候就会使用这个方法。 9.什么是先bytype再byName在使用构造方法的时候会使用参数，参数有类型和名字，这个时候要先根据对应的类型来进行寻找，然后再根据名字来寻找。如果类型只有一个，那么就不需要再byName了，如果有好几个，那么就会再byName进行寻找了（name是传递进入的参数）。 10.SpringAOP底层是如何工作的？添加这个注解@EnableAspectAutoProxy 得到代理对象之后并没有依赖注入，里面的都是null CGLib通过父子类来进行代理的 UserServiceProxy对象—-》 UserService代理对象 —-》 UserService代理对象.target &#x3D; 普通对象 —-》 放入单例池 11.Spring事务是如何工作的需要添加@Configuration有关 ， 事务也是基于SpringAOP的","tags":["面试"]},{"title":"商城小程序热门商品","path":"/2022/03/01/商城小程序热门商品/","content":"商城小程序热门商品后台编写controller123456789101112/*查询热门商品*/ @GetMapping(&quot;/hotProduct&quot;) public R hotProduct()&#123; Page&lt;Product&gt; page = new Page&lt;&gt;(0 , 8); Page&lt;Product&gt; productPage = iProductService.page(page, new QueryWrapper&lt;Product&gt;() .eq(&quot;isHot&quot;, true) .orderByAsc(&quot;hotDateTime&quot;)); List&lt;Product&gt; productList = productPage.getRecords(); Map&lt;String , Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;message&quot; , productList); return R.ok(map); &#125; 除此之外，还需要添加一个配置类只有添加了这个配置类，才能够进行分页的查询 1234567891011121314151617181920package top.timous.config;import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author Timous * @create 2022-03-01 11:09 **/@Configurationpublic class MybatisConfig &#123; /* * @Bean 是一个JavaBean，注入了容器之中 * */ @Bean public PaginationInterceptor paginationInterceptor()&#123; return new PaginationInterceptor(); &#125;&#125; 不添加配置类时候的查询 分页查询 从上述图可以看出，在添加分页功能的时候一定要添加对应分页拦截器。 查询结果","tags":["小程序"]},{"title":"微信商城小程序大类显示","path":"/2022/02/28/微信商城小程序大类显示/","content":"微信商城小程序大类显示请求123456789101112131415161718192021222324252627282930//data数据定义 bigTypeImages 大类的图片 bigTypeList:[], // 第一行的images bigTypeList_row1:[], // 第二行的iamges数据 bigTypeList_row2:[] //方法调用 this.getBigTypeImages()//获取大类数据 /bigType/findAll async getBigTypeImages()&#123; const res = await requestUtil(&#123; url: &quot;/bigType/findAll&quot;, method: &quot;GET&quot; &#125;); const bigTypeList = res.message const bigTypeList_row1 = bigTypeList.filter((item , index)=&gt;&#123; return index &lt; 5 &#125;) const bigTypeList_row2 = bigTypeList.filter((item , index)=&gt;&#123; return index &gt; 5 &#125;) this.setData(&#123; // 设置第一行数据 bigTypeList_row1, // 设置第二行数据 bigTypeList_row2 &#125;) &#125; wxml文件(跳转的url还没有写)1234567891011121314151617181920&lt;!-- 大类图片开始 --&gt;&lt;view class=&quot;bigTypeList&quot;&gt; &lt;view class=&quot;bigTypeRow&quot; &gt; &lt;navigator wx:for=&quot;&#123;&#123;bigTypeList_row1&#125;&#125;&quot; wx:for-item=&quot;bigType&quot; wx:key=&quot;id&quot;&gt; &lt;image mode=&quot;widthFix&quot; src=&quot;&#123;&#123;baseUrl + &#x27;/image/bigType/&#x27;+bigType.image&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;/navigator&gt; &lt;/view&gt; &lt;view class=&quot;bigTypeRow&quot; &gt; &lt;navigator wx:for=&quot;&#123;&#123;bigTypeList_row2&#125;&#125;&quot; wx:for-item=&quot;bigType&quot; wx:key=&quot;id&quot;&gt; &lt;image mode=&quot;widthFix&quot; src=&quot;&#123;&#123;baseUrl + &#x27;/image/bigType/&#x27;+bigType.image&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;/navigator&gt; &lt;/view&gt;&lt;/view&gt;&lt;!-- 大类图片结束 --&gt; less文件（css）文件123456789101112131415// 大类的样式.bigTypeList&#123; padding-top: 20rpx; background-color: #F7F7F7; .bigTypeRow&#123; display: flex; width: 150rpx; navigator&#123; flex: 1; image&#123; width: 150rpx; &#125; &#125; &#125;&#125; 完成页面展示 filter解释小程序filter文档地址：https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/command/aggregate/AggregateCommand.filter.html 返回的结果是满足条件数组的子集 今天就先到这","tags":["小程序"]},{"title":"微信商城小程序商品类别显示","path":"/2022/02/27/微信商城小程序商品类别显示/","content":"微信商城小程序商品大类的显示1.数据库文件 后面图片会做本地映射 12345678910111213141516171819create table `t_bigtype` (\t`id` int (11),\t`name` varchar (150),\t`remark` varchar (765),\t`image` varchar (765)); insert into `t_bigtype` (`id`, `name`, `remark`, `image`) values(&#x27;1&#x27;,&#x27;手机&#x27;,&#x27;手机描述&#x27;,&#x27;1.jpg&#x27;);insert into `t_bigtype` (`id`, `name`, `remark`, `image`) values(&#x27;2&#x27;,&#x27;电脑平板&#x27;,&#x27;电脑平板描述&#x27;,&#x27;2.jpg&#x27;);insert into `t_bigtype` (`id`, `name`, `remark`, `image`) values(&#x27;3&#x27;,&#x27;智能穿戴&#x27;,&#x27;智能穿戴描述&#x27;,&#x27;3.jpg&#x27;);insert into `t_bigtype` (`id`, `name`, `remark`, `image`) values(&#x27;4&#x27;,&#x27;电视&#x27;,&#x27;电视描述&#x27;,&#x27;4.jpg&#x27;);insert into `t_bigtype` (`id`, `name`, `remark`, `image`) values(&#x27;5&#x27;,&#x27;大家电&#x27;,&#x27;大家电描述&#x27;,&#x27;5.jpg&#x27;);insert into `t_bigtype` (`id`, `name`, `remark`, `image`) values(&#x27;6&#x27;,&#x27;小家电&#x27;,&#x27;小家电描述&#x27;,&#x27;6.jpg&#x27;);insert into `t_bigtype` (`id`, `name`, `remark`, `image`) values(&#x27;7&#x27;,&#x27;智能家居&#x27;,&#x27;智能家居描述&#x27;,&#x27;7.jpg&#x27;);insert into `t_bigtype` (`id`, `name`, `remark`, `image`) values(&#x27;8&#x27;,&#x27;户外出行&#x27;,&#x27;户外出行描述&#x27;,&#x27;8.jpg&#x27;);insert into `t_bigtype` (`id`, `name`, `remark`, `image`) values(&#x27;9&#x27;,&#x27;日用百货&#x27;,&#x27;日用百货描述&#x27;,&#x27;9.jpg&#x27;);insert into `t_bigtype` (`id`, `name`, `remark`, `image`) values(&#x27;10&#x27;,&#x27;儿童用品&#x27;,&#x27;儿童用品描述&#x27;,&#x27;10.jpg&#x27;);insert into `t_bigtype` (`id`, `name`, `remark`, `image`) values(&#x27;41&#x27;,&#x27;ds&#x27;,&#x27;ds&#x27;,&#x27;default.jpg&#x27;);insert into `t_bigtype` (`id`, `name`, `remark`, `image`) values(&#x27;42&#x27;,&#x27;dsds&#x27;,&#x27;ds&#x27;,&#x27;default.jpg&#x27;);insert into `t_bigtype` (`id`, `name`, `remark`, `image`) values(&#x27;43&#x27;,&#x27;22&#x27;,&#x27;22&#x27;,&#x27;20220226111030000000632.jpg&#x27;); 创建对应的文件进行查询代码的编写，由于使用的是Mybatis-Plus。所以代码会比较少 如果有兴趣，对应的maven仓库：https://gitee.com/timoustop/mall（所有的工具啥的都在里面）","tags":["小程序"]},{"title":"java面试题进阶","path":"/2022/02/27/java面试题进阶/","content":"java面试题进阶1.HashMap底层实现原理详解123456public static void main(String[] args) HashMap&lt;String , String&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(&quot;timous&quot; , &quot;2&quot;); String result = hashMap.put(&quot;timous&quot; , &quot;3&quot;); System.out.println(result);&#125; 此处返回的值是2 ， 不是3，返回的是覆盖的值 hashmap在1.7中是使用的数组+链表实现的 当前put的放在那里？ 是根据key对应的来确定需要放置的位置的 通过 key.hashCode来获取hashcode，如下图所示是获取到的hashCode 不会使用这个作为数组的下标 ， 根据一定的格式（区取余 ， 根据数组的长度进行取余 ， 这里拿长度为8的数组来举例子），转化为对应的0 - 7 的对应的值 ， hashcode是没有很大的规律的 1.7考虑的是尾插法的话需要进行遍历完所有的元素之后才能找到对应的位置，头插法则不需要。一开始初始化的时候并没有去定义大小，而是在进行put的时候才进行初始化，初始化是通过对应大于等于2的幂的次数，通过左移和右移来确定对应的数组的大小，最后通过与操作来确定应该放在数组的那个位置上面。 2.为什么HashMap要用数组+链表实现？key不一样的时候hashCode可能也不一样，但是最后结果的范围是对应数组的大小，如果数据多的话，可能会出现hash冲突，在这里不是指hash值出现冲突，这里指的是对应的位置出现了冲突，解决这个方法就是对应的位置放置一个链表。","tags":["面试题"]},{"title":"商城小程序工具封装","path":"/2022/02/26/商城小程序工具封装/","content":"商城小程序工具封装1.创建封装帮助js文件 js文件内容 1234567891011121314151617181920212223// baseUrl工具封装 之后改成自己的请求的地址即可const baseUrl = &quot;http://localhost:8080&quot;;// baseUrl 导出export const getBaseUrl=()=&gt;&#123; return baseUrl;&#125;// 后端请求工具类export const requestUtil = (params)=&gt;&#123; return new Promise((resolve , rejece)=&gt;&#123; wx.request(&#123; // 此处相当于传递了Url以及各种参数，可以更改传递过啦IDE参数 ...params, url:baseUrl+params.url, success:(res)=&gt;&#123; resolve(res.data) &#125;, fail:(err)=&gt;&#123; reject(err) &#125; &#125;) &#125;);&#125; 2.使用封装的请求工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 导入请求工具类import &#123;getBaseUrl , requestUtil&#125; from &#x27;../../utils/requestUtil.js&#x27;import regeneratorRuntime from &#x27;../../lib/runtime/runtime.js&#x27;Page(&#123; /** * 页面的初始数据 */ data: &#123; // swiper轮播图的数组 swiperList : [], // baseUrl 此处的值一定不能不写 可以为‘’ baseUrl:&#x27;&#x27;, &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; // // 加载swiper数组的元素 // wx.request(&#123; // // 请求的url地址 // url: &#x27;http://localhost:8080/product/findSwiper&#x27;, // method: &quot;GET&quot;, // // 请求成功之后调用的函数 // success:(res)=&gt;&#123; // this.setData(&#123; // swiperList : res.data.message // &#125;) // &#125; // &#125;) // 获取baseUrl this.getUrl(); // 封装之后的代码 // requestUtil(&#123; // url: &#x27;http://localhost:8080/product/findSwiper&#x27;, // method: &quot;GET&quot; // &#125;).then(res=&gt;&#123; // this.setData(&#123; // swiperList : res.message // &#125;) // &#125;) this.getSwiperList() &#125;, // 获取swiperList方法 async getSwiperList()&#123; // requestUtil(&#123; // url: &#x27;/product/findSwiper&#x27;, // method: &quot;GET&quot; // &#125;).then(res=&gt;&#123; // this.setData(&#123; // swiperList : res.message // &#125;) // &#125;) const res = await requestUtil(&#123; url: &#x27;/product/findSwiper&#x27;, method: &quot;GET&quot; &#125;); // 会等待结果出来之后再执行下面的东西 this.setData(&#123; swiperList : res.message &#125;) &#125;, // 获取baseUrl方法 getUrl()&#123; const baseUrl = getBaseUrl(); this.setData(&#123; baseUrl &#125;) &#125;&#125;) html文件的修改，把baseUrl已修改即可 以后可能还有很多的工具要封装，今天就到这里了。","tags":["小程序"]},{"title":"微信商城小程序开发","path":"/2022/02/25/微信商城小程序开发/","content":"app.js文件介绍123456789// app.jsApp(&#123; //小程序初始页面加载 onLaunch() &#123; &#125;, //全局数据 globalData: &#123;&#125;&#125;) app.json文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//里面不能写注释，后面的注释都是自己写的&#123; //所有的页面，各个页面 &quot;pages&quot;: [ &quot;pages/index/index&quot;, &quot;pages/category/index&quot;, &quot;pages/cart/index&quot;, &quot;pages/my/index&quot;, &quot;pages/search/index&quot; ], //backgroundTextStyle 背景文字颜色 navigationBarBackgroundColor 上面背景的颜色 //navigationBarTitleText 小程序的名称 navigationBarTextStyle 小程序名字字体的颜色 &quot;window&quot;: &#123; &quot;backgroundTextStyle&quot;: &quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#FF5700&quot;, &quot;navigationBarTitleText&quot;: &quot;Timous商城&quot;, &quot;navigationBarTextStyle&quot;: &quot;white&quot; &#125;, //下面的四个东西 color 颜色 selectedColor 选中之后的颜色 backgroundColor 背景颜色 //list 下面的导航的具体信息 pagePath 页面的路径 text 页面的名字 //iconPath 图标的路径 selectedIconPath 选中图标的样式 &quot;tabBar&quot;: &#123; &quot;color&quot;: &quot;#999&quot;, &quot;selectedColor&quot;: &quot;#FF5700&quot;, &quot;backgroundColor&quot;: &quot;#fafafa&quot;, &quot;list&quot;: [ &#123; &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;首页&quot;, &quot;iconPath&quot;: &quot;./icons/_home.png&quot;, &quot;selectedIconPath&quot;: &quot;./icons/home.png&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/category/index&quot;, &quot;text&quot;: &quot;分类&quot;, &quot;iconPath&quot;: &quot;./icons/_category.png&quot;, &quot;selectedIconPath&quot;: &quot;./icons/category.png&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/cart/index&quot;, &quot;text&quot;: &quot;购物车&quot;, &quot;iconPath&quot;: &quot;./icons/_cart.png&quot;, &quot;selectedIconPath&quot;: &quot;./icons/cart.png&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/my/index&quot;, &quot;text&quot;: &quot;我的&quot;, &quot;iconPath&quot;: &quot;./icons/_my.png&quot;, &quot;selectedIconPath&quot;: &quot;./icons/my.png&quot; &#125; ] &#125;, &quot;style&quot;: &quot;v2&quot;, &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;, &quot;lazyCodeLoading&quot;: &quot;requiredComponents&quot;&#125; 小程序组件引入要做一个如下图所示的搜索框： conmponent，组件，建立具体对应的页面 .wxml页面这个文件相当于前端的html文件 12345&lt;view class=&quot;search_Bar&quot;&gt;&lt;navigator url=&quot;/pages/search/index&quot; open-type=&quot;navigate&quot;&gt; &lt;icon type=&quot;search&quot; size=&quot;16&quot;&gt;&lt;/icon&gt;搜索&lt;/navigator&gt;&lt;/view&gt; .less文件less文件比较符合写作的习惯，写完之后能够自动生成对应的wxss文件 12345678910111213141516171819.search_Bar &#123; height: 90 rpx; padding: 10 rpx; background-color: var(--themeColor); navigator &#123; height: 100%; display: flex; justify-content: center; align-items: center; background-color: #fff; color: #666; border-radius: 15 rpx; icon &#123; padding-right: 5 rpx; &#125; &#125;&#125; .wxss页面这个文件相当于css文件 1234567891011121314151617.search_Bar &#123; height: 90rpx; padding: 10rpx; background-color: var(--themeColor);&#125;.search_Bar navigator &#123; height: 100%; display: flex; justify-content: center; align-items: center; background-color: #fff; color: #666; border-radius: 15rpx;&#125;.search_Bar navigator icon &#123; padding-right: 5rpx;&#125; 组件引入先在json文件中引入对应的组件 在wxml文件中引入注册的组件 保存即可实现对应的组件 小程序请求后台数据js请求数据 12345678910111213141516171819202122232425262728Page(&#123; /** * 页面的初始数据 */ data: &#123; // swiper轮播图的数组 swiperList : [] &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; // 加载swiper数组的元素 wx.request(&#123; // 请求的url地址 url: &#x27;http://localhost:8080/product/findSwiper&#x27;, method: &quot;GET&quot;, // 请求成功之后调用的函数 success:(res)=&gt;&#123; this.setData(&#123; swiperList : res.data.message &#125;) &#125; &#125;) &#125;&#125;) 页面文件渲染wxml 12345678910111213141516171819202122&lt;view&gt;&lt;!-- 搜索框开始 --&gt;&lt;searchBar&gt;&lt;/searchBar&gt;&lt;!-- 搜索框结束 --&gt;&lt;!-- 轮播图开始 --&gt;&lt;view class=&quot;index_swiper&quot;&gt;&lt;!-- 进行循环遍历对应的轮播图 --&gt; &lt;swiper indicator-dots autoplay circular&gt; &lt;!-- wx:for=&quot;&#123;&#123;swiperList&#125;&#125;&quot; 循环对应的swiperList wx:for-item=&quot;swiper&quot; 给循环的数据项去一个名字 wx:key=&quot;id&quot; 循环的唯一标识 --&gt; &lt;swiper-item wx:for=&quot;&#123;&#123;swiperList&#125;&#125;&quot; wx:for-item=&quot;swiper&quot; wx:key=&quot;id&quot;&gt; &lt;!-- &#123;&#123;&#x27;http://localhost:8080/image/swiper/&#x27;+swiper.swiperPic&#125;&#125; 拼接对应的数据项 --&gt; &lt;navigator&gt;&lt;image mode=&quot;widthFix&quot; src=&quot;&#123;&#123;&#x27;http://localhost:8080/image/swiper/&#x27;+swiper.swiperPic&#125;&#125;&quot;&gt;&lt;/image&gt;&lt;/navigator&gt; &lt;/swiper-item&gt; &lt;/swiper&gt;&lt;/view&gt;&lt;!-- 轮播图结束 --&gt;&lt;/view&gt; 上述页面对应的css文件 1234567.index_swiper swiper &#123; width: 750rpx; height: 375rpx;&#125;.index_swiper swiper swiper-item image &#123; width: 100%;&#125; 如此便请求好了对应的后台的数据，下图是请求好的数据。 下面是做出来的具体的样式图","tags":["小程序"]},{"title":"Java面试题","path":"/2022/02/24/Java面试题/","content":"Java基础面试题1.什么是面向对象？谈谈你对面向对象的理解洗衣服 面向过程： 打开洗衣机–》 放衣服—》 放洗衣粉—》 清洗—》 烘干 面向对象 人： 打开洗衣机 放衣服 放洗衣粉 洗衣机： 清洗 烘干 面向过程比较直接 ， 面向对象更容易进行复用 面向对象的三大特性： 继承 ， 封装 ， 多态 封装明确标识出外部函数能够使用的所有成员函数和数据项 javaBean属性私有 orm框架 ，不需要关心内部如何实现 ， 只需要调用方法即可 继承继承基类的方法 ， 并作出自己的扩展和改变 ， 共性全部定义在父类·· 多态基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。 继承、方法重写、父类引用指向子类对象 12父类类型 变量名 = new 子类对象变量名.方法名（）； //调用的是子类的方法名 无法调用子类的特有功能 2.JDK、JRE、JVM三者的区别和练习JDK ： Java Development Kit java开发工具 JRE : Java Runtime Environment java运行时环境 JVM ： java virtual machine java虚拟机 3.&#x3D;&#x3D;和equals&#x3D;&#x3D;对比的是栈中的值 ， 基本数据类型是变量值 ， 引用类型是堆中内存对象的地址 equals： object中默认也是&#x3D;&#x3D;比较 ， 通常会进行重写 String中重新写了equals这个方法，这个时候二者是相等的 4.简述final的作用最终的 修饰类： 表示类不可以被继承 修饰方法： 表示方法不可能被子类覆盖，但是可以重载 修饰变量： 表示变量一旦被赋值就不可以更改它的值 （1）修饰成员变量 如果修饰的是成员变量，可以在非静态初始化块声明该变量或者构造器中执行初始值 如果修饰的是类变量 ， 只能在静态初始化块中指定初始值或者声明类变量时指定初始值 （2）修饰局部变量 系统不会为局部变量进行初始化，局部变量必须有程序员初始化显示。一次使用final修饰局部变量的时候，即可以在定义时指定默认值，也可以不指定默认值，在后面的代码中对final变量赋初值一次 （3）修饰基本数据类型和引用数据类型 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能进行更改 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象，但是引用的值是可变的 5.为什么局部内部类和匿名内部类只能访问final变量？编译之后会生成两个class文件，Test.class Test1.class 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; &#125;// 局部final变量a , b public void test(final int b)&#123; final int a = 10; //匿名内部类 new Thread()&#123; public void run()&#123; System.out.println(a); System.out.println(b); &#125; &#125;.start(); &#125;&#125;class OutClass&#123; private int age = 12; public void outPrint(final int x)&#123; class InClass&#123; public void InPrint()&#123; system.out.println(x); System.out.println(age); &#125; &#125; new InClass().InPrint(); &#125;&#125; 首先需要知道的一点是： 内部类和外部类是出于同一个级别的，内部类不会因为定义在方法中就会随着方法执行的完毕就被销毁。 这就会产生问题： 当外部类的方法结束时，局部的变量就会被销毁，但是内部类对象可能还存在（只有没有人在引用它的时候才会死亡）。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量付之一份作为内部类的成员变量，这样局部变量死亡之后，内部类仍然可以进行访问，实际访问的是局部变量重新拷贝的。这样就好像延长了局部变量的生命周期。 将局部变量复制为内部类的成员变量时必须保证 这两个变量时一样的，也就是如果我们在内部类修改了成员变量，方法中的局部变量也得随着改变，怎么解决问题呢？ 就将局部变量设置为final，对它初始化后，就不需要你再去修改这个变量，就保证了内部类的成员变量和方法的局部变量的一致性。这实际上也是种妥协。使得局部变量与内部类建立的拷贝保持一致。 顺便说一下关于考研成绩的事，自己大概率是没有考上的希望了，我也很希望能够考上，但是成绩出来之后，我觉得是考不上了，所以开始准备参加工作，搞面试题啥的，希望自己能够找到一家好的公司，能够不让父母担心自己，希望一切都慢慢变的好起来。 2月25号更新的内容 6.String 、 StringBuffer、StringBuilder区别以及使用场景String是final修饰的，不可变，每次操作都会产生新的String对象 StringBuffer和StringBuilder都是在原来的对象上进行操作 StringBuffer是线程安全的，StringBuilder不是线程安全的 StringBuffer方法都是sychronized修饰的 性能： StringBuilder &gt; StringBuffer &gt; String 场景： 经常需要改变字符内容时使用后面两个 优先使用StringBuilder ， 多线程使用共享变量的时候使用的是StringBuffer 7.重载和重写的区别重载： 发生在同一个类中，方法名相同，参数类型不同、个数不同、顺序不同，方法的返回值和修饰符可以不同，发生在编译的时候。 重写： 发生在父子类之中，方法名、参数列表必须相同，返回值小于父类，抛出的异常小于父类，访问修饰符大于父类；如果父类方法访问修饰符是private的话，子类就不能重写该方法。 123public int add(int a , String b);public String add(int a , String b);//编译报错 8.接口和抽象类的区别 抽象类中可以存在普通成员函数，而接口中只能存在public abstract方法 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final 类型的。 抽象类只能继承一个，接口可以实现多个。 接口的设计目的，是对类的行为进行约束（更准确的说是一种“有”的约束，因为接口不能规定类不可以有什么行为），也是提供一种机制，可以强制要求不同的类有相同的行为。它只是约束了行为的有无，但不对如何实现进行限制。 而抽象类的设计，是代码的复用。当不同的类具有某些相同行为（记为集合A），且其中一部分的行为实现方式一致时（A的非真子集 ， 记为B），可以让这些类都派生于一个抽象类，在这个抽象类中实现了B，避免让所有的子类来实现B，这样就达到了代码的复用。而A减B的部分，留给各个子类自己实现。正是因为A减B在这里没有实现，所以抽象类不允许被实例化出来（否则当调用A减B时 ，无法执行）。 抽象类是对类本质的抽象，表达的是is a 的关系，比如B is a car。 抽象类包含并实现了子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。 而接口是对行为的抽象，表达的是 like a 的关系。接口的核心是定义行为，即实现类可以做什么，至于实现类主题是谁，是如何实现的，接口并不关心。 使用场景： 当你关注一个事物的本质的时候，用抽象类，当你关注一个操作的时候，使用接口。 抽象了的功能要远超过接口，但是定义抽象类的代价高，因为高级语言来说（从实际设计上说也是）每个类只能继承一个类，在这个类中，你必须继承或编写其子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中实现多个接口，这在设计阶段会降低难度。 9.List和Set的区别 list有序，按照对象进入的顺序保存对象，可以重复，允许有多个NULL元素，可以使用iterator取出所有的元素，在逐一进行遍历，还可以进行get（index）获取制定下标的元素 set无序，不可重复，且最多有一个NULL元素，取元素的时候只能使用iterator接口取得所有的元素，再逐一遍历各个元素 10.hashCode与equals equals提供个程序员对比两个对象是不是相同的，定义对比对象的规则，如果不进行重写，采用的是Object的对比，跟&#x3D;&#x3D;是一样的，一般都是会进行重写equals的。 hashCode介绍hashCode（）的作用就是获取哈希码，也称为散列码，它实际上是一个int类型的整数，这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode（）定义在JDK中的Object.java中，Java中的任何类都包含有hashCode()函数。散列表存储的是键值对（key-value），它的特点是：能根据键快速的索引出对应的值。这其中就利用到了散列码！（）可以快速找到所需要的对象 为什么要有hashCode以HashSet如何检查重复为例子来说明为什么要有hashCode： ​\t对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有值，如果没有，HashSet会假设对象没有出现，但是如果发现有值，这时会调用equals（）方法来检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他的位置上，这样就大大减少了equals的次数，就相应大大提高了执行的速度。 如果两个对象是相等的，则hashcode也是相同的 两个对象相等，对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，他们不一定是相等的 因此，equals方法被覆盖过，则hashcode也必须被覆盖 hashCode（）的默认行为是对堆上的对象产生独特值，如果没有重写hashCode（），则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 11.ArrayList和LinkedList的区别ArrayList： 基于动态数组，连续内存存储，适合下标访问（随机访问），扩容机制： 因数组长度固定，超出长度存数据时需要新建数组，然后将老的数组的数据拷贝到新的数组，如果不是尾部插入数据还会涉及到元素的移动（往后复制一份，插入新的元素），使用尾插法并制指定初始容量可以极大的提升性能，甚至超过LinkedList（需要创建大量的node对象） LinkedList： 基于链表，可以存储在分散的内存之中，适合做数据插入以及删除操作，不适合查询，需要逐一遍历，遍历LInkedList需要采用iterator，不能使用for循环进行遍历，因为每次for循环体内通过get（）获取某一元素的时候都需要对list进行遍历，性能消耗极大。 另外不要试图使用indexOf等来返回元素索引，并利用其遍历，使用idnexOf对list进行遍历，当结果为空时，会遍历整个列表。 12.谈谈你对Java的注解的理解注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包，类，接口，字段，方法，参数，局部变量等进行注解。 生成文档，通过代码里标识的元数据生成javadoc文档 编译检查，通过代码里的元数据让编译器在编译期间进行检查 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例 13.mysql如何去重1234567891011121314151617181920create table student (\tid int(4) primary key, name varchar(10) );insert into student(id , name) value(1 , &#x27;tus&#x27;);insert into student(id , name) value(2 , &#x27;tus3&#x27;);insert into student(id , name) value(3 , &#x27;tus3&#x27;);insert into student(id , name) value(4 , &#x27;tus3&#x27;);insert into student(id , name) value(5 , &#x27;tus1&#x27;);insert into student(id , name) value(6 , &#x27;tus1&#x27;);insert into student(id , name) value(7 , &#x27;tus2&#x27;);insert into student(id , name) value(8 , &#x27;tus2&#x27;);查询语句select name from student;明显可以看出来，是有重复的字段的，如果没有重复的字段，需要添加distinctselect distinct name from student; 查询的结果 去重之后的查询结果","tags":["面试"]},{"title":"ssm框架整合学习","path":"/2022/01/15/ssm框架整合学习/","content":"ssm的maven整合导入需要的依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!--导入的jar包 也就是依赖--&gt; &lt;!--junit、数据库驱动、连接池、servlet、jsp、mybatis、mybatis-spring、spring--&gt; &lt;dependencies&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库连接池 c3p0 dbcp--&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet jsp--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis和spring整合--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Lombok 偷懒专用--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 静态资源的导出1234567891011121314151617181920&lt;!--静态资源的导出问题 必须要做的--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 连接数据库12# 在mysql8.0及以上的版本需要配置时区的问题 serverTimezonejdbc:mysql://127.0.0.1:3306/web?serverTimezone=UTC&amp;amp&amp;useSSL=false 配置数据源 database.properties1driver=com.mysql.cj.jdbc.Driver 如果是8.0及其以上的版本，需要时区的设置123url=jdbc:mysql://localhost:3306/ssmbuild?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC&amp;amp&amp;useSSL=false&amp;allowPublicKeyRetrieval=trueusername=rootpassword=123456 1234567891011121314151617185. ## 配置mybatis，mybatis-config.xml ```xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--别名的配置--&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.timous.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!--注册我们写过的mapper文件--&gt; &lt;mappers&gt; &lt;mapper class=&quot;com.timous.dao.BookMapper&quot; /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 配置spring applicationContext.xml1234567891011121314151617 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--后面需要的时候导入的--&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;import resource=&quot;spring-service.xml&quot;/&gt; &lt;import resource=&quot;spring-mvc.xml&quot;/&gt;&lt;/beans&gt; 配置与dao有关的操作 spring-dao.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--整合dao 1.关联数据库配置文件--&gt;&lt;!-- &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;--&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath*:database.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--2.连接池 dbcp ： 半自动化操作 不能自动连接，需要手动连接 c3p0 ： 自动化操作 自动化的加载配置文件 并且可以自动设置到对象中 druid hikari spring 2.0 默认集成的 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!--配置driverclass--&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;!--配置url--&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;!--配置username--&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;!--配置password--&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;!--配置最大连接数量--&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;!--配置最小连接数量--&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!--配置关闭后不自动commit--&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!--获取连接超时时间--&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt; &lt;!--获取连接失败重试次数--&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt; &lt;/bean&gt; &lt;!--3. sqlSessionFactory--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--绑定mybatis的配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;/bean&gt; &lt;!--可以配置dao接口的扫描包 动态自动化配置--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--注入sqlSessionFactory--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!--扫描dao包--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.timous.dao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 配置spring的service层 spring-service.xml1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--1. 扫描service下面的包--&gt; &lt;context:component-scan base-package=&quot;com.timous.service&quot;/&gt; &lt;!--3. 声明是事务--&gt; &lt;!--注入数据源--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--4. aop事务支持--&gt;&lt;/beans&gt; 添加web支持 web.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--乱码过滤--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--session--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; 配置springmvc的mvc层 spring-mvc.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!--1. 注解驱动--&gt;&lt;mvc:annotation-driven/&gt;&lt;!--2. 静态资源过滤--&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!--3. 扫描包--&gt;&lt;context:component-scan base-package=&quot;com.timous.controller&quot;/&gt;&lt;!--4. 视图解析器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;&lt;/beans&gt;","tags":["ssm"]},{"title":"HashMap源码探究","path":"/2022/01/14/HashMap源码探究/","content":"HashMap核心理论： Hash也称为散列、哈希，对应的英文都是Hash。&#x3D;&#x3D;基本原理就是把任意长度的输入，通过Hash算法，变成固定长度的输出&#x3D;&#x3D;，这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制就是哈希值（可能会有冲突) Hash的特点 从hash值不可以反向推到出原始的数据 输入数据的微小变化会得到完全不用的hash值，相同的数据会得到相同的值 哈希算法的执行效率高效，长的文本也能快速的计算出哈希值 hash算法的冲突概率要小 由于hash的原理是将输入空间的值映射成hash空间内，而hash值的空间远小于输入的空间。 根据抽屉原理，一定存在不同的输入映射到相同的输出的情况。 抽屉原理：桌子上有10个苹果，放到9个抽屉里面，无论是怎样放的，我们会发现至少有一个抽屉里面放了不少于两个苹果。这一现象我们称之为“抽屉原理”。 Map继承体系图 内部类： 123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; //存储hash值 与 hashcode还是有区别的 this.key = key; // 就是put的key值 this.value = value;// 就是put的value值 this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; &#x3D;&#x3D;当链表的长度达到9并且表中的数据超过64个的时候，链表就会进行树化&#x3D;&#x3D; map的put的过程 map.put(“timous”,”chenliuhong”); 获取timous字符串的hash值 经过hash值&#x3D;&#x3D;扰动函数&#x3D;&#x3D;，使hash值更加散列 构造出Node对象 Hash—–》1122 Key—》timous value —-&gt; chenliuhong next—-&gt;null 路由算法，找出node应该存放的数组的位置 路由寻址公式 ： (table.length-1)&amp;node.hash (16-1) &amp; 1122 &#x3D;》 B0000 0000 1111 &amp; B0100 0110 0010 &#x3D;》B0010 &#x3D;》2 这就是下标 表的长度一定是2的多少次方 16 32 64 等 Hash碰撞在上面的时候再插入一个值可能也会得到2这个下标 ， 所以出现了两个值，在同一个位置，这个时候就会发生hash碰撞 ， next就会指向下一个值，如果一直碰撞的话就会使我们的链表很长，在get的时候，就会遍历一个链表，比较长，本来时间复杂度是O(1)，但是退化之后就变成O(n)了，为了解决链化问题，就会出现了树化 手撕源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783package java.util;import java.io.IOException;import java.io.InvalidObjectException;import java.io.Serializable;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.function.BiConsumer;import java.util.function.BiFunction;import java.util.function.Consumer;import java.util.function.Function;import sun.misc.SharedSecrets;public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; private static final long serialVersionUID = 362498820763181265L; // static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; static final float DEFAULT_LOAD_FACTOR = 0.75f; static final int TREEIFY_THRESHOLD = 8; static final int UNTREEIFY_THRESHOLD = 6; static final int MIN_TREEIFY_CAPACITY = 64; static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; static Class&lt;?&gt; comparableClassFor(Object x) &#123; if (x instanceof Comparable) &#123; Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p; if ((c = x.getClass()) == String.class) // bypass checks return c; if ((ts = c.getGenericInterfaces()) != null) &#123; for (int i = 0; i &lt; ts.length; ++i) &#123; if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp; ((p = (ParameterizedType)t).getRawType() == Comparable.class) &amp;&amp; (as = p.getActualTypeArguments()) != null &amp;&amp; as.length == 1 &amp;&amp; as[0] == c) // type arg is c return c; &#125; &#125; &#125; return null; &#125; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) // for cast to Comparable static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123; return (x == null || x.getClass() != kc ? 0 : ((Comparable)k).compareTo(x)); &#125; static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; transient Node&lt;K,V&gt;[] table; transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; transient int size; transient int modCount; int threshold; final float loadFactor; public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; public boolean containsKey(Object key) &#123; return getNode(hash(key), key) != null; &#125; public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125; &#125; public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; putMapEntries(m, true); &#125; public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; &#125; final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null; &#125; public void clear() &#123; Node&lt;K,V&gt;[] tab; modCount++; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; size = 0; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; &#125; &#125; public boolean containsValue(Object value) &#123; Node&lt;K,V&gt;[] tab; V v; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; if ((v = e.value) == value || (value != null &amp;&amp; value.equals(v))) return true; &#125; &#125; &#125; return false; &#125; public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; if (ks == null) &#123; ks = new KeySet(); keySet = ks; &#125; return ks; &#125; final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; if (vs == null) &#123; vs = new Values(); values = vs; &#125; return vs; &#125; final class Values extends AbstractCollection&lt;V&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(); &#125; public final boolean contains(Object o) &#123; return containsValue(o); &#125; public final Spliterator&lt;V&gt; spliterator() &#123; return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super V&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.value); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es; &#125; final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(); &#125; public final boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Node&lt;K,V&gt; candidate = getNode(hash(key), key); return candidate != null &amp;&amp; candidate.equals(e); &#125; public final boolean remove(Object o) &#123; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Object value = e.getValue(); return removeNode(hash(key), key, value, true, true) != null; &#125; return false; &#125; public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123; return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; // Overrides of JDK8 Map extension methods @Override public V getOrDefault(Object key, V defaultValue) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? defaultValue : e.value; &#125; @Override public V putIfAbsent(K key, V value) &#123; return putVal(hash(key), key, value, true, true); &#125; @Override public boolean remove(Object key, Object value) &#123; return removeNode(hash(key), key, value, true, true) != null; &#125; @Override public boolean replace(K key, V oldValue, V newValue) &#123; Node&lt;K,V&gt; e; V v; if ((e = getNode(hash(key), key)) != null &amp;&amp; ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) &#123; e.value = newValue; afterNodeAccess(e); return true; &#125; return false; &#125; @Override public V replace(K key, V value) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) != null) &#123; V oldValue = e.value; e.value = value; afterNodeAccess(e); return oldValue; &#125; return null; &#125; @Override public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) &#123; if (mappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; V oldValue; if (old != null &amp;&amp; (oldValue = old.value) != null) &#123; afterNodeAccess(old); return oldValue; &#125; &#125; V v = mappingFunction.apply(key); if (v == null) &#123; return null; &#125; else if (old != null) &#123; old.value = v; afterNodeAccess(old); return v; &#125; else if (t != null) t.putTreeVal(this, tab, hash, key, v); else &#123; tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); return v; &#125; public V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; if (remappingFunction == null) throw new NullPointerException(); Node&lt;K,V&gt; e; V oldValue; int hash = hash(key); if ((e = getNode(hash, key)) != null &amp;&amp; (oldValue = e.value) != null) &#123; V v = remappingFunction.apply(key, oldValue); if (v != null) &#123; e.value = v; afterNodeAccess(e); return v; &#125; else removeNode(hash, key, null, false, true); &#125; return null; &#125; @Override public V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; &#125; V oldValue = (old == null) ? null : old.value; V v = remappingFunction.apply(key, oldValue); if (old != null) &#123; if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; else removeNode(hash, key, null, false, true); &#125; else if (v != null) &#123; if (t != null) t.putTreeVal(this, tab, hash, key, v); else &#123; tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); &#125; return v; &#125; @Override public V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123; if (value == null) throw new NullPointerException(); if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; &#125; if (old != null) &#123; V v; if (old.value != null) v = remappingFunction.apply(old.value, value); else v = value; if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; else removeNode(hash, key, null, false, true); return v; &#125; if (value != null) &#123; if (t != null) t.putTreeVal(this, tab, hash, key, value); else &#123; tab[i] = newNode(hash, key, value, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); &#125; return value; &#125; @Override public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key, e.value); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; @Override public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) &#123; Node&lt;K,V&gt;[] tab; if (function == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; e.value = function.apply(e.key, e.value); &#125; &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; @SuppressWarnings(&quot;unchecked&quot;) @Override public Object clone() &#123; HashMap&lt;K,V&gt; result; try &#123; result = (HashMap&lt;K,V&gt;)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; // this shouldn&#x27;t happen, since we are Cloneable throw new InternalError(e); &#125; result.reinitialize(); result.putMapEntries(this, false); return result; &#125; // These methods are also used when serializing HashSets final float loadFactor() &#123; return loadFactor; &#125; final int capacity() &#123; return (table != null) ? table.length : (threshold &gt; 0) ? threshold : DEFAULT_INITIAL_CAPACITY; &#125; private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; int buckets = capacity(); // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); s.writeInt(buckets); s.writeInt(size); internalWriteEntries(s); &#125; private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it&#x27;s the nearest public type to // what we&#x27;re actually creating. SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125; &#125; /* ------------------------------------------------------------ */ // iterators abstract class HashIterator &#123; Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e; &#125; public final void remove() &#123; Node&lt;K,V&gt; p = current; if (p == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); current = null; K key = p.key; removeNode(hash(key), key, null, false, false); expectedModCount = modCount; &#125; &#125; final class KeyIterator extends HashIterator implements Iterator&lt;K&gt; &#123; public final K next() &#123; return nextNode().key; &#125; &#125; final class ValueIterator extends HashIterator implements Iterator&lt;V&gt; &#123; public final V next() &#123; return nextNode().value; &#125; &#125; final class EntryIterator extends HashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125; &#125; /* ------------------------------------------------------------ */ // spliterators static class HashMapSpliterator&lt;K,V&gt; &#123; final HashMap&lt;K,V&gt; map; Node&lt;K,V&gt; current; // current node int index; // current index, modified on advance/split int fence; // one past last index int est; // size estimate int expectedModCount; // for comodification checks HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; this.map = m; this.index = origin; this.fence = fence; this.est = est; this.expectedModCount = expectedModCount; &#125; final int getFence() &#123; // initialize fence and size on first use int hi; if ((hi = fence) &lt; 0) &#123; HashMap&lt;K,V&gt; m = map; est = m.size; expectedModCount = m.modCount; Node&lt;K,V&gt;[] tab = m.table; hi = fence = (tab == null) ? 0 : tab.length; &#125; return hi; &#125; public final long estimateSize() &#123; getFence(); // force init return (long) est; &#125; &#125; static final class KeySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;K&gt; &#123; KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public KeySpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super K&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p.key); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super K&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; K k = current.key; current = current.next; action.accept(k); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; &#125; &#125; static final class ValueSpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;V&gt; &#123; ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public ValueSpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super V&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p.value); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super V&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; V v = current.value; current = current.next; action.accept(v); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0); &#125; &#125; static final class EntrySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public EntrySpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; Node&lt;K,V&gt; e = current; current = current.next; action.accept(e); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; &#125; &#125; Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(hash, key, value, next); &#125; // For conversion from TreeNodes to plain nodes Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(p.hash, p.key, p.value, next); &#125; // Create a tree bin node TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(hash, key, value, next); &#125; // For treeifyBin TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next); &#125; /** * Reset to initial default state. Called by clone and readObject. */ void reinitialize() &#123; table = null; entrySet = null; keySet = null; values = null; modCount = 0; threshold = 0; size = 0; &#125; // Callbacks to allow LinkedHashMap post-actions void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125; void afterNodeInsertion(boolean evict) &#123; &#125; void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125; // Called only from writeObject, to ensure compatible ordering. void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException &#123; Node&lt;K,V&gt;[] tab; if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; s.writeObject(e.key); s.writeObject(e.value); &#125; &#125; &#125; &#125; static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; /** * Returns root of tree containing this node. */ final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; &#125; static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123; int n; if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) &#123; int index = (n - 1) &amp; root.hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; if (root != first) &#123; Node&lt;K,V&gt; rn; tab[index] = root; TreeNode&lt;K,V&gt; rp = root.prev; if ((rn = root.next) != null) ((TreeNode&lt;K,V&gt;)rn).prev = rp; if (rp != null) rp.next = rn; if (first != null) first.prev = root; root.next = first; root.prev = null; &#125; assert checkInvariants(root); &#125; &#125; final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; &#125; while (p != null); return null; &#125; final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; return ((parent != null) ? root() : this).find(h, k, null); &#125; static int tieBreakOrder(Object a, Object b) &#123; int d; if (a == null || b == null || (d = a.getClass().getName(). compareTo(b.getClass().getName())) == 0) d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -1 : 1); return d; &#125; final void treeify(Node&lt;K,V&gt;[] tab) &#123; TreeNode&lt;K,V&gt; root = null; for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123; next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; if (root == null) &#123; x.parent = null; x.red = false; root = x; &#125; else &#123; K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; root = balanceInsertion(root, x); break; &#125; &#125; &#125; &#125; moveRootToFront(tab, root); &#125; final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123; Node&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; q = this; q != null; q = q.next) &#123; Node&lt;K,V&gt; p = map.replacementNode(q, null); if (tl == null) hd = p; else tl.next = p; tl = p; &#125; return hd; &#125; final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) &#123; Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) &#123; if (!searched) &#123; TreeNode&lt;K,V&gt; q, ch; searched = true; if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; &#125; dir = tieBreakOrder(k, pk); &#125; TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; &#125; &#125; &#125; final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable) &#123; int n; if (tab == null || (n = tab.length) == 0) return; int index = (n - 1) &amp; hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; if (pred == null) tab[index] = first = succ; else pred.next = succ; if (succ != null) succ.prev = pred; if (first == null) return; if (root.parent != null) root = root.root(); if (root == null || (movable &amp;&amp; (root.right == null || (rl = root.left) == null || rl.left == null))) &#123; tab[index] = first.untreeify(map); // too small return; &#125; TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement; if (pl != null &amp;&amp; pr != null) &#123; TreeNode&lt;K,V&gt; s = pr, sl; while ((sl = s.left) != null) // find successor s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors TreeNode&lt;K,V&gt; sr = s.right; TreeNode&lt;K,V&gt; pp = p.parent; if (s == pr) &#123; // p was s&#x27;s direct parent p.parent = s; s.right = p; &#125; else &#123; TreeNode&lt;K,V&gt; sp = s.parent; if ((p.parent = sp) != null) &#123; if (s == sp.left) sp.left = p; else sp.right = p; &#125; if ((s.right = pr) != null) pr.parent = s; &#125; p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; &#125; else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; if (replacement != p) &#123; TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; &#125; TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); if (replacement == p) &#123; // detach TreeNode&lt;K,V&gt; pp = p.parent; p.parent = null; if (pp != null) &#123; if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; &#125; &#125; if (movable) moveRootToFront(tab, r); &#125; final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // Relink into lo and hi lists, preserving order TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; if ((e.hash &amp; bit) == 0) &#123; if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; &#125; else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; if (loHead != null) &#123; if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; r, pp, rl; if (p != null &amp;&amp; (r = p.right) != null) &#123; if ((rl = p.right = r.left) != null) rl.parent = p; if ((pp = r.parent = p.parent) == null) (root = r).red = false; else if (pp.left == p) pp.left = r; else pp.right = r; r.left = p; p.parent = r; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; l, pp, lr; if (p != null &amp;&amp; (l = p.left) != null) &#123; if ((lr = p.left = l.right) != null) lr.parent = p; if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; l.right = p; p.parent = l; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; x.red = true; for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123; if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (!xp.red || (xpp = xp.parent) == null) return root; if (xp == (xppl = xpp.left)) &#123; if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123; xppr.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.right) &#123; root = rotateLeft(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateRight(root, xpp); &#125; &#125; &#125; &#125; else &#123; if (xppl != null &amp;&amp; xppl.red) &#123; xppl.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.left) &#123; root = rotateRight(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateLeft(root, xpp); &#125; &#125; &#125; &#125; &#125; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123; if (x == null || x == root) return root; else if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (x.red) &#123; x.red = false; return root; &#125; else if ((xpl = xp.left) == x) &#123; if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123; xpr.red = false; xp.red = true; root = rotateLeft(root, xp); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right; if ((sr == null || !sr.red) &amp;&amp; (sl == null || !sl.red)) &#123; xpr.red = true; x = xp; &#125; else &#123; if (sr == null || !sr.red) &#123; if (sl != null) sl.red = false; xpr.red = true; root = rotateRight(root, xpr); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr != null) &#123; xpr.red = (xp == null) ? false : xp.red; if ((sr = xpr.right) != null) sr.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateLeft(root, xp); &#125; x = root; &#125; &#125; &#125; else &#123; // symmetric if (xpl != null &amp;&amp; xpl.red) &#123; xpl.red = false; xp.red = true; root = rotateRight(root, xp); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right; if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red)) &#123; xpl.red = true; x = xp; &#125; else &#123; if (sl == null || !sl.red) &#123; if (sr != null) sr.red = false; xpl.red = true; root = rotateLeft(root, xpl); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl != null) &#123; xpl.red = (xp == null) ? false : xp.red; if ((sl = xpl.left) != null) sl.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateRight(root, xp); &#125; x = root; &#125; &#125; &#125; &#125; &#125; /** * Recursive invariant check */ static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) &#123; TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right, tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next; if (tb != null &amp;&amp; tb.next != t) return false; if (tn != null &amp;&amp; tn.prev != t) return false; if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right) return false; if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash)) return false; if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash)) return false; if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red) return false; if (tl != null &amp;&amp; !checkInvariants(tl)) return false; if (tr != null &amp;&amp; !checkInvariants(tr)) return false; return true; &#125; &#125;&#125;","tags":["源码"]},{"title":"linux安装mysql8","path":"/2022/01/14/linux安装mysql8/","content":"linux安装mysql81234567891011121314151617181920212223242526272829303132333435363738394041# 创建文件夹mkdir environment# 进入文件夹并且下载mysql8wget https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpmrpm -ivh mysql80-community-release-el7-1.noarch.rpm# 需要添加新的命令gpg --export -a 3a79bd29 &gt; 3a79bd29.ascrpm --import 3a79bd29.ascrpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022# 安装mysqlyum install -y mysql-community-server# 在这行这个命令之前先执行yum module disable mysql# 启动并且开机自启动systemctl start mysqldsystemctl enable mysqld# 查看mysql版本信息mysql -V# 查看mysql的临时密码grep &quot;A temporary password&quot; /var/log/mysqld.log# 进入mysql并且重新设置密码mysql -uroot -pALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;自己的mysql的密码&#x27;;# 下面是我自己设置的密码 ， 之后你还可以进行修改 一般这里必须进行修改密码之后再进行策略的修改mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;MYsql123.&#x27;;Query OK, 0 rows affected (0.01 sec)# 查看策略SHOW VARIABLES LIKE &#x27;validate_password%&#x27;;# 这里可能会因为你的密码过于简单有策略的问题，我们可以进行修改ERROR 1819 (HY000): Your password does not satisfy the current policy requirements# 修改策略set global validate_password.policy=0; //里面有很多策略，这里我设置了最简单的策略，学习的时候是可以使用的# 还要修改长度set global validate_password.length=6;# 必须重新进入才能进行mysql密码的简单设定ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;# 开启mysql的端口，默认是3306firewall-cmd --add-port=3306/tcp --permanentfirewall-cmd --reload mysql8下载成功 查看临时密码成功 进入mysql成功 密码策略查看的结果 修改策略成功 本地测试数据库的连接本地数据库需要mysql的授权1234use mysql;select host from user where user=&#x27;root&#x27;;update user set host = &#x27;%&#x27; where user =&#x27;root&#x27;;ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;; 连接成功","tags":["数据库"]},{"title":"vue初步探索","path":"/2022/01/13/vue初步探索/","content":"Vue0.学习目标 会创建vue实例，知道vue的常见属性 会使用vue的生命周期的钩子函数 能够使用vue的常见指令 能够使用vue计算属性和watch监控 能够编写vue组件 能够使用axios发布异步请求获取数据 1.vue概述1.1前言先了解一下前端开发模式的发展。 静态页面 最初的网页以html为主，是纯静态的网页，网页是只读的，信息流只能从服务端到客户端单项流通，开发人员也只关心页面的样式和内容。 异步刷新，操作DOM 1995年，网景工程师Brendan Rich花了10天时间设计了JavaScript语言。随着Javascript的诞生，我们可以操作页面的DOM元素以及样式，页面开始有了一些动态的效果，但是依然是以静态为主。 ajax盛行： 2005年开始，ajax逐渐被前端开发人员所重视，因为不用刷新页面就可以更新页面的数据和渲染效果。 此时的开发人员不仅要编写HTML样式，还要懂ajax与后端交互，然后通过JS操作DOM元素来实现页面的动态效果，，比较流行的框架如jQuery就是典型的代表。 MVVM， 关注模型和视图 2008年，Googlr的Chrom发布，随后就以极快的速度占领市场，超过IE成为浏览器的主导者。 2009年，Ryan Dahi在谷歌的Chrome V8引擎基础上，打造了基于事件循环的异步IO框架：Node.js 基于时间循环的异步IO 单线程运行，避免多线程的变量同步问题 JS可以编写后台diamante，前后台同一编程语言 Node.js的伟大之处不在于让JS迈向后端开发，而是构建了一个庞大的生态系统 2010年，NPM作为Node.js的包管理系统首次发布，开发人员可以遵循commmon.js规范来编写Node.js模块，然后发布到NPM上供其他开发人员使用，目前已经是世界最大的模块管理系统。 随后，在node的基础上，永喜出了一大批的前端框架： 框架 MVVM 最初发布时间 Knockout MVVM 2010年7月 Backbone MVP 2010年10月 Angular MVC-&gt;MVVM 2010年10月 Ember MVVM 2011年12月 Meteor MVC 2012年1月 Vue MVVM 2014年7月 MVVM模式 M:即Model，模型，包括数据和一些基本操作 V:即view，视图，页面渲染结果 VM: 即 view-model，模型与视图之间的双向操作（无需开发人员干涉） 在MVVM之前，开发人员从后端获取需要的数据类型，然后通过DOM操作Model渲染到view中。而后当用户操作视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。 而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不用再Model和View之间是如何互相影响的： 只要Model发生了改变，View自然就会表现出来 当用户修改了VIew，Model中的数据也会跟着改变 把开发人员从繁琐的DOM操作中解放出来，把关注点放在如何操作Model上面 MVVM前端框架Vue 1.2认识VueVue（读&#x2F;vju&#x2F;，类似于view）是一套用于构建用户界面的**渐进式架构。**与其他框架不同的是，Vue被设计为可以自底向上逐层应用，Vue核心库只关注视图层。不仅易于上手，还便于第三方库或者既有项目整合。另一方面，当与现代化的工具链以及各种支持类库集合使用的时候，Vue也完全能够为复杂的页面应用提供驱动。 前端框架三巨头：Vue.js,React.js,Angular.js Vue.js以轻量易用著称，Vue.js与React.js发展速度最快，渐进式：可以选择性的使用该框架的一个或者是一些组件，这些组件的使用也不需要将框架全部的组件都应用；而且用了这些组件也不要求你的系统全部都是用该框架 官网：https://cn.vuejs.org/ 参考：https://cn.vuejs.org/v2/guide/ 小结MVVM通过视图与模型的双向绑定，简化前端操作，vue是一款侵短的渐进式操作，可以提高前端开发操作 2.快速入门 可以在线引入vue.js 可以离线下载vue.js npm包资源管理器，可以下载 cdn方式引入&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; 2.1搭建vue工程1.创建一个web项目 2.引入vue.js(cdn npm 直接下载) 3.编写第一个vue程序 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;!--引入vue.js--&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.2演示双向绑定和事件处理1.创建页面 2.引入vue 3.编写代码 4.查看效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;input&quot; v-model=&quot;num&quot;&gt;&lt;button v-on:click=&quot;num++&quot;&gt;点击加一&lt;/button&gt; &lt;h2&gt;&#123;&#123; name &#125;&#125; 是一个&#123;&#123;num&#125;&#125;岁的人&lt;/h2&gt; &lt;span v-bind:title=&quot;message&quot;&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt;&lt;/div&gt;&lt;div id=&quot;app-3&quot;&gt; &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt;&lt;div id=&quot;app-4&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;div id=&quot;app-5&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;reverseMessage&quot;&gt;反转消息&lt;/button&gt;&lt;/div&gt;&lt;!--引入vue.js--&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; name: &#x27;陈留红&#x27;, num: 1, message: &#x27;页面加载与&#x27;+new Date().toLocaleDateString() &#125; &#125;); var app3 = new Vue(&#123; el: &#x27;#app-3&#x27;, data: &#123; seen: true &#125; &#125;) var app4 = new Vue(&#123; el: &#x27;#app-4&#x27;, data: &#123; todos: [ &#123; text: &#x27;学习 JavaScript&#x27; &#125;, &#123; text: &#x27;学习 Vue&#x27; &#125;, &#123; text: &#x27;整个牛项目&#x27; &#125; ] &#125; &#125;) var app5 = new Vue(&#123; el: &#x27;#app-5&#x27;, data: &#123; message: &#x27;Hello Vue.js!&#x27; &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 里面的数据可以根据我们的东西动态绑定 3.组件化应用构建组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;组件化应用构建&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app-7&quot;&gt; &lt;ol&gt; &lt;!-- 现在我们为每个 todo-item 提供 todo 对象 todo 对象是变量，即其内容可以是动态的。 我们也需要为每个组件提供一个“key”，稍后再 作详细解释。 --&gt; &lt;todo-item v-for=&quot;item in groceryList&quot; v-bind:todo=&quot;item&quot; v-bind:key=&quot;item.id&quot; &gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt;&lt;!--引入vue.js--&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#x27;todo-item&#x27;, &#123; props: [&#x27;todo&#x27;], template: &#x27;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&#x27; &#125;) var app7 = new Vue(&#123; el: &#x27;#app-7&#x27;, data: &#123; groceryList: [ &#123; id: 0, text: &#x27;蔬菜&#x27; &#125;, &#123; id: 1, text: &#x27;奶酪&#x27; &#125;, &#123; id: 2, text: &#x27;随便其它什么人吃的东西&#x27; &#125; ] &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.数据与方法当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。 1234567// 我们的数据对象var data = &#123; a: 1 &#125;// 该对象被加入到一个 Vue 实例中var vm = new Vue(&#123; data: data&#125;) 当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。也就是说如果你添加一个新的 property，比如：vm.b = &#39;hi&#39;,这个时候你去调用b是不会有值的。 那么对 b 的改动将不会触发任何视图的更新。如果你知道你会在晚些时候需要一个 property，但是一开始它为空或不存在，那么你仅需要设置一些初始值。比如： 12345678data: &#123; newTodoText: &#x27;&#x27;, visitCount: 0, hideCompletedTodos: false, todos: [], error: null， b: null&#125; 后面的时候你再去设置值就不会报错了 这里唯一的例外是使用 Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。 也就是说在你修改obj的值之后也不会再去动态修改我们的值 除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 $，以便与用户定义的 property 区分开来。例如： 123456789101112131415var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: &#x27;#example&#x27;, data: data&#125;)================== 上面的是用户自己定义的，下面的类似于系统的vm.$data === data // =&gt; truevm.$el === document.getElementById(&#x27;example&#x27;) // =&gt; true// $watch 是一个实例方法vm.$watch(&#x27;a&#x27;, function (newValue, oldValue) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;) 4.实例生命周期钩子每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 比如 created 钩子可以用来在一个实例被创建之后执行代码： 12345678910new Vue(&#123; data: &#123; a: 1 &#125;, created: function () &#123; // `this` 指向 vm 实例 console.log(&#x27;a is: &#x27; + this.a) &#125;&#125;)// =&gt; &quot;a is: 1&quot; 也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 mounted、updated 和 destroyed。生命周期钩子的 this 上下文指向调用它的 Vue 实例。 生命周期图示 5.模板语法5.1文本数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; Mustache 标签将会被替代为对应数据对象上 msg property 的值。无论何时，绑定的数据对象上 msg property 发生了改变，插值处的内容都会更新。通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 5.2原始HTML双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令： 注意：元素都是在data里面声明的 12&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt; # 这里输出的是普通的文本字符串&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; # 这里会输出span这个元素的东西 这个 span 的内容将会被替换成为 property 值 rawHtml，直接作为 HTML——会忽略解析 property 值中的数据绑定。注意，你不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位。 5.3AttributeMustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 v-bind 指令：&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 对于布尔 attribute (它们只要存在就意味着值为 true)，v-bind 工作起来略有不同，在这个例子中：&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; 如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled attribute 甚至不会被包含在渲染出来的 &#96;&#96; 元素中。 5.4使用 JavaScript 表达式1234567&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;div v-bind:id=&quot;&#x27;list-&#x27; + id&quot;&gt;&lt;/div&gt; 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。 5.5指令指令 (Directives) 是带有 v- 前缀的特殊 attribute。指令 attribute 的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在介绍中看到的例子： 1&lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt; # 如果seen为真，我们能够看见p这个标签，否则不能看到 这里，v-if 指令将根据表达式 seen 的值的真假来插入&#x2F;移除 &#96;&#96; 元素。 5.6参数一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML attribute： 1&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt; 在这里 href 是参数，告知 v-bind 指令将该元素的 href attribute 与表达式 url 的值绑定。 另一个例子是 v-on 指令，它用于监听 DOM 事件： 1&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt; 在这里参数是监听的事件名。我们也会更详细地讨论事件处理。 5.7动态参数从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数： 1&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt; 这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data property attributeName，其值为 &quot;href&quot;，那么这个绑定将等价于 v-bind:href。 同样地，你可以使用动态参数为一个动态的事件名绑定处理函数： 1&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt; 在这个示例中，当 eventName 的值为 &quot;focus&quot; 时，v-on:[eventName] 将等价于 v-on:focus。 在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写 5.8修饰符修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： 1&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt; 5.9缩写v- 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，v- 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue 管理所有模板的单页面应用程序 时，v- 前缀也变得没那么重要了。因此，Vue 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写： v-bind 缩写 12345678&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a :[key]=&quot;url&quot;&gt; ... &lt;/a v-on 缩写 12345678&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a @[event]=&quot;doSomething&quot;&gt; ... &lt;/a&gt; 6计算属性和侦听器6.1计算属性模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如： 123&lt;div id=&quot;example&quot;&gt; &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/div&gt; 在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多包含此处的翻转字符串时，就会更加难以处理。 所以，对于任何复杂逻辑，你都应当使用计算属性。 基础例子123456789101112131415161718192021222324&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt;var vm = new Vue(&#123; el: &#x27;#example&#x27;, data: &#123; message: &#x27;Hello&#x27; &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125; &#125;&#125;)结果：Original message: &quot;Hello&quot;Computed reversed message: &quot;olleH&quot; VUE实战1、GitLab安装1.安装相关依赖 yum -y install policycoreutils openssh-server openssh-client postfix 2.启动ssh服务并且设置为开机启动 systemctl enable sshd &amp;&amp; sudo systemctl start sshd 3.设置postfix开机自启，并启动，postfix支持gitlab发信功能 systemctl enable postfix &amp;&amp; systemctl VUE的学习所有的基础都是建立在我们的node.js等前端的东西都安装好的基础之上 1.初始化项目 新建文件夹 初始化项目 一路next进行安装route等。 等待完成 运行后的结果： 可以通过下面的修改我们的端口号： 运行测试： 运行的时候，# 我们也可以进行去掉这个在我们的route里面加上mode: &#39;history&#39;,定义一个这样的就行了 引入element-ui安装组件npm i element-ui -S 使用element-ui开发第一个vue程序 编写组件，从element-ui官网拿过来"},{"title":"leetcode笔试题","path":"/2022/01/12/leetcode笔试题/","content":"151. 翻转字符串里的单词https://leetcode-cn.com/problems/reverse-words-in-a-string/ 1.消除字符串中的多余的空格 0 1 2 3 4 5 6 7 8 9 10 11 12 13 a r e y o u o k 需要变成下面的： 0 1 2 3 4 5 6 7 8 9 10 11 12 13 a r e r y o u o k 将这个序列进行逆序 得到下面的序列 0 1 2 3 4 5 6 7 8 9 10 11 12 13 k o u o y e r a 将我们的每个单词进行逆序[0 , 2) , 然后就可以了 消除空格 ，得到有效字符串的长度 编写一个方法 ， 将字符串进行逆序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.timous.others;import com.sun.org.apache.regexp.internal.RE;/** * https://leetcode-cn.com/problems/reverse-words-in-a-string/ * 输入：&quot;the sky is blue&quot; * 输出：&quot;blue is sky the&quot; * * 输入：&quot; hello world! &quot; * 输出：&quot;world! hello&quot; * 解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 * * 输入：&quot;a good example&quot; * 输出：&quot;example good a&quot; * 解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 * * 输入：s = &quot; Bob Loves Alice &quot; * 输出：&quot;Alice Loves Bob&quot; * * 输入：s = &quot;Alice does not even like bob&quot; * 输出：&quot;bob like even not does Alice&quot; * * 1 &lt;= s.length &lt;= 104 * s 包含英文大小写字母、数字和空格 &#x27; &#x27; * s 中 至少存在一个 单词 * * 请尝试使用 O(1) 额外空间复杂度的原地解法。 * * 中间可能有多个字符 中间没有空格是一个单词 */public class _151_翻转字符串里的单词 &#123; public static void main(String[] args) &#123; String s = &quot;are you ok&quot;; System.out.println(reverseWords(s)); &#125; public static String reverseWords(String s) &#123; if (s == null) return null; char[] chars = s.toCharArray(); // 消除多余的空格 直接挪动我们的元素 ， 从前往后 //字符串最终的有效长度 int len = 0; int cur = 0; //前一个字符是不是为空格字符 一开始遇到的字符是空格的话就需要跳过 ， // 就需要为true 不然的话 一开始有空格的话就会增加长度 ， 前面的空格是我们不需要的 boolean space = true; for (int i = 0; i &lt; chars.length; i++) &#123; if (chars[i] != &#x27; &#x27;)&#123;//非空格字符 chars[cur++] = chars[i]; space = false; &#125;else if (space == false)&#123; //chars[i] 是空格字符 chars[i-1] 是非空格 chars[cur++] = &#x27; &#x27;; space = true; &#125; &#125; len = space ? cur-1:cur; System.out.println(len); //反转操作 写一个函数 reverseSingleWord(chars , 0 , len); cur = 0; // for (int i = 0; i &lt; len; i++) &#123; if (chars[i] == &#x27; &#x27;)&#123; reverseSingleWord(chars , cur , i); cur = i+1; &#125; &#125; reverseSingleWord(chars , cur , len); return new String(chars , 0 , len); &#125; //反转[l , r) 范围内的字符串逆转 也就是把第一个跟最后一个进行交换 private static void reverseSingleWord(char[] chars , int l , int r)&#123; r--; // l 跟 r进行交换 while (l &lt; r)&#123; char temp = chars[l]; chars[l] = chars[r]; chars[r] = temp; r--; l++; &#125; &#125;&#125; 3. 无重复字符的最长子串 pi li i-1 i D D 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.timous.others;import java.util.HashMap;import java.util.Map;/** * https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ */public class _3_无重复字符的最长子串 &#123; public static void main(String[] args) &#123; String s = &quot;abcabcbb&quot;; System.out.println(lengthOfLongestSubstring(s)); &#125; public static int lengthOfLongestSubstring(String s) &#123; if (s == null) return 0; char[] chars = s.toCharArray(); if (chars.length == 0) return 0; int[] array = new int[128]; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = -1; &#125; array[chars[0]] = 0; //扫描我们的字符串 int li = 0; int max = 1; for (int i = 1; i &lt; chars.length; i++) &#123; // chars[i] 上次出现的位置 int pi = array[chars[i]]; if (li &lt;= pi)&#123; li = pi + 1; &#125; max = Math.max(max , i - li + 1); //每次都要添加字符最新位置 array[chars[i]] = i; &#125; return max; &#125; public static int lengthOfLongestSubstring3(String s) &#123; if (s == null) return 0; char[] chars = s.toCharArray(); if (chars.length == 0) return 0; int[] array = new int[26]; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = -1; &#125; array[0] = 0; //扫描我们的字符串 int li = 0; int max = 1; for (int i = 1; i &lt; chars.length; i++) &#123; // chars[i] 上次出现的位置 int pi = array[chars[i] - 97]; if (li &lt;= pi)&#123; li = pi + 1; &#125; max = Math.max(max , i - li + 1); //每次都要添加字符最新位置 array[chars[i] - 97] = i; &#125; return max; &#125; public static int lengthOfLongestSubstring2(String s) &#123; if (s == null) return 0; char[] chars = s.toCharArray(); if (chars.length == 0) return 0; Map&lt;Character , Integer&gt; pre = new HashMap&lt;&gt;(); pre.put(chars[0] , 0); //扫描我们的字符串 int li = 0; int max = 1; for (int i = 1; i &lt; chars.length; i++) &#123; // chars[i] 上次出现的位置 int pi = pre.getOrDefault(chars[i], -1); if (li &lt;= pi)&#123; li = pi + 1; &#125; max = Math.max(max , i - li + 1); pre.put(chars[i] , i); &#125; return max; &#125;&#125; 剑指 Offer 47. 礼物的最大价值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364javapackage com.timous.动态规划;/** * https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/ */public class _剑指Offer47_礼物的最大价值 &#123; /** * 二位数组 * @param grid * @return */ public int maxValue(int[][] grid) &#123; if (grid == null) return 0; int rows = grid.length; int cols = grid[0].length; int[][] dp = new int[rows][cols]; dp[0][0] = grid[0][0]; // 初始化0行 for (int i = 1; i &lt; cols; i++) &#123; dp[0][i] = dp[0][i-1] + grid[0][i]; &#125; //初始化0列 for (int i = 1; i &lt; rows; i++) &#123; dp[i][0] = dp[i-1][0] + grid[i][0]; &#125; for (int row = 1; row &lt; rows; row++) &#123; for (int col = 1; col &lt; cols; col++) &#123; dp[row][col] = Math.max(dp[row-1][col] , dp[row][col-1]) + grid[row][col]; &#125; &#125; return dp[rows-1][cols-1]; &#125; /** * 一维数组 * @param grid * @return */ public int maxValue1(int[][] grid) &#123; if (grid == null) return 0; int rows = grid.length; int cols = grid[0].length; int[] dp = new int[cols]; int count = 0; //循环的次数 dp[0] = grid[0][0]; for (int i = 1; i &lt; cols; i++) &#123; dp[i] = dp[i-1] + grid[0][i]; &#125; for (int row = 1; row &lt; rows; row++) &#123; for (int col = 1; col &lt; cols; col++) &#123; if (col - 1 == 0)&#123; dp[0] = dp[0] + grid[row][0]; &#125; // 比较左边和上面值的大小 ， 如果是上面值是比较大的就选上面的 ， 反之选择最下面的 dp[col] = Math.max(dp[col-1] , dp[col]) + grid[row][col];// dp[col] = dp[col-1] + grid[row][col]; &#125; &#125; return dp[cols - 1]; &#125;&#125;","tags":["笔试"]},{"title":"git学习","path":"/2022/01/11/git学习/","content":"GitGit： 十分简单！！！Github版本控制 版本控制（Revision control）是一种在开发中的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便于恢复以前的版本的软件工程技术 实现扩区域多人协同开发、 追踪和记录一个或者多个文件的历史记录 组织和保护你的源代码和文档 统计工作量 并行开发，提高开发效率 跟踪记录整个软件的开发过程 减轻开发人员的负担，节省时间同时降低人为错误 简单的说就是用于管理多人协同开发项目的技术 没有进行版本控制或者版本控制本身缺乏正确的流程管理，在开发软件的过程中会引入很多的问题，如软件代码的一致性，软件内容的冗余，软件过程的事物性，软件开发过程中的并发性，软件源代码的安全性，以及软件的整合等问题 解决方案1 解决方案2 解决方案3 解决方案4 最终方案1 最终方案2 最终方案3 最终方案4 ……. 无论是工作还是学习，都经过这样一个阶段！ 我们迫切需要一个版本控制工具 多人开发必须要使用版本控制，不然的话可能会花比较大的代价 常见的版本控制工具 我们学习的东西一般都是当下最流行的 主流的版本控制器，有一下的这些： Git SVN（Subversion） CVS（Concurrent Version System） VSS（Micorosoft Visual SourceSafe） TFS（Team Foundation Server） Visual Studio Online 版本控制的产品非常的多（Perforce）等 最大的好处就是分布式版本控制 GIt和SVN的区别git是分布式的版本控制 svn是集中式的版本控制 Git可以直接看到更新了那些代码和文件操作Git是目前最新进的版本控制 Git环境配置所有东西下载慢的话一般都可以去找镜像 下载地址：http://npm.taobao.org/mirrors/git-for-windows 卸载Git 1.直接反安装即可 清理环境变量 2.卸载 安装 无脑下一步即可 启动Git Git Bash：Unix与linux风格的命令行，使用最多推荐最多 Git CMD：windows风格的命令行 Git GUI：图形界面的Git 不建议初学者使用，尽量先熟悉常用的命令 Git基本的linux命令学习 平时一定要多使用这些基础的命令 cd ： 改变目录 cd .. :回退到上一级目录 pwd ： 显示当前所在的目录 ls（ll）：都是列出当前目录中的所有文件只不过后面的列出的内容更为详细 touch： 新建一个文件，如touch index.js 就会在当前目录下新建一个index.js文件 rm： 删除一个文件 如 rm index.js mkdir： 新建一个目录，就是新建一个文件夹 rm -r： 删除一个文件夹 mv： 移动文件 reset： 重新初始化终端 clear ： 清屏 history： 查看历史命令 help：帮助 exit： 退出 # 表示注释 rm -rf &#x2F; 切勿在linux里面尝试 删除电脑的全部文件 Git配置 环境变量只是为了全局使用而已 默认会帮你配置所有的配置文件其实都保存在本地 查看配置git config -l 系统的配置git config --system --list 查看本地的配置git config --global --list 配置邮箱 必须要配置的 12git config --global user.name &quot;Timous&quot;git config --global user.email &quot;1844736251@qq.com&quot; Git理论（所有的时间都要源于这个理论） 工作区域 Git本地有三个工作区域： 工作目录， 暂存区，资源库。如果在加上远程的Git仓库，就可以分为四个工作区域，文件在这四个区域之间的转换关系如下： 工作路径： 写代码的空间 暂存区： 就是一些文件，基本看不到 Repository： 本地的代码库 Remote： 远程仓库 github gitee .git隐藏文件夹 Git项目搭建 创建工作目录与常用的指令 工作目录一般就是你希望Git帮助你管理的文件夹，可以是你的项目的目录，也可以是一个空的目录，建议不要有中文，日常只需要记住以下的6个命令 本地仓库搭建 创建本地仓库的方法有两种，一种是创建全新的仓库，另一种是克隆远程仓库 1.创建全新的仓库，需要Git管理的根目录执行 1234# 在当前目录创建一个新的Git代码库$ git initInitialized empty Git repository in D:/environment/gitcode/.git/ 2.克隆一个远程的仓库到本地 123456789git clone [url] # 克隆一个远程的地址的Cloning into &#x27;openclass&#x27;...remote: Enumerating objects: 272, done.remote: Counting objects: 100% (272/272), done.remote: Compressing objects: 100% (182/182), done.remote: Total 272 (delta 98), reused 119 (delta 68), pack-reused 0Receiving objects: 100% (272/272), 13.41 MiB | 1.54 MiB/s, done.Resolving deltas: 100% (98/98), done. 这个文件夹就是我们的远程的仓库克隆下来的地址 查看文件的状态 文件有四种状态，通过下面的命令可以有 123git add . # 添加所以文件到暂存区git status [filename] # 查看文件的状态git commit -m &quot;要备注的信息&quot; # 提交暂存区的内容到本地仓库 -m 提交信息 忽略文件 前端项目的总npm_moudels 有些时候我们不想把某些文件纳入版本控制中，如数据库文件，临时文件，设计文件等 在主目录下建立.gitignore文件，此文件有如下的规则： 忽略文件中的空行或者以#开始的行会被忽略 使用linux通配符，例如*代表任意多个字符 ？代表一个字符 []代表可选字符范围{} 代表可选字符串范围 如果名称的最前面有一个！，表示例外规则，将不被忽略 如果名称前面是一个&#x2F;表示要忽略的文件在此目录下，而子目录中的文件不被忽略 如果名称的后面是一个&#x2F;表示忽略的是此目录下该名称的子目录，而非文件 123456# 为注释*.txt # 忽略所有.txt结尾的文件！lib.txt # 但lib.txt除外/temp # 仅忽略项目根目录下的TODO文件，不包括其他的tempbuild/ # 忽略build/目录下的所有文件doc/*.txt # 会忽略 doc/*.txt 但是不包括 doc/server/arch.txt .gitignore文件1234567891011121314151617181920212223242526272829303132333435363738*.class*.log*.lock# Package Files #*.jar*.war*.eartarget/#idea.idea/*.iml*velocity.log*### STS ###.apt_generated.factorypath.springBeans### Intellij IDEA ###*.iml*.ipr*.iws*.idea.classpath.project.settings/bin/*.logtmp/#rebel*rebel.xml* 使用码云 github是有墙的，比较慢，在国内的话一般使用gitee gitlab 未来找工作的个人东西 设置本机绑定ssh公钥，实现免密登录 进入 ssh-keygen -t rsa 使用码云创建自己的仓库 许可证开源是否可以随意转载 ，开源不能商业使用，不能转载，限制 git clone https://gitee.com/timou_top/java-project.git克隆到本地 使用IDEA集成Git1.新建项目，绑定git 将我们的远程git文件目录拷贝到项目中即可 2.修改文件使用idea操作git 添加到暂存区 commit提交 push到远程仓库 3.提交测试 上面都是单个人的操作 说明：Git分支123456789101112131415161718# 查看所有的分支git branch# 查看远程所有的分支git branch -r# 新建一个分支，但是依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 合并指定分支到当前分支git merge [branch]# 删除远程仓库分支git push origin --delete [branch-name]git branch -dr [remote/branch] 我们多个分支如果并行执行，会导致我们代码不冲突，也就是同时存在多个版本！！！！ web-api A（Restful.xxxx（）） web-admin B 可能调用A 修改了A的代码 web-app C 可能会调用B和A的代码 冲突了协商即可 如果在同一个文件在合并分支的时候都被修改了，则会引起冲突：解决的办法就是我们可以修改冲突文件后重新提交！ master主分支应该非常稳定，用来发布新的版本，一般情况下不允许直接在上面工作，工作上的一般建立在dev上面，工作完之后，比如要发布，，或者说dev分支代码稳定之后可以合并到master上面来。 &#x3D;&#x3D;注意：找人一起搭建一个远程仓库，联系git，两个人或者是三个人都可以练习&#x3D;&#x3D; 团队很重要 寻找小伙伴","tags":["git"]},{"title":"jvm学习","path":"/2022/01/10/jvm学习/","content":"JVM探究 请你谈谈你对JVM的理解？ jvm8虚拟机和之前的变化 或者说更新 什么是OOM，什么是栈溢出StackOverFlowError Exception ？怎么分析 JVM的常用的调优参数有哪些？ 内存快照如何抓取，怎么分析Dump下来的文件？ 谈谈JVM中类加载器你的认识？？ 1.JVM的位置 2.JVM的体系结构 很多的第三方插件都是在执行引擎那一块加上的，其他的基本动不了 3.类加载器作用： 加载class文件 new Student(); 引用放在javaStack，但是具体的实例是放在堆里面的 1.虚拟机自带的加载器 2.启动类（根）加载器 3.扩展类加载器 4.应用程序加载器 5.双亲委派机制 4.双亲委派机制 沙箱安全机制Java安全模型的核心就是沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境，沙箱机制就是将java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，组织对本地系统造成破坏。沙箱主要限制系统资源访问，系统资源包括： CPU、内存、系统文件、网络。不同级别的沙箱对这些资源访问的限制也可以不一样 所有的java程序都可以指定沙箱，可以定制安全策略。 在java中将执行程序分为本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信任的。对于授信的本地代码可以访问一切本地资源。而对于非授信的远程代码在早期的java实现中，安全依赖于沙箱机制。如下图所示JDK1.0安全模型。 但如此严格的机制也给程序的功能带来障碍，比如用户希望远程代码访问本地系统的时候，就无法实现。因此在后续的java1.1版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型 在java1.2版本中，再次改进了安全机制，增加代码签名，不论本地代码或者是远程代码，都会按照用户的安全策略设定，由类记载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型 当前最新的安全机制实现，则引入了域（Domain）的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问，虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如图所示最新的安全模型。 组成沙箱的基本组件： 字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。 java javax 类装载器（class loader）：其中类装载器在3个方面对Java沙箱起作用 它防止恶意代码去干涉善意的代码； &#x2F;&#x2F;双亲委派机制 它守护了被信任的类库边界； 它将代码归入保护域，确定了代码可以进行哪些操作。3 虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一些列唯一的名称组成，每一个被装载的类有一个名字，这个命名空间是由java虚拟机为每一个类装载器维护的，他们互相之间甚至是不可见的。 类装载器采用的机制是双亲委派模式。 从内层JVM自带的类加载器开始加载，外层恶意同名类得不到加载进而无法使用； 由于严格的通过包来区分访问域，，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效 存取控制： 存取控制器可以控制核心API对操作系统的存取权限，而这个控制策略的设定可以由用户控制 安全管理器： 是核心API和操作系统之间的主要接口，实现权限控制，比存取控制器优先级别高 安全软件包： java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括： 安全提供者 消息摘要 数字签名 keytools https 生成一个安全证书 https通过java实现 加密 鉴别 6.Native12345678910111213141516171819package Native;public class Demo &#123; public static void main(String[] args) &#123; new Thread(()-&gt;&#123; &#125; , &quot;my thread name&quot;).start(); //凡是带了native关键字的，说明了java的作用范围打不到了，会去调用底层的c语言的库 //会进入本地方法栈 ， 调用本地方法接口 java native interface //JNI的作用就是为了扩展java的使用融合不同的编程语言为java所用 最初就是为了融合c和c++ // java诞生的时候 c 和 c ++ 横行，必须要用调用c和c++的程序 // 在内存中专门开辟了一块标记区域： native method stack 登记native方法 //在最终执行的时候，加载本地方法库中的方法 通过jni //private native void start0(); 就是一个单纯的class //java程序驱动打印机， java去管理系统 robot 写外挂 在企业级应用中较为少见 //调用其他接口： Socket webService http // 写其他的东西 通过socket来进行调用 &#125;&#125; 7.pc寄存器程序技术器： programe counter register 每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储执行一条指令的地址，也是即将要执行的指令代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计 8.方法区Method Area 方法区 方法区是被所有的线程共享的，所有的字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域中，此区域属于共享空间 静态变量、常量、类信息（构造方法和接口定义），运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关 static final Class 常量池 1234567891011package Native;public class Demo01 &#123; private int a; private String name; public static void main(String[] args) &#123; Demo01 demo01 = new Demo01(); demo01.a=1; demo01.name=&quot;113&quot;; &#125;&#125; 9.栈一种数据结构 ， 一般和队列做比较 程序 &#x3D; 数据结构 + 算法 程序 &#x3D; 框架 + 业务逻辑 淘汰 SSM SSH SpringBoot SpringCloud 栈： 新进后出 后进先出 类似于一个桶. 队列： 先进先出（FIFO） 为什么main先执行后结束 把mai方法丢进栈里面，然后依次进入往上压入的方法，一旦main方法结束，就相当于是整个程序结束了，栈溢出就是一些方法相互调用，然后如果特别多的话就会溢出 栈： 栈内存，主管程序的运行，生命周期和线程同步，线程结束我们的栈内存就会释放，对于栈来说，不存在垃圾回收问题，一旦线程结束，栈就会结束。 栈： 8大基本类型，对象的引用 实例的方法 栈运行原理： 栈帧 程序正在执行的方法，一定是在栈的顶部，直到栈的东西都弹出来 栈+堆+方法区的一些关系： 对象实例化的过程 10.三种JVM sun公司 HotSpot BEA公司的 JRockit IBM的j9vm JIT编译器 我们学习的都是hotspot的 11.堆（重点）Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。类加载器读取了文件之后，一般把啥东西放入堆中？ 类 方法 常量 变量，保存我们所有引用类型的真实对象 堆内存中还要分为三个内存： 新生区 养老区 永久区 GC垃圾回收主要在伊甸园和养老区 假设内存满了，就是oom，堆内存不够 java.lang.OutOfMemoryError: Java heap space 在8之后，永久存储区改了个名字，叫元空间 12.新生区老年区新生区 类： 诞生和成长的地方，甚至是死亡 伊甸园区： 所有的对象都时在伊甸园区中创建的 幸存者（0,1） 真理： 经过研究，99%的对象都是临时对象，进入养老区的并不是很多 13.永久区这个区域是常驻内存的，用来存放jdk自身携带的class对象。interface元数据， 存储的是java运行时的一些环境或者是类信息，这个区域不存在垃圾回收，在关闭虚拟机的时候回释放这个区域的内存 一个启动类，加载了大量的第三方jar包 一个tomcat部署了太多的应用 或者是大量动态生成的反射类 ， 如果这些类进行不断的加载，就可能放不下，知道内存满，就会出现OOM jdk1.6之前 ： 永久代 常量池是在方法区 jdk1.7 ： 永久代 但是慢慢退化了 去永久代 这个时候常量池是在堆中 jdk1.8之后 ： 无永久代，变成了元空间 常量池在元空间 现在的模型： 14.堆内存调优 123456789101112131415161718maxMemory:981.5totalMemory:981.5Heap PSYoungGen total 305664K, used 20971K [0x00000000eab00000, 0x0000000100000000, 0x0000000100000000) eden space 262144K, 8% used [0x00000000eab00000,0x00000000ebf7afb8,0x00000000fab00000) from space 43520K, 0% used [0x00000000fd580000,0x00000000fd580000,0x0000000100000000) to space 43520K, 0% used [0x00000000fab00000,0x00000000fab00000,0x00000000fd580000) ParOldGen total 699392K, used 0K [0x00000000c0000000, 0x00000000eab00000, 0x00000000eab00000) object space 699392K, 0% used [0x00000000c0000000,0x00000000c0000000,0x00000000eab00000) Metaspace used 3243K, capacity 4496K, committed 4864K, reserved 1056768K class space used 351K, capacity 388K, committed 512K, reserved 1048576KProcess finished with exit code 0# Metaspace 元空间 构思里面存在，但是在物理区域的时候没有这个# PSYoungGen + ParOldGen = 1005056k = 981.5 = totalMemory# -Xms1024m -Xmx1024m -XX:+PrintGCDetails# 把堆内存的空间调打，如果还不行，可能是代码有问题（专业工具） 1234567891011121314151617181920212223242526272829[GC (Allocation Failure) [PSYoungGen: 1536K-&gt;504K(2048K)] 1536K-&gt;687K(7680K), 0.0026000 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 1980K-&gt;503K(2048K)] 2164K-&gt;867K(7680K), 0.0014383 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 1762K-&gt;408K(2048K)] 2126K-&gt;1219K(7680K), 0.0012731 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 1779K-&gt;424K(2048K)] 2591K-&gt;2130K(7680K), 0.0012355 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 1341K-&gt;0K(2048K)] [ParOldGen: 5287K-&gt;1527K(5632K)] 6629K-&gt;1527K(7680K), [Metaspace: 3231K-&gt;3231K(1056768K)], 0.0052460 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 951K-&gt;0K(2048K)] 4268K-&gt;3317K(7680K), 0.0006889 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] 3317K-&gt;3317K(7680K), 0.0003715 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] [ParOldGen: 3317K-&gt;3316K(5632K)] 3317K-&gt;3316K(7680K), [Metaspace: 3231K-&gt;3231K(1056768K)], 0.0057998 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] 3316K-&gt;3316K(7680K), 0.0002574 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] [ParOldGen: 3316K-&gt;3296K(5632K)] 3316K-&gt;3296K(7680K), [Metaspace: 3231K-&gt;3231K(1056768K)], 0.0070062 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] Heap PSYoungGen total 2048K, used 42K [0x00000000ffd80000, 0x0000000100000000, 0x0000000100000000) eden space 1536K, 2% used [0x00000000ffd80000,0x00000000ffd8abc8,0x00000000fff00000) from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) to space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen total 5632K, used 3296K [0x00000000ff800000, 0x00000000ffd80000, 0x00000000ffd80000) object space 5632K, 58% used [0x00000000ff800000,0x00000000ffb38338,0x00000000ffd80000) Metaspace used 3263K, capacity 4496K, committed 4864K, reserved 1056768K class space used 353K, capacity 388K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space\tat java.util.Arrays.copyOf(Arrays.java:3332)\tat java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)\tat java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:674)\tat java.lang.StringBuilder.append(StringBuilder.java:208)\tat Native.Demo01.main(Demo01.java:12)Process finished with exit code 1# 当GC清理不了的时候才会进行报错 ， 是oom的错误 在一个线程中突然出现了一个oom故障，该如何排除 ， 研究为什么出错？ 能够看到代码的第几行出错？ ： 内存快照分析工具 MAT（eclipse），Jprofile（IDEA的） Debug一行一行分析代码 MAT（eclipse），Jprofile（IDEA的）作用： 分析Dump内存文件 ，快速定位内存泄露 获得堆中的数据 获得大的对象 ….. 123456# -Xmx1m 最小的内存 1/64# -Xmx8m 最大的内存 1/4# -XX:+HeapDumpOnOutOfMemoeyError 打印OOM的信息 # -XX:+PrintGCDetails 打印GC来及回收信息-Xmx1m -Xmx8m -XX:+HeapDumpOnOutOfMemoeyError# 要找其他的错误，只需要把后面的改了就行了 这种方式不知道第几行出问题了 15.GC垃圾回收 JVM在进行垃圾回收的时候，并不是对这三个区域进行统一的回收，大部分的时候的回收都是在新生代 新生代 幸存区（form to ） 老年区 GC两种类型： 轻GC 普通的GC 只针对新生代 ， 偶尔去轻幸存区 重GC 全局的GC 老年区 JVM的内存模行和分区： 详细到每个区放什么 堆里面的分区有哪些 ： eden from to old 说说他们的特点 GC的算法有哪些： 1. 标记清除法 2. 标记整理（标记压缩） 3. 复制算法 4. 引用计数法 普通GC和重GC分别在什么时候发生 引用计数法： 复制算法： 好处： 没有内存的碎片 坏处： 浪费了内存空间 多了一半内存空间永远是空 to 假设对象是100%存活（极端情况的时候回被放大） 复制算法最佳使用场景是对象存活度较低的情况： 新生区 标记清除算法： 缺点： 两次扫描 ， 严重浪费时间，会产生内存碎片 优点： 不需要额外的空间 标记压缩： 是对于标记清除的再优化 总结： 内存效率： 复制算法》标记清除算法》标记压缩（时间复杂度） 内存整齐度：复制算法》标记压缩》标记清除算法 内存利用率：标记压缩》标记清除算法》复制算法 思考： 难道没有最优的算法吗？ 没有最优的算法来进行调优，只有最合适的 GC： 分代收集算法 年轻代： 存活率低 复制算法 老年代： 区域大，存活率高 标记清除（内存碎片不是太多）+标记压缩混合实现 一天学JVM，不现实，要深究，必须花时间学习，多看面试题 16.JMM java memory model 什么是JMM 【JMM】（Java Memory Model的缩写）允许编译器和缓存以数据在处理器特定的缓存（或寄存器）和主存之间移动的次序拥有重要的特权，除非程序员使用了volatile或synchronized明确请求了某些可见性的保证。 他是干啥的 官方 博客 对应的视频 作用：缓存一致性协议，用于定义数据读写的规则。 JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory） 解决共享对象可见性这个问题，我们可以使用java volatile关键字或者是加锁 他如何学习 JMM是一个抽象的概念 volatile 123456789101112131415lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 17.总结1.百度 2.思维导图","tags":["虚拟机"]},{"title":"线程学习","path":"/2022/01/09/线程学习/","content":"线程（Thread）线程简介 多任务 多个任务，时间交替，开车打电话，吃饭玩手机，上厕所玩手机。 程序、进程（process）、线程（thread） 进程里面有多个线程 ， 进程里面有程序，进程是把程序跑起来。 线程实现（重点）进程和线程，进程里面有线程，一般还有一个垃圾回收线程gc线程 1、继承Thread类（重点） 2、实现Runnable接口（重点） 3、实现callable接口（了解） 自定义线程123自定义线程类继承Thread类重写run（）方法，编写线程执行体创建线程对象，调用start（）方法启动线程 继承Thread类12345678910111213141516171819202122232425262728package com.timous;//创建线程方式一 ： 继承Thread类 ， 重写run（）方法 ， 调用start（）方法 开启线程//注意： 线程开启不一定立即执行，等待cpu的调度public class TestThead extends Thread&#123; @Override public void run() &#123; //run方法的线程体 for (int i = 0; i &lt; 20; i++)&#123; System.out.println(&quot;我在看代码---&quot;+i); &#125; &#125; public static void main(String[] args) &#123; //创建一个线程对象，调用start方法，开启线程 TestThead testThead = new TestThead(); testThead.start(); //main线程，主线程 for (int i = 0; i &lt; 2000; i++) &#123; System.out.println(&quot;我在学习多线程---&quot;+i); &#125; &#125;&#125; 此处说明两条线程是同时执行的，不是先执行哪一个的，交替执行的。此处是cpu执行调度的，每次执行的结果不一定一样。 练习： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.timous;import org.apache.commons.io.FileUtils;import javax.swing.*;import java.io.File;import java.io.IOException;import java.net.MalformedURLException;import java.net.URL;//复习线程public class TestThreadDemo extends Thread&#123; private String url; //网络文件地址 private String name; //保存的文件名字 public TestThreadDemo(String url , String name)&#123; this.url = url; this.name = name; &#125; //下载图片的执行体 @Override public void run() &#123; WebDownLoader webDownLoader = new WebDownLoader(); webDownLoader.downLoader(url , name); System.out.println(&quot;下载了文件名为：&quot; + name); &#125; public static void main(String[] args) &#123; TestThreadDemo testThreadDemo1 = new TestThreadDemo(&quot;https://dss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1906469856,4113625838&amp;fm=26&amp;gp=0.jpg&quot;,&quot;1.jpg&quot;); TestThreadDemo testThreadDemo2 = new TestThreadDemo(&quot;https://dss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3892521478,1695688217&amp;fm=26&amp;gp=0.jpg&quot;,&quot;2.jpg&quot;); TestThreadDemo testThreadDemo3 = new TestThreadDemo(&quot;https://dss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1141259048,554497535&amp;fm=26&amp;gp=0.jpg&quot;,&quot;3.jpg&quot;); testThreadDemo1.start(); testThreadDemo2.start(); testThreadDemo3.start(); &#125;&#125;//下载器class WebDownLoader&#123; //下载方法 public void downLoader(String url , String name)&#123; try &#123; FileUtils.copyURLToFile(new URL(url) , new File(name)); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println(&quot;IO异常 ， downloader方法出现问题&quot;); &#125; &#125;&#125; 每次的结果不一定一样 实现Runnable接口1234567891011121314151617181920212223242526272829package com.timous;//创建线程方式二//实现runnable接口， 重写run方法 ， 执行线程丢入runnable接口实现，调用startpublic class TestThread02 implements Runnable&#123; @Override public void run() &#123; //run方法的线程体 for (int i = 0; i &lt; 20; i++)&#123; System.out.println(&quot;我在看代码---&quot;+i); &#125; &#125; public static void main(String[] args) &#123; //创建runnable接口的实例对象 TestThread02 testThead02 = new TestThread02(); //创建线程对象，通过线程对象来开启我们的线程 ， 代理// Thread thread = new Thread(testThead02);// thread.start(); new Thread(testThead02).start(); //main线程，主线程 for (int i = 0; i &lt; 500; i++) &#123; System.out.println(&quot;我在学习多线程---&quot;+i); &#125; &#125;&#125; 总结继承Thread类1、子线程继承Thread类具备多线程能力 2、启动线程： 子类对象.start() 3、不建议使用： 避免OOP单继承局限性 实现Runnable接口1、实现Runnable接口具有多线程能力 2、启动线程： 传入目标对象 + Thread对象.start() 3、推荐使用： 避免单继承的局限，灵活方便，方便同一个对象被多个线程使用 例子1234567891011121314151617181920212223242526272829303132333435363738394041package com.timous;//多个线程如何操作一个对象//买火车票的例子//发现问题： 多个线程在操作同一个资源的情况下，线程不安全，数据紊乱 , 线程的同步可以解决这个问题public class TestThreadDemo02 implements Runnable&#123; //票数 int ticknumbers = 10; @Override public void run() &#123; while(true)&#123; if(ticknumbers &lt;= 0)&#123; break; &#125; //模拟延时 try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;-----&gt;拿到了&quot;+ticknumbers--+&quot;票&quot;); &#125; &#125; public static void main(String[] args) &#123; TestThreadDemo02 testThreadDemo02 = new TestThreadDemo02(); new Thread(testThreadDemo02,&quot;小明&quot;).start(); new Thread(testThreadDemo02 , &quot;老师&quot;).start(); new Thread(testThreadDemo02 , &quot;黄牛&quot;).start(); &#125;&#125; 龟兔赛跑的例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.timous;//模拟龟兔赛跑public class Race implements Runnable&#123; private String winner; @Override public void run() &#123; for (int i = 0; i &lt;= 100; i++) &#123; //模拟乌龟休息// if(Thread.currentThread().getName() == &quot;乌龟&quot; &amp;&amp; i%10 == 0)&#123;//// try &#123;// Thread.sleep(1);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;//// &#125; //判断比赛是否结束 boolean flag = gameOver(i); //如果比赛结束，就停住程序 if(flag)&#123; break; &#125; System.out.println(Thread.currentThread().getName()+&quot;---&gt;跑了&quot;+i+&quot;步&quot;); &#125; &#125; //判断是否完成比赛 private boolean gameOver(int steps)&#123; //判断是否有胜利者 if(winner != null)&#123; //已经存在胜利者了 return true; &#125;else&#123; if(steps &gt;= 100) &#123; winner = Thread.currentThread().getName(); System.out.println(&quot;winner is&quot; + winner); return true; &#125; &#125; return false; &#125; public static void main(String[] args) &#123; Race race = new Race(); new Thread(race , &quot;兔子&quot;).start(); new Thread(race , &quot;乌龟&quot;).start(); &#125;&#125; 实现Callable接口1、实现Callable接口，需要返回值类型 2、重写call方法，需要抛出异常 3、创建目标对象 4、创建执行服务： EXecutorService ser &#x3D; EXecutors.newFixedThreadPool（1）； 5、提交执行: Future 6、获取结果: boolean r1 &#x3D; result1.get(); 7、关闭服务： ser.shutdownNow(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.timous.demo;//创建线程方式三 ，实现Callable接口import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;import java.net.URL;import java.util.concurrent.*;/** * callable的好处 * 可以定义返回值 * 可以跑出异常 */public class TestCallable implements Callable&lt;Boolean&gt; &#123; private String url; //网络文件地址 private String name; //保存的文件名字 public TestCallable(String url , String name)&#123; this.url = url; this.name = name; &#125; @Override public Boolean call() throws Exception &#123; WebDownLoader webDownLoader = new WebDownLoader(); webDownLoader.downLoader(url , name); System.out.println(&quot;下载了文件名为：&quot; + name); return true; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; TestCallable t1 = new TestCallable(&quot;https://dss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1906469856,4113625838&amp;fm=26&amp;gp=0.jpg&quot;,&quot;1.jpg&quot;); TestCallable t2 = new TestCallable(&quot;https://dss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3892521478,1695688217&amp;fm=26&amp;gp=0.jpg&quot;,&quot;2.jpg&quot;); TestCallable t3 = new TestCallable(&quot;https://dss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1141259048,554497535&amp;fm=26&amp;gp=0.jpg&quot;,&quot;3.jpg&quot;); //4、创建执行服务： ExecutorService ser = Executors.newFixedThreadPool(3); // 5、提交执行: Future&lt;Boolean&gt; result1 = ser.submit(t1); Future&lt;Boolean&gt; result2 = ser.submit(t2); Future&lt;Boolean&gt; result3 = ser.submit(t3); // 6、获取结果: boolean r1 = result1.get(); boolean r2 = result2.get(); boolean r3 = result3.get(); System.out.println(r1); System.out.println(r2); System.out.println(r3); //7、关闭服务： ser.shutdownNow(); &#125;&#125;//下载器class WebDownLoader&#123; //下载方法 public void downLoader(String url , String name)&#123; try &#123; FileUtils.copyURLToFile(new URL(url) , new File(name)); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println(&quot;IO异常 ， downloader方法出现问题&quot;); &#125; &#125;&#125; 静态代理模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.timous.proxystatic;import java.util.Map;//静态代理模式总结/** * 真实对象和代理对象都要实现同一个接口，代理对象要代理真实角色 */public class StatciProxy &#123; public static void main(String[] args) &#123; WeddingCompany weddingCompany = new WeddingCompany(new You()); weddingCompany.HappyMarry(); &#125;&#125;interface Marry&#123; //人间四大喜事 // 久旱逢甘露 他乡遇故知 洞房花烛夜 金榜题名时 void HappyMarry();&#125;//真是角色class You implements Marry&#123; @Override public void HappyMarry() &#123; System.out.println(&quot;我要结婚了！！！&quot;); &#125;&#125;//代理角色，帮助你结婚class WeddingCompany implements Marry&#123; //代理谁 private Marry target; public WeddingCompany(Marry target) &#123; this.target = target; &#125; @Override public void HappyMarry() &#123; before(); this.target.HappyMarry(); after(); &#125; private void after() &#123; System.out.println(&quot;结婚之后收尾款！！！&quot;); &#125; private void before() &#123; System.out.println(&quot;结婚之前布置现场！&quot;); &#125;&#125; 直接通过把自己给婚庆公司，进而达到结婚 好处： 可以做很多真实对象做不了的事情，真是对象专注做自己的事情 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.timous.proxystatic;import java.util.Map;//静态代理模式总结/** * 真实对象和代理对象都要实现同一个接口，代理对象要代理真实角色 */public class StatciProxy &#123; public static void main(String[] args) &#123; You you = new You(); //代理runnable接口 new Thread( ()-&gt; System.out.println(&quot;我爱你&quot;)).start(); new WeddingCompany(new You()).HappyMarry(); WeddingCompany weddingCompany = new WeddingCompany(you); weddingCompany.HappyMarry(); &#125;&#125;interface Marry&#123; //人间四大喜事 // 久旱逢甘露 他乡遇故知 洞房花烛夜 金榜题名时 void HappyMarry();&#125;//真是角色class You implements Marry&#123; @Override public void HappyMarry() &#123; System.out.println(&quot;我要结婚了！！！&quot;); &#125;&#125;//代理角色，帮助你结婚class WeddingCompany implements Marry&#123; //代理谁 private Marry target; public WeddingCompany(Marry target) &#123; this.target = target; &#125; @Override public void HappyMarry() &#123; before(); this.target.HappyMarry(); after(); &#125; private void after() &#123; System.out.println(&quot;结婚之后收尾款！！！&quot;); &#125; private void before() &#123; System.out.println(&quot;结婚之前布置现场！&quot;); &#125;&#125; Lamda表达式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package Lamda;public class TestLamda &#123; //静态内部类 static class Like2 implements ILike&#123; @Override public void lamda() &#123; System.out.println(&quot;I Like Lamda2!!!&quot;); &#125; &#125; public static void main(String[] args) &#123; ILike like1 = new Like1(); ILike like2 = new Like2(); like1.lamda(); like2.lamda(); //局部内部类 class Like3 implements ILike&#123; @Override public void lamda() &#123; System.out.println(&quot;I Like Lamda3!!!&quot;); &#125; &#125; ILike like3 = new Like3(); like3.lamda(); like1 = new ILike() &#123; @Override public void lamda() &#123; System.out.println(&quot;I Like Lamda4!!!&quot;); &#125; &#125;; like1.lamda(); //lamda简化 也就是匿名内部类 like1 = () -&gt; &#123; System.out.println(&quot;I Like Lamda5!!!&quot;); &#125;; &#125;&#125;//定义一个函数式接口interface ILike&#123; void lamda();&#125;class Like1 implements ILike&#123; @Override public void lamda() &#123; System.out.println(&quot;I Like Lamda!!!&quot;); &#125;&#125; 例子1234567891011121314151617181920212223242526272829303132333435363738394041package Lamda;public class TestLamda02 &#123; public static void main(String[] args) &#123;//// ILove love = (int a) -&gt; &#123;// System.out.println(&quot;I Love You ---&gt;&quot;+a);// &#125;; //去掉参数类型// ILove love = (a)-&gt; &#123;// System.out.println(&quot;I Love You ---&gt;&quot;+a);// &#125;; //简化括号// ILove love = a-&gt; &#123;// System.out.println(&quot;I Love You ---&gt;&quot;+a);// &#125;; //简化花括号 ILove love = a-&gt; System.out.println(&quot;I Love You ---&gt;&quot;+a); //总结： lamda表达式只能有一行的情况下能够简化为一行，如果有多行，就要用代码块包裹 ， 前提是必须是函数式接口 //多个参数也可以去掉参数类型，但是要保持一致，要去掉都去掉，不去掉都不能去掉，必须加上括号 love.love(520); &#125;&#125;interface ILove&#123; void love(int a);&#125; 线程状态 线程方法1234567891011setPriority(int newPriority) # 更改线程的优先级static void sleep(long millis) # 在指定的毫秒数内让当前正在执行的线程休眠void join() # 等待该线程终止static void yield() # 暂停当前正在执行的线程对象，并执行其他线程void interrupt() # 终端线程，别用这个方式boolean isAlive() # 测试线程是够处于活动状态 停止线程1、不推荐使用JDK提供的stop()、destory()方法【已经废弃了】 2、推荐线程自己停下来 3、&#x3D;&#x3D;建议使用一个标志位进行终止变量当flag&#x3D;false，则终止线程运行（推荐使用）&#x3D;&#x3D; 例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package Stop;//测试停止线程//1建议线程正常停止-------》利用次数，不建议死循环//2建议使用标志位-------》设置一个标志位//3不要使用stop或者destory等过时或者JDK不建议使用的方法public class TestStop implements Runnable&#123; //1.设置一个标志位 private boolean flag = true; @Override public void run() &#123; int i = 0; while(flag)&#123; System.out.println(&quot;run------Thread&quot;+i++); &#125; &#125; //2.设置一个公开的方法停止线程，转换标志位 public void stop()&#123; flag = false; &#125; public static void main(String[] args) &#123; TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(&quot;main&quot;+i); if (i == 900)&#123; //调用stop方法切换标志位，让线程停止 testStop.stop(); System.out.println(&quot;该线程该停止了！！！&quot;); &#125; &#125; &#125;&#125; 线程(sleep)休眠1、sleep（时间） 指定当前线程阻塞的毫秒数 2、sleep存在异常InterruptedException 3、sleep时间达到后线程就进入就绪状态 4、sleep可以模拟网络延迟、倒计时等 5、每一个对象都有一个锁，sleep不会释放锁 例子（倒计时和打印当前时间）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package Stop;import java.text.SimpleDateFormat;import java.util.Date;//模拟倒计时public class TestSleep02&#123; public static void tenDown() throws InterruptedException &#123; int num = 10; while(true)&#123; Thread.sleep(1000); System.out.println(num--); if (num&lt;0)&#123; break; &#125; &#125; &#125; //打印当前系统时间 public static void main(String[] args) &#123; try &#123; tenDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Date startTime = new Date(System.currentTimeMillis());//获取系统当前时间 while(true)&#123; try &#123; Thread.sleep(1000); System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime)); startTime = new Date(System.currentTimeMillis());//更新当前时间 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 线程礼让（yield）1、礼让线程，让当前正在执行的线程暂停，但不阻塞 2、让线程从运行状态转为就绪状态 3、让cpu重新调度，礼让不一定成功！看cpu心情 12345678910111213141516171819202122232425262728293031package yield;//测试礼让线程//礼让不一定成功，看cpu心情public class TestYield &#123; public static void main(String[] args) &#123; MyYield myYield = new MyYield(); new Thread(myYield,&quot;A&quot;).start(); new Thread(myYield,&quot;B&quot;).start(); &#125;&#125;class MyYield implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot;线程开始执行！！&quot;); Thread.yield();//礼让 System.out.println(&quot;线程礼让&quot;); System.out.println(Thread.currentThread().getName()+&quot;线程停止执行！！&quot;); &#125;&#125; Join1、Join合并线程，待线程执行完成后，再执行其他线程，其他线程阻塞 2、可以想象成插队 12345678910111213141516171819202122232425262728293031323334353637package Join;import Stop.TestStop;//测试join方法 想象为插队public class TestJoin implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(&quot;线程Vip来了&quot;+i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; //启动线程 TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); thread.start(); for (int i = 0; i &lt; 500; i++) &#123; if(i == 200)&#123; thread.join(); &#125; System.out.println(&quot;main&quot;+i); &#125; &#125;&#125; 线程状态(state)观测线程状态，可以处于以下状态之一： NEW 尚未启动的线程位于此状态 RUNNABLE 在Java虚拟机中执行的线程处于此状态 BLOCKED 被阻塞等待监视器锁定的线程处于此状态 WAITTING 正在等待另一个线程执行特定动作的线程处于此状态 TIMED_WAITTING 正在等待另一个线程执行动作达到指定的等待时间的线程处于此状态 TERMINATED 已退出的线程处于此状态 一个线程可以在给定时间点处于一个状态。这些状态是不反应任何操作系统线程状态的虚拟机状态。 JDK帮助文档 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package TestState;//测试线程的状态public class TestState &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(()-&gt;&#123; for (int i = 0; i &lt; 5; i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;======&quot;); &#125;); //观察状态 Thread.State state = thread.getState(); System.out.println(state); //观察启动后 thread.start(); state = thread.getState(); System.out.println(state); //只要线程不终止，就会一直输出 while(state != Thread.State.TERMINATED)&#123; Thread.sleep(100); state = thread.getState();//更新状态 System.out.println(state);//输出状态 &#125;// thread.start(); &#125;&#125; 注意： 结束的线程不能重新在开始 线程的优先级（Priority） java提供了一个线程调度器来监控程序中启动后进入就绪状态的所有的线程，线程调度器按照优先级决定调度那个线程来执行 线程的优先级用数字表示，范围从1到10 Thread.&lt;MIN_PRIORITY &#x3D; 1; Thread.MAX_PRIORITY &#x3D; 10; Thread.NORM_PRIORITY &#x3D; 5; 使用以下的方式改变或获取优先级 getPriority().setPriority(int xxx) 注意 线程的优先级高不一定限制性，跟cpu的调度有关系 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package TestState;//测试线程的优先级public class TestPriority &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName()+&quot;----&gt;&quot;+Thread.currentThread().getPriority()); Priority priority = new Priority(); Thread thread1 = new Thread(priority); Thread thread2 = new Thread(priority); Thread thread3 = new Thread(priority); Thread thread4 = new Thread(priority); Thread thread5 = new Thread(priority); Thread thread6 = new Thread(priority); //先设置优先级再启动 thread1.start(); thread2.setPriority(1); thread2.start(); thread3.setPriority(4); thread3.start(); thread4.setPriority(Thread.MAX_PRIORITY); //MAX_PRIORITY常量数字10 thread4.start(); thread5.setPriority(-1); thread5.start(); thread6.setPriority(11); thread6.start(); &#125;&#125;class Priority implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot;----&gt;&quot;+Thread.currentThread().getPriority()); &#125;&#125; . 注意： 要先设计优先级，再启动。 优先级低只是意味着获得调度的概率低，并不是优先级低的就不会被调用了，这都是看cpu的调度了。一般都是5，公平竞争 守护(daemon)线程 线程分为&#x3D;&#x3D;用户线程&#x3D;&#x3D;和&#x3D;&#x3D;守护线程&#x3D;&#x3D; 虚拟机必须确保用户线程执行完毕(&#x3D;&#x3D;main&#x3D;&#x3D;、&#x3D;&#x3D;gc&#x3D;&#x3D;) 虚拟机不用等待守护线程执行完毕 如，后台记录操作日志，监控内存，垃圾回收等待 例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package TestState;import java.awt.font.TextHitInfo;//测试守护线程public class TestDaemon &#123; public static void main(String[] args) &#123; God god = new God(); You you = new You(); Thread thread = new Thread(god); thread.setDaemon(true); thread.start(); new Thread(you).start();//用户线程启动 &#125;&#125;//上帝class God implements Runnable&#123; @Override public void run() &#123; while(true)&#123; System.out.println(&quot;上帝保佑着你！！&quot;); &#125; &#125;&#125;//你class You implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 36500; i++) &#123; System.out.println(&quot;你一生都在开心的活着！！&quot;); &#125; System.out.println(&quot;===goodbye world !&quot;); &#125;&#125; 线程同步（重点）发生在多个线程同时操作一个资源，也就是同一个对象被多个线程操作（解决的方法就是排队，在程序里面就是队列）也叫并发问题，对象的等待池。 队列+锁 synchronized（同步） 由于同一进程的多个线程共享一块存储空间，在带来方便的同时，也带来了访问冲突的问题，为了保证数据在方法中被访问时的正确性，在访问时加入了锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须进入等待，使用后释放锁即可，存在问题： 1.一个线程持有锁会导致其他所有需要此锁的线程挂起； 2.在多个线程竞争下，加锁，释放锁会导致比较多的上下文切换 和调度时延，引起性能问题； 3.如果一个优先级高的线程等待一个优先级低的线程释放锁 会导致优先级倒置，引起性能问题 三大不安全案例买票 例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package syn;//不安全的买票public class UnsafeBuyTicket &#123; public static void main(String[] args) &#123; BuyTicket buyTicket = new BuyTicket(); new Thread(buyTicket,&quot;小明&quot;).start(); new Thread(buyTicket,&quot;小红&quot;).start(); new Thread(buyTicket,&quot;黄牛&quot;).start(); &#125;&#125;class BuyTicket implements Runnable&#123; //票 private int tickets = 10; //循环标志 private boolean flag = true; @Override public void run() &#123; //买票 while(flag)&#123; buy(); &#125; &#125; private void buy()&#123; //判断是够有票 if(tickets &lt;= 0)&#123; flag = false; return; &#125; //模拟时延 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;拿到&quot;+tickets--); &#125;&#125; 银行取钱 例子： sleep可以放大问题的发生性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package syn;//不安全的取钱public class UnsafeBank &#123; public static void main(String[] args) &#123; Account account = new Account(100 , &quot;结婚基金&quot;); Drawing you = new Drawing(account,50,&quot;你&quot;); Drawing girlFriend = new Drawing(account,100,&quot;girlFriend&quot;); you.start(); girlFriend.start(); &#125;&#125;//客户class Account&#123; int money; String name; public Account(int money, String name) &#123; this.money = money; this.name = name; &#125;&#125;//银行class Drawing extends Thread&#123; Account account; //账户 int drawingMoney; int nowMoney; public Drawing(Account account , int drawingMoney , String name)&#123; super(name); this.account = account; this.drawingMoney = drawingMoney; &#125; //取钱 @Override public void run() &#123; if(account.money-drawingMoney &lt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;钱不够取不了&quot;); return; &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //卡内余额 account.money = account.money-drawingMoney; //手里的钱 nowMoney = drawingMoney; System.out.println(account.name+&quot;余额为：&quot;+account.money); //this.getName() == Thread.currentThread().getName() System.out.println(Thread.currentThread().getName()+&quot;手里的钱&quot;+nowMoney); &#125;&#125; List是不安全的 例子 123456789101112131415161718192021222324252627282930package syn;import org.omg.PortableServer.THREAD_POLICY_ID;import java.util.ArrayList;import java.util.List;//线程不安全的集合public class UnsafeList &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; new Thread(()-&gt;list.add(Thread.currentThread().getName())).start(); &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(list.size()); &#125;&#125; 同步方法 由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法synchronized方法和synchronized块 同步方法： public synchronized void method(int args){} synchronized方法控制对象的访问，每一个对象对应着一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行 缺陷：若将一个大的方法申明为synchronized将会影响效率 方法里面需要修改的内容才需要锁，锁的太多，浪费资源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package syn;//不安全的买票public class UnsafeBuyTicket &#123; public static void main(String[] args) &#123; BuyTicket buyTicket = new BuyTicket(); new Thread(buyTicket,&quot;小明&quot;).start(); new Thread(buyTicket,&quot;小红&quot;).start(); new Thread(buyTicket,&quot;黄牛&quot;).start(); &#125;&#125;class BuyTicket implements Runnable&#123; //票 private int tickets = 10; //循环标志 private boolean flag = true; @Override public void run() &#123; //买票 while(flag)&#123; buy(); &#125; &#125; //加入synchronized实现同步 锁的是this private synchronized void buy()&#123; //判断是够有票 if(tickets &lt;= 0)&#123; flag = false; return; &#125; //模拟时延 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;拿到&quot;+tickets--); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package syn;//不安全的取钱public class UnsafeBank &#123; public static void main(String[] args) &#123; Account account = new Account(100 , &quot;结婚基金&quot;); Drawing you = new Drawing(account,50,&quot;你&quot;); Drawing girlFriend = new Drawing(account,100,&quot;girlFriend&quot;); you.start(); girlFriend.start(); &#125;&#125;//客户class Account&#123; int money; String name; public Account(int money, String name) &#123; this.money = money; this.name = name; &#125;&#125;//银行class Drawing extends Thread&#123; Account account; //账户 int drawingMoney; int nowMoney; public Drawing(Account account , int drawingMoney , String name)&#123; super(name); this.account = account; this.drawingMoney = drawingMoney; &#125; //取钱 //synchronized默认锁的是this这个对象，也就是取钱，此处我们应该锁银行的 @Override public synchronized void run() &#123; if(account.money-drawingMoney &lt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;钱不够取不了&quot;); return; &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //卡内余额 account.money = account.money-drawingMoney; //手里的钱 nowMoney = drawingMoney; System.out.println(account.name+&quot;余额为：&quot;+account.money); //this.getName() == Thread.currentThread().getName() System.out.println(Thread.currentThread().getName()+&quot;手里的钱&quot;+nowMoney); &#125;&#125; 同步块 同步块： synchronized （Obj）{} Obj称之为同步监视器 Obj可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象的本身，或者是class【反射的时候集中讲】 同步监视器之星的过程 1.第一个线程访问，锁定同步监视器，执行其中的代码 2.第二个线程访问，发现同步监视器被锁定，无法访问 3.第一个线程访问完毕，解锁同步监视器 4.第二个线程访问，发现同步监视器没有锁，然后锁定并且访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package syn;//不安全的取钱public class UnsafeBank &#123; public static void main(String[] args) &#123; Account account = new Account(100 , &quot;结婚基金&quot;); Drawing you = new Drawing(account,50,&quot;你&quot;); Drawing girlFriend = new Drawing(account,100,&quot;girlFriend&quot;); you.start(); girlFriend.start(); &#125;&#125;//客户class Account&#123; int money; String name; public Account(int money, String name) &#123; this.money = money; this.name = name; &#125;&#125;//银行class Drawing extends Thread&#123; Account account; //账户 int drawingMoney; int nowMoney; public Drawing(Account account , int drawingMoney , String name)&#123; super(name); this.account = account; this.drawingMoney = drawingMoney; &#125; //取钱 //synchronized默认锁的是this这个对象，也就是取钱，此处我们应该锁银行的 @Override public synchronized void run() &#123; synchronized (account)&#123; if(account.money-drawingMoney &lt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;钱不够取不了&quot;); return; &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //卡内余额 account.money = account.money-drawingMoney; //手里的钱 nowMoney = drawingMoney; System.out.println(account.name+&quot;余额为：&quot;+account.money); //this.getName() == Thread.currentThread().getName() System.out.println(Thread.currentThread().getName()+&quot;手里的钱&quot;+nowMoney); &#125; &#125;&#125; 注意：锁的对象是变的量 1234567891011121314151617181920212223242526272829303132333435package syn;import org.omg.PortableServer.THREAD_POLICY_ID;import java.util.ArrayList;import java.util.List;//线程不安全的集合public class UnsafeList &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); synchronized (list) &#123; for (int i = 0; i &lt; 10000; i++) &#123; new Thread(() -&gt; list.add(Thread.currentThread().getName())).start(); &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(list.size()); &#125; &#125;&#125; JUC并发解决123456789101112131415161718192021222324252627282930package syn;import java.util.concurrent.CopyOnWriteArrayList;//测试juc安全类型的集合public class TestJuc &#123; public static void main(String[] args) &#123; CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; new Thread(()-&gt;&#123; list.add(Thread.currentThread().getName()); &#125;).start(); &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(list.size()); &#125;&#125; 这个时候的并发是安全的 死锁多个线程各自占有一些共享资源，并且相互等待其他线程占有的资源才能运行，而导致的两个或着多个线程都在等待对方的释放资源，都停止执行的情形，某一个同步块同时拥有“两个以上的对象的锁“时，就会发生”死锁的问题“。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package Lock;//多个线程互相抱着度一方的资源，然后形成僵持public class DeadLock &#123; public static void main(String[] args) &#123; Makeup g1 = new Makeup(0 , &quot;灰姑娘&quot;); Makeup g2 = new Makeup(1 , &quot;白雪公主&quot;); g1.start(); g2.start(); &#125;&#125;//口红class Lipstick&#123;&#125;//镜子class Mirror&#123;&#125;//化妆class Makeup extends Thread&#123; //需要的资源只有一份，用static来表示 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); int choice;//选择 String girlName;//使用化妆品的人 Makeup(int choice , String girlName)&#123; this.choice = choice; this.girlName = girlName; &#125; @Override public void run() &#123; //化妆 makeup(); &#125; //化妆，互相持有对方的锁，就是拿到对方的资源 private void makeup() &#123; if (choice == 0) &#123; synchronized (lipstick) &#123;//获得口红的锁 System.out.println(this.girlName + &quot;获得口红的锁&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //1秒之后想获得镜子 synchronized (mirror) &#123; System.out.println(this.girlName + &quot;获得镜子的锁&quot;); &#125; &#125; &#125; else &#123; synchronized (mirror) &#123;//获得口红的锁 System.out.println(this.girlName + &quot;获得镜子的锁&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //1秒之后想获得镜子 synchronized (lipstick) &#123; System.out.println(this.girlName + &quot;获得口红的锁&quot;); &#125; &#125; &#125; &#125;&#125; 不能持有对方的锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package Lock;//多个线程互相抱着度一方的资源，然后形成僵持public class DeadLock &#123; public static void main(String[] args) &#123; Makeup g1 = new Makeup(0 , &quot;灰姑娘&quot;); Makeup g2 = new Makeup(1 , &quot;白雪公主&quot;); g1.start(); g2.start(); &#125;&#125;//口红class Lipstick&#123;&#125;//镜子class Mirror&#123;&#125;//化妆class Makeup extends Thread&#123; //需要的资源只有一份，用static来表示 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); int choice;//选择 String girlName;//使用化妆品的人 Makeup(int choice , String girlName)&#123; this.choice = choice; this.girlName = girlName; &#125; @Override public void run() &#123; //化妆 makeup(); &#125; //化妆，互相持有对方的锁，就是拿到对方的资源 private void makeup() &#123; if (choice == 0) &#123; synchronized (lipstick) &#123;//获得口红的锁 System.out.println(this.girlName + &quot;获得口红的锁&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //1秒之后想获得镜子 synchronized (mirror) &#123; System.out.println(this.girlName + &quot;获得镜子的锁&quot;); &#125; &#125; else &#123; synchronized (mirror) &#123;//获得口红的锁 System.out.println(this.girlName + &quot;获得镜子的锁&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //1秒之后想获得镜子 synchronized (lipstick) &#123; System.out.println(this.girlName + &quot;获得口红的锁&quot;); &#125; &#125; &#125;&#125; 死锁避免的方法： 死锁产生的四个必要的条件 1.互斥条件：一个资源每次只能被一个进程使用 2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 3.不剥夺条件： 进程已获得的资源，在未使用完之前，不能强行剥夺 4.循环等待条件： 若干个进程之间形成了一种头尾相接的循环等待资源关系 上述死锁产生的四个必要的条件，我们只要想办法破其中任何一个或者是多个条件就可以避免死锁的发生 Lock 从jdk5.0开始，java提供了更强大的线程同步机制——通过&#x3D;&#x3D;显示定义同步锁对象来实现同步&#x3D;&#x3D;，同步锁使用lock对象充当 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象0 &#x3D;&#x3D;ReentrantLock（可重入锁）&#x3D;&#x3D;类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显示加锁，释放锁 测试锁： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package Lock;import com.sun.org.apache.xml.internal.utils.ThreadControllerWrapper;//测试lock锁public class TestLock &#123; public static void main(String[] args) &#123; TestLock2 testLock2 = new TestLock2(); new Thread(testLock2).start(); new Thread(testLock2).start(); new Thread(testLock2).start(); &#125;&#125;class TestLock2 implements Runnable&#123; int ticketNumbers = 10; @Override public void run() &#123; while (true)&#123; if(ticketNumbers &gt; 0)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(ticketNumbers--); &#125;else&#123; break; &#125; &#125; &#125;&#125; ReentrantLock（可重入锁） 测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package Lock;import com.sun.org.apache.xml.internal.utils.ThreadControllerWrapper;import java.util.concurrent.locks.ReentrantLock;//测试lock锁public class TestLock &#123; public static void main(String[] args) &#123; TestLock2 testLock2 = new TestLock2(); new Thread(testLock2).start(); new Thread(testLock2).start(); new Thread(testLock2).start(); &#125;&#125;class TestLock2 implements Runnable&#123; int ticketNumbers = 10; //定义可重入锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; while (true)&#123; try&#123; lock.lock();//加锁 if(ticketNumbers &gt; 0)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(ticketNumbers--); &#125;else&#123; break; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock();//解锁 &#125; &#125; &#125;&#125; synchronized与lock的对比 Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域，自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好、。并且具有更好的扩展性（提供更多的子类） 优先顺序 Lock &gt; 同步块代码（已经进入方法体，分配了相应的资源）&gt;同步方法（在方法体之外） 线程通信问题生产者和消费者模式（不是模式，是一个问题） 应用场景：生产者和消费这问题 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中的产品取走 消费 如果仓库中没有产品，则生产者将产品放入仓库否则停止生产并且等待，知道仓库中的产品被消费者取走为止 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并且等待，知道仓库中再次放入产品位置 线程通信 java提供了几个方法解决线程之间的通信问题 方法名 作用 wait() 表示线程一直等待，直到其他线程通知，与sleep不同。会释放锁 wait(long timeout) 指定等待的毫秒数 notify 唤醒一个处于等待状态的线程 notifyAll() 唤醒一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 &#x3D;&#x3D;注意&#x3D;&#x3D;：均是object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllegalMonitorStateException 解决方式1 并发协作模型生产者/消费者模式—&gt;管程法 生产者： &#x3D;&#x3D;负责生产数据的模块&#x3D;&#x3D;（可能是方法、对象、线程、进程） 消费者： &#x3D;&#x3D;负责处理数据的模块&#x3D;&#x3D;（可能是方法、对象、线程、进程） 缓冲区： &#x3D;&#x3D;消费者不能直接使用生产者的数据，他们之间有一个缓冲区&#x3D;&#x3D; &#x3D;&#x3D;生产者将生产好的数据放入缓冲区，消费者从缓冲区拿取数据&#x3D;&#x3D; 生产者消费者实例管程法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package gaoji;//测试生产者消费者模型---》利用缓冲区解决 管程法//生产者 消费者 缓冲区public class TestPC &#123; public static void main(String[] args) &#123; SynContainer container = new SynContainer(); new Productor(container).start(); new Consumer(container).start(); &#125;&#125;//生产者class Productor extends Thread&#123; SynContainer container; public Productor(SynContainer container)&#123; this.container = container; &#125; //生产 @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; container.push(new Chicken(i+1)); System.out.println(&quot;生产了&quot;+(i+1)+&quot;只鸡&quot;); &#125; &#125;&#125;//消费者class Consumer extends Thread&#123; SynContainer container; //消费 public Consumer(SynContainer container)&#123; this.container = container; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;消费了---》&quot;+container.pop().id+&quot;只鸡&quot;); &#125; &#125;&#125;//产品class Chicken&#123; int id; public Chicken(int id) &#123; this.id = id; &#125;&#125;//缓冲区class SynContainer&#123; int count = 0; //容器计数器 //需要一个容器大小 Chicken[] chickens = new Chicken[10]; //生产者放入产品 public synchronized void push(Chicken chicken)&#123; //如果容器满了，就需要等待消费者消费 if(count == chickens.length-1)&#123; //通知消费者消费，生产者等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如过没有满，需要生产者生产 chickens[count] = chicken; count++; //可以通知消费者消费了 this.notifyAll(); &#125; //消费者消费产品 public synchronized Chicken pop()&#123; //如果容器里面没有，消费者等待生产者生产 if(count == 0)&#123; //消费者等待生产者生产 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果容器里面有东西，消费者消费 count--; Chicken chicken = chickens[count]; //吃完了，通知生产 this.notifyAll(); return chicken; &#125;&#125; 解决方式2 并发协作模型“生产者&#x2F;消费者模式”—&gt;信号灯法 生产者和消费者信号灯法实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package gaoji;//信号灯法public class TestPC2 &#123; public static void main(String[] args) &#123; TV tv = new TV(); new Player(tv).start(); new Watcher(tv).start(); &#125;&#125;//生产者 演员class Player extends Thread&#123; TV tv; public Player(TV tv)&#123; this.tv = tv; &#125; //表演 @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if (i%2 == 0)&#123; this.tv.play(&quot;快乐大本营播放中&quot;); &#125;else&#123; this.tv.play(&quot;抖音&quot;); &#125; &#125; &#125;&#125;//消费者 观众class Watcher extends Thread&#123; TV tv; public Watcher(TV tv)&#123; this.tv = tv; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; this.tv.watch(); &#125; &#125;&#125;//节目class TV&#123; //演员表演，观众等待 //观众观看，演员等待 String voice; // 表演的节目 boolean flag = true; // true表示演员表演节目后，观众在观看节目 //表演 public synchronized void play(String voice)&#123; if (!flag)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;演员来了：&quot;+voice); //通知观众观看 this.notifyAll(); this.voice = voice; this.flag = ! this.flag; &#125; //观看 public synchronized void watch()&#123; if (flag)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;观看了：&quot;+voice); //通知演员表演 this.notifyAll(); this.flag = ! this.flag; &#125;&#125; 线程池使用线程池 背景： 经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大 思路： 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中，可以避免频繁创建销毁、实现重复利用。类似于生活中的交通工具（单车） -好处： 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 &#x3D;&#x3D;corePoolSize&#x3D;&#x3D;： 核心池的大小 &#x3D;&#x3D;maxmumPoolSize&#x3D;&#x3D;： 最大线程数 &#x3D;&#x3D;keepAliveTime&#x3D;&#x3D;： 线程没有任务是最多保持多长时间后会终止 JDK5.0起提供了线程池相关API： ExecutorService和Executors ExecutorService:真正的线程池接口。常见子类ThreadPoolExecutor &#x3D;&#x3D;void execute（Runnable command）&#x3D;&#x3D; ： 执行任务有返回值，一般用来执行Runnabke &#x3D;&#x3D; Future submit(Callable task)&#x3D;&#x3D; : 执行任务。有返回值，一般用来执行Callable &#x3D;&#x3D;void shutdown() :&#x3D;&#x3D; 关闭连接池 Executors ： 工具类、线程池的工厂类，用于创建并返回不同类型的线程池 测试 123456789101112131415161718192021222324252627282930313233343536package gaoji;import java.util.concurrent.Executor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;//测试线程池public class TestPool &#123; public static void main(String[] args) &#123; //1.创建线程池 //newFixedThreadPool(10) 线程池大小为10 ExecutorService service = Executors.newFixedThreadPool(10); //2.执行 service.execute(new MyThead()); service.execute(new MyThead()); service.execute(new MyThead()); service.execute(new MyThead()); //3.关闭连接 service.shutdown(); &#125;&#125;class MyThead implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125;&#125; 总结三种线程创建的方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package gaoji;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.Future;import java.util.concurrent.FutureTask;//回顾总结线程的创建public class ThreadNew &#123; public static void main(String[] args) &#123; //继承Thread，启动线程 new MyThead1().start(); //实现runnable接口，启动线程 new Thread(new MyThread2()).start(); //实现callable接口启动线程 FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new MyThread3()); new Thread(futureTask).start(); Integer integer = null; try &#123; integer = futureTask.get(); System.out.println(integer); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125;//1.继承Thread类class MyThead1 extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;MyThread1&quot;); &#125;&#125;//2. 实现runnable接口class MyThread2 implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;MyThread2&quot;); &#125;&#125;//3.实现callable接口class MyThread3 implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; System.out.println(&quot;MyThread3&quot;); return 100; &#125;&#125;","tags":["线程"]},{"title":"docker学习","path":"/2022/01/08/docker学习/","content":"Docker？ 2020年，docker必备的 Devops Docker 学习 Docker 运行 Docker概述 Docker安装 Docker命令 镜像命令 容器命令 操作命令 。。。 Docker镜像 容器数据卷 DockerFile 做镜像 Docker网络原理 IDEA整合Docker 到这就是单机版的docker 集群 Docker Compose 集群的编排管理 Docker Swarm 相当于简化版的k8s CI&#x2F;CD jenkins Docker概述Docker为什么会出现一款产品： 开发-》上线 两套环境！ 应用环境，应用配置 开发人员 运维人员 会产生问题 我在我的电脑上可以运行，你那不能运行 版本更新导致服务不可用 这些问题对于运维考验是十分大的 开发即运维！ 环境配置是比较麻烦的，每个机器都要部署环境（集群 redis hadoop ES 费时费力） 从根本上上解决问题 发布一个项目 jar war redis mysql jdk es 可能你部署环境的时候部署好久都不能部署完 我们可以带着环境去运行 项目能不能带着环境打包安装 Docker就是干这个事的 配置是十分麻烦的 不能跨平台的 环境是不能跨平台的，环境是天壤指别的 传统的给一个jar就行了，所有的东西交给运维就行了，现在的思想是我们把一套流程做完！ java—–》apk—-》发布 应用商店 软件会有人用 张三使用apk 下载安装即可用！ 我们现在就是这个逻辑，把环境和代码全部打包就可以 Docker仓库 类似一个商店 下载运行即可 Docker给以上的问题提出了解决方案！！！！ Docker的思想就来源于集装箱！ jre —– 多个应用 （端口冲突 配置错误，连接错误） —- 原来可能是交叉的 隔离：Docker的思想 打包装箱，每个箱子是互相隔离的，我们之后就不用担心端口或者是其他的环境出问题了 一个箱子装水果，一个箱子装生化武器 ，现在我们为了让这些东西放在一个环境，我们通过容器进行隔离，我们通过这个就直接可以使用隔离机制保护的很好 Docker通过隔离的机制，可以把服务器运行到极致 Tomcat 集群 或者是redis集群，我们通过docker一键就可以安装了 本质：所有的技术都是因为出现了问题，我们才会去学习，才会出现新的东西 Docker的历史2010年，几个搞it的年轻人，在美国成立了一家公司dotcloud 做一些pass的云计算服务 linux虚拟机 有关的容器技术 将自己的技术（容器化技术）进行统一的简化命名，Docker Docker刚刚诞生的时候，没有引起行业的注意，由于经济问题，dotcloud，经营不下去，开源开放源代码，让所有的人一起研发，2013年，Docker创始人将docker开源，很多人觉得技术可以，现在很多的人发现了docker的优点，所以就火了。几乎每个月就会更新一个版本。到了2014年4月9日docker1.0发布！6年几乎成为开发人员所必须的技术。 Docker为什么会这么火？ 十分轻巧 在容器出来之前，我们都使用的是虚拟机技术 虚拟机：在window装一个虚拟机软件wmware，通过这个软件我们可以虚拟一台或者是多台电脑，十分笨重的是基本的是十几个G的，笨重，好处是每个虚拟的电脑都相当于是一个真实的电脑。虚拟机是虚拟化技术，Docker容器技术也是一种容器化技术！ 例子： 12wm: linux centos 原生镜像（一整个电脑） 隔离需要开启多个虚拟机 一般都要几分钟docker容器： 隔离 镜像机制 只是一个最核心的环境 4m+jdk+mysql 直接运行镜像就可以了，这个东西是十分小巧的 容器是秒级的启动 聊聊DockerDocker是基于GO语言开发的开源项目 官网：https://www.docker.com/ 文档地址：https://docs.docker.com/get-docker/ Docker的文档是十分详细的！！！ 仓库地址：https://hub.docker.com/ pull push 发布到远程仓库也可以 Docker百度百科Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 Docker能干啥？ 之前的虚拟机技术 缺点: 资源占用十分多 冗余步骤多 启动十分的慢 容器化技术 &#x3D;&#x3D;容器化技术不是模拟的一个完整的操作系统，比如安装centos只需要一个核心&#x3D;&#x3D; 比较Docker和虚拟机技术的不同： 传统虚拟机虚拟出一套硬件，运行一个完整的操作系统，在这个系统安装软件运行 容器化技术是直接应用在宿主机的内容，容器是没有内核的，实现公用的内核，也没有虚拟我们的硬件，所有就轻便了 每个容器间是互相隔离的，每个容器都有一个自己的文件系统，互不硬性 Docker 3 30 利用这个linux的环境 DevOps 开发 运维 初级程序员 运维也一定要会 更快速的交付和部署 传统： 帮助文档 安装程序 部署 Docker： 打包镜像，发布测试，一键运行 更便捷的升级和扩缩容 使用了docker我们部署应用就和搭积木一样！！ springboot 1.5 redis 5 tomcat 8 现在我们通过docker就可以直接进行运行了 项目打包一个镜像，服务器A，可以直接在服务器B直接运行 更简单的系统运维 在容器化之后，我们的开发，运行测试基本环境都是高度一直的 更高小的资源利用 1核2G 可以几十个tomcat Docker 是内核级别的虚拟化，可以再咱们的一个物理机上可以运行很多的容器实例！！！服务器的性能可以被压榨到极致 Docker安装Docker基本组成 镜像 image: 就好比一个模板，可以通过模板来创建容器服务，tomcat镜像—-》run——》tomcat容器（提供服务），通过这个镜像可以创建多个容器（最终的服务或者是项目运行就是在这个容器中的） 容器 container：Docker利用容器技术，独立运行一个或者是一组应用，通过镜像来创建的，启动，停止，删除，基本命令！目前就可以把这个容器理解为一个简易的linux系统 仓库 repository：就是存储镜像的地方！！仓库分为公有仓库和私有仓库。Docker Hub（默认是国外的） 阿里云…都有容器服务器（我们可以配置镜像加速） 安装Docker环境准备 会一点的linux基础 Centos 7 我们使用xshell连接远程服务器进行操作 环境查看1234567891011121314151617181920# 系统的内核是3.10版本以上的[root@izbp169pmuqqu68q0mhkfaz /]# uname -r3.10.0-514.26.2.el7.x86_64# 系统版本[root@izbp169pmuqqu68q0mhkfaz /]# cat /etc/os-releaseNAME=&quot;CentOS Linux&quot;VERSION=&quot;7 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;7&quot;PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR=&quot;0;31&quot;CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;HOME_URL=&quot;https://www.centos.org/&quot;BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot; 安装1234567891011121314151617181920212223242526272829303132# 1.卸载旧的版本yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 2. 需要的安装包yum install -y yum-utils# 3. 设置镜像的仓库yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 这个是阿里云的 推荐使用，不然的话十分的慢 https://download.docker.com/linux/centos/docker-ce.repo # 默认的是国外的，我们使用国内的# 更新索引yum makecache fast# 4.安装docker最新的 docker-ce是社区版的 ee是企业版的 官方也使用ceyum install docker-ce docker-ce-cli containerd.io# 5.启动dockersystemctl start docker# 6.安装成功下图所示 12# 7.运行hello-worlddocker run hello-world 运行成功： 12# 8.查看hello-world镜像在不在docker images 卸载docker1234# 移除镜像yum remove docker-ce docker-ce-cli containerd.io# 删除工作目录rm -rf /var/lib/docker 设置阿里云加速 登录阿里云找到容器镜像服务 找到镜像加速 配置使用 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://5q2uftpp.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 回顾hello-world流程运行流程图 有些没有会找不到，报错 底层原理Docker是如何工作的 Docker是一个client-server结构的系统，Docker的守护运行在我们的主机上（宿主机），通过Socker从客户端访问 DockerServer接受DockerClient的指令，就会执行这个指令 Docker为什么比虚拟机快： 左边是虚拟机，右边是docker docker有着比虚拟机更少的抽象层 docker利用的是宿主机的内核，vm需要的是Guest OS 所以说，新建一个容器的时候，docker并不需要像虚拟机一样重新加载一个操作系统的内核，避免引导。虚拟机加载的是Guest OS，分钟级别的，而docker利用的是宿主机的操作系统，省略了这个复杂的过程 之后学习完毕所有的命令，在回过头来看这段理论就会十分清晰的 Docker的常用命令帮助命令123docker version # 显示docker的版本信息docker info # 显示更加详细的信息 镜像和容器的数量的等docker 命令 --help # 帮助 命令文档：https://docs.docker.com/reference/ 镜像的命令12345678910111213141516171819docker images # 查看所有本地主机上面的镜像[root@izbp169pmuqqu68q0mhkfaz /]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest bf756fb1ae65 9 months ago 13.3kBREPOSITORY # 镜像的仓库源TAG # 镜像的标签IMAGE ID # 镜像的idCREATED # 镜像的创建时间SIZE # 镜像的大小# 可选项 -a # 列出所有的镜像 -q # 只显示镜像的id -aq # 显示所有镜像的id docker search 可以直接去这个地址搜索镜像：https://registry.hub.docker.com/ 镜像搜索123456789101112131415docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10015 [OK] mariadb MariaDB is a community-developed fork of MyS… 3669 [OK] # 可选项 -f, --filter filter Filter output based on conditions provided # 过滤 --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don&#x27;t truncate output [root@izbp169pmuqqu68q0mhkfaz /]# docker search mysql --filter=STARS=3000NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10015 [OK] mariadb MariaDB is a community-developed fork of MyS… 3669 [OK] 下载镜像123456789101112131415161718192021222324252627282930313233343536373839404142docker pull mysql # 下载镜像 默认使用最新版[root@izbp169pmuqqu68q0mhkfaz /]# docker pull mysqlUsing default tag: latest # 如果不写tag默认是罪行的latest: Pulling from library/mysqld121f8d1c412: Pull complete # 分层下载 docker image的核心f3cebc0b4691: Pull complete 1862755a0b37: Pull complete 489b44f3dbb4: Pull complete 690874f836db: Pull complete baa8be383ffb: Pull complete 55356608b4ac: Pull complete dd35ceccb6eb: Pull complete 429b35712b19: Pull complete 162d8291095c: Pull complete 5e500ef7181b: Pull complete af7528e958b6: Pull complete Digest: sha256:e1bfe11693ed2052cb3b4e5fa356c65381129e87e38551c6cd6ec532ebe0e808 #签名Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest # 真实地址# 下面的这两个命令是等价的docker pull mysqldocker pull docker.io/library/mysql:latest# 指定版本下载[root@izbp169pmuqqu68q0mhkfaz /]# docker pull mysql:5.75.7: Pulling from library/mysql d121f8d1c412: Already exists # 之前下载过了，可以使用以前的东西f3cebc0b4691: Already exists 1862755a0b37: Already exists 489b44f3dbb4: Already exists 690874f836db: Already exists baa8be383ffb: Already exists 55356608b4ac: Already exists 277d8f888368: Pull complete 21f2da6feb67: Pull complete 2c98f818bcb9: Pull complete 031b0a770162: Pull complete Digest: sha256:14fd47ec8724954b63d1a236d2299b8da25c9bbb8eacc739bb88038d82da4919Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 docker rim删除镜像 没有全部删除，只删除了属于5.7版本的层次的东西 123docker rmi -f ef08065b0a30 # 删除指定id 的镜像docker rmi -f id [id] # 删除多个镜像docker rmi -f $(docker images -aq) #删除所有的镜像 容器命令说明： 我们有了镜像才会有容器，我们下载一个centos来测试学习 1docker pull centos 新建容器并且启动12345678910111213141516171819202122232425262728293031323334353637383940docker run [可选参数] image# 参数说明--name # 容器名字 tomcat01 用来区分容器-d # 后台运行-it # 使用交互模式运行-p # 指定的容器的端口 8080:8080 -p ip：主机端口：容器端口 -p 主机端口：容器端口 （常用） -p 容器端口 容器端口-P # 随机指定端口# 测试[root@izbp169pmuqqu68q0mhkfaz /]# docker run -it centos /bin/bash # 启动并且进入容器[root@42dde16a4b41 /]# # 此时已经在容器的内部了[root@42dde16a4b41 /]# lsbin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var# 上面的就是一个小型的服务器 跟外部的没有啥关系# 从容器中推到主机[root@42dde16a4b41 /]# exitexit[root@izbp169pmuqqu68q0mhkfaz /]# lsbin boot data dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var# 列出所有的运行的容器[root@izbp169pmuqqu68q0mhkfaz /]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42dde16a4b41 centos &quot;/bin/bash&quot; 4 minutes ago Exited (0) About a minute ago strange_hoover30aaa7b43000 bf756fb1ae65 &quot;/hello&quot; 2 hours ago Exited (0) 2 hours ago busy_ptolemy # 列出当前正在运行的容器-a # 列出当前正在运行的容器，还有历史运行的容器-n=? # 显示最近创建的容器-q # 只显示容器的编号 退出容器123exit # 容器停止退出ctrl+p+q # 容器停止不退出 删除容器1234docker rm 容器id # 删除指定的容器docker rm $(docker ps -aq) # 删除所有的容器# 不能删除正在运行的容器docker ps -a -qxargs docker rm # 删除所有的容器 启动和停止容器12345docker start 容器id # 启动启动容器docker stop 容器id # 停止当前正在运行容器docker restart 容器id # 重启容器docker kill 容器id # 强制停止当前容器 常用的其他命令123456789101112131415# 后台启动# docker run -d 镜像名docker run -d centos# 问题 ： docker ps 发现centos停止了# 常见的坑，容器使用后台运行，就必须要有一个前台进程，docker发现没有应用就会自动停止# nginx，容器启动之后，发现自己没有服务会立刻停止 发现没有程序了，最后就停止了# 查看日志 docker logsdocker logs -f -t --tail 19 26534cd836dc 没有日志，自己编写一段shell脚本--tail num # 要显示的日志条数-f # 带上时间戳&quot;while true:do echo timous;sleep 2;&quot; 查看容器中的进程信息 1234567891011[root@izbp169pmuqqu68q0mhkfaz /]# docker top --helpUsage:\tdocker top CONTAINER [ps OPTIONS]Display the running processes of a containerdocker top 容器id[root@izbp169pmuqqu68q0mhkfaz /]# docker top ee55e34eb941UID PID PPID C STIME TTY TIME CMDroot 17647 17626 0 16:06 ? 00:00:00 /bin/bash -c while true;do echo timous;sleep 1;doneroot 17987 17647 0 16:09 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1 查看镜像的元数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210docker inspect ee55e34eb941[root@izbp169pmuqqu68q0mhkfaz /]# docker inspect ee55e34eb941[ &#123; &quot;Id&quot;: &quot;ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3&quot;, &quot;Created&quot;: &quot;2020-10-04T08:06:10.003607393Z&quot;, &quot;Path&quot;: &quot;/bin/bash&quot;, &quot;Args&quot;: [ &quot;-c&quot;, &quot;while true;do echo timous;sleep 1;done&quot; ], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 17647, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2020-10-04T08:06:10.379247101Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125;, &quot;Image&quot;: &quot;sha256:0d120b6ccaa8c5e149176798b3501d4dd1885f961922497cd0abef155c869566&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3/ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3-json.log&quot;, &quot;Name&quot;: &quot;/charming_gates&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: &#123; &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: &#123; &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: &#123;&#125; &#125;, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: &#123;&#125;, &quot;RestartPolicy&quot;: &#123; &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 &#125;, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;Capabilities&quot;: null, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: false, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] &#125;, &quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/e9f1b7ac4782a1ff47ebd0ac9a25147a64006cc8b0ba8fdb86d31980438a3850-init/diff:/var/lib/docker/overlay2/2f1f2c9feada01705f5f971d6cbf9f5cdb6d64de3a48556ed7fada3f8252ac9d/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/e9f1b7ac4782a1ff47ebd0ac9a25147a64006cc8b0ba8fdb86d31980438a3850/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/e9f1b7ac4782a1ff47ebd0ac9a25147a64006cc8b0ba8fdb86d31980438a3850/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/e9f1b7ac4782a1ff47ebd0ac9a25147a64006cc8b0ba8fdb86d31980438a3850/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;, &quot;Mounts&quot;: [], &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;ee55e34eb941&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;while true;do echo timous;sleep 1;done&quot; ], &quot;Image&quot;: &quot;centos&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123; &quot;org.label-schema.build-date&quot;: &quot;20200809&quot;, &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;, &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;, &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;, &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot; &#125; &#125;, &quot;NetworkSettings&quot;: &#123; &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;9a08423b1508ec7922699865f0f5482ee7c6dc9a0b37451201e89a6a604cbc86&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: &#123;&#125;, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/9a08423b1508&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;86c2383afa0dc2f44b00f5d8ac8bc939a9b5080d01378021adbed863652bcd5d&quot;, &quot;Gateway&quot;: &quot;172.18.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.18.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;, &quot;Networks&quot;: &#123; &quot;bridge&quot;: &#123; &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;30b06d957b64f677ac44cc752d240e535850bb5bacc643d96dcf2ea976880c80&quot;, &quot;EndpointID&quot;: &quot;86c2383afa0dc2f44b00f5d8ac8bc939a9b5080d01378021adbed863652bcd5d&quot;, &quot;Gateway&quot;: &quot;172.18.0.1&quot;, &quot;IPAddress&quot;: &quot;172.18.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;, &quot;DriverOpts&quot;: null &#125; &#125; &#125; &#125;] 进入当前正在运行的容器 12345678910111213141516171819# 我们通常都是使用后台管理的方式进行运行的，我们需要进入容器，修改一些配置#命令docker exec -it 容器id /bin/bash[root@izbp169pmuqqu68q0mhkfaz /]# docker exec -it ee55e34eb941 /bin/bash[root@ee55e34eb941 /]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 08:06 ? 00:00:00 /bin/bash -c while true;do echo timous;sleep 1;doneroot 2075 0 0 08:40 pts/0 00:00:00 /bin/bashroot 2099 1 0 08:40 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1root 2100 2075 0 08:40 pts/0 00:00:00 ps -ef# 方式二docker attach 容器id# 测试[root@izbp169pmuqqu68q0mhkfaz /]# docker attach ee55e34eb941正在执行当前的代码exec 进入容器之后开启一个新的终端，可以在里面操作attach 进入容器正在执行的终端，不会启动新的进程 从容器拷贝文件到主机内 12345678910111213141516docker cp 容器id：容器内路径 目的主机路径[root@izbp169pmuqqu68q0mhkfaz home]# docker attach c6a9acaf91e5 [root@c6a9acaf91e5 /]# cd /home[root@c6a9acaf91e5 home]# ls[root@c6a9acaf91e5 home]# touch test.java[root@c6a9acaf91e5 home]# exit exit[root@izbp169pmuqqu68q0mhkfaz home]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc6a9acaf91e5 centos &quot;/bin/bash&quot; 2 minutes ago Exited (0) 4 seconds ago romantic_almeida[root@izbp169pmuqqu68q0mhkfaz home]# docker cp c6a9acaf91e5:/home/test.java /home[root@izbp169pmuqqu68q0mhkfaz home]# lsadmin staragent test.java timous.java www# 拷贝是一个手动过程 未来我们可以使用卷技术来进行实现 小结 123456789101112131415161718192021222324252627282930313233343536373839404142434445attach Attach to a running container # 当前 shell 下 attach 连接指定运行镜像build Build an image from a Dockerfile # 通过 Dockerfile 定制镜像commit Create a new image from a container changes # 提交当前容器为新的镜像cp Copy files/folders from the containers filesystem to the host path#从容器中拷贝指定文件或者目录到宿主机中create Create a new container # 创建一个新的容器，同run，但不启动容器diff Inspect changes on a container&#x27;s filesystem # 查看 docker 容器变化events Get real time events from the server # 从 docker 服务获取容器实时事件exec Run a command in an existing container # 在已存在的容器上运行命令export Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ]history Show the history of an image # 展示一个镜像形成历史images List images import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]info Display system-wide information # 显示系统相关信息inspect Return low-level information on a container # 查看容器详细信息kill Kill a running container # kill 指定 docker 容器load Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save]login Register or Login to the docker registry server # 注册或者登陆一个docker 源服务器logout Log out from a Docker registry server # 从当前 Dockerregistry 退出logs Fetch the logs of a container # 输出当前容器日志信息port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT #查看映射端口对应的容器内部源端口pause Pause all processes within a container # 暂停容器ps List containers # 列出容器列表pull Pull an image or a repository from the docker registry server #从docker镜像源服务器拉取指定镜像或者库镜像push Push an image or a repository to the docker registry server #推送指定镜像或者库镜像至docker源服务器restart Restart a running container # 重启运行的容器rm Remove one or more containers # 移除一个或者多个容器rmi Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]run Run a command in a new container # 创建一个新的容器并运行一个命令save Save an image to a tar archive # 保存一个镜像为一个tar 包[对应 load]search Search for an image on the Docker Hub # 在 docker hub 中搜索镜像start Start a stopped containers # 启动容器stop Stop a running containers # 停止容器tag Tag an image into a repository # 给源中镜像打标签top Lookup the running processes of a container # 查看容器中运行的进程信息unpause Unpause a paused container # 取消暂停容器version Show the docker version information # 查看 docker 版本号wait Block until a container stops, then print its exit code # 截取容器停止时的退出状态值 docker上面学的知识最基本的命令，还有很多的命令需要学习 作业练习Docker安装Nginx12345678910111213141516171819202122232425262728293031323334353637383940414243# 1. 搜索镜像 dockerhub上去搜索# 2. 下载镜像# 3. 运行下载的Nginx-d # 后台启动 --name 给容器起名字 -p 宿主机端口：容器内端口docker run -d --name nginx01 -p 3344:80 nginx# 本地测试 curlcurl localhost:3344# 测试结果&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;root@09646f289814:/# whereis nginxnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginxroot@09646f289814:/# cd /etc root@09646f289814:/etc# cd nginxroot@09646f289814:/etc/nginx# lsconf.d\tfastcgi_params\tkoi-utf koi-win mime.types modules nginx.conf scgi_params\tuwsgi_params win-utf **注意：**如果端口或者不能启动的话就直接重启docker 1[root@izbp169pmuqqu68q0mhkfaz home]# systemctl restart docker # 重启docker 端口暴露：、 思考问题： 我们每次改动nginx配置文件都需要进入容器的内部，我要是能够在容器外部提供一个映射路径，达到在容器外部修改文件，容器内部就可以自动修改？ -v 数据卷的技术 Docker安装Tomcat&#x3D;&#x3D;注意：&#x3D;&#x3D;这里的容器内部的和容器外部的端口都要打开的 123456789101112131415# 官方的使用docker run -it --rm tomcat:9.0# 我们之前都是启动的后台，停止容器之后还是可以找到的，上面的是用完就会删除的 但是不会删除镜像#下载启动# 测试访问没问题，但是没有出现tomcat页面 这是因为这是个不完整的版本的docker exec -it tomcat01 /bin/bash# 进入之后发现 没有webapps和ll命令 阿里云镜像的原因，默认是最小的镜像，所有的不必要的都剔除掉，保证最小可运行的环境cp -r webapps.dist/* webappsroot@5d448aeddfff:/usr/local/tomcat/webapps# lsROOT docs examples host-manager manager 思考问题： 我们以后部署项目，每次都进去是十分麻烦的，我们如果可以在容器外部提供一个映射路径，webapps，使得我们在外部放置的项目自动同步到我们的内部就好了。 部署es+kibana12345678910111213141516171819# es 暴露的端口很多# es 十分消耗内存# es的数据一般要放置到安全文件夹# --net somenetwork这是一个网络配置docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:tag# 下载启动docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2# 启动完之后发现自己的服务器都是很卡的 docker status 查看cpu的状态# 启动完之后发现自动关了# 测试es是否成功了# 开始测试的时候发现他自动停止了# 可以修改配置文件 -e 环境配置修改docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2 12345678910111213141516171819[root@izbp169pmuqqu68q0mhkfaz /]# clear[root@izbp169pmuqqu68q0mhkfaz /]# curl localhost:9200&#123; &quot;name&quot; : &quot;bf3f2cba9661&quot;, &quot;cluster_name&quot; : &quot;docker-cluster&quot;, &quot;cluster_uuid&quot; : &quot;6SNBo33YSSaOLNBJ8IN_SQ&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;7.6.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;docker&quot;, &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;, &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.4.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 作业：使用kibana连接 可视化 portainer 1docker run -d -p 8088:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true pontainer/pontainer Ranch （持续集成和部署） 什么是portainer？ Docker的图形化界面管理工具！提供一个后台模板供我们操作 1234567docker run -d -p 8088:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true pontainer/pontainer# 这个是我们的官方给的东西 上面的经过试验，不能使用$ docker volume create portainer_data$ docker run -d -p 8088:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainerhttp://localhost:8088/ 运行之后的截图 选择本地的 进入之后的面板 我们所有的信息都可以看到 我们平时不会使用，我们测试一下就可以了。 Docker镜像讲解镜像是什么镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件的所有内容，包括代码，运行时，库，环境变量和配置文件 所有的应用直接打包成为一个Docker镜像部署 如何得到镜像： 远程仓库下载 朋友拷贝给你 自己制作一个镜像Dockerfile Docker加载原理 UnionFS 联合文件系统 我们下载的时候看到的一层一层的就是这个 UnionFS（联合文件系统）： Union文件系统时一种分层、轻量级并且高性能的文件系统，它支持对文件系统的的修改，作为一次提交来一层一层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite severral directions into single virtual filesystem）.Union文件系统时Docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 特性： 一次同时加载多个文件系统，但是从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有的底层的文件和目录 类似于git 的版本控制 ， 每一次都会直接记录下来 比如tomcat和mysql都是在centos下面执行的，我们下载一个就够了（这只是一个说法） Docker镜像加载原理 docker的镜像实际上是由一层一层的文件系统组成，这种层级的文件系统UnionFS（联合文件系统） boorfs（boot file system）主要包含bootloader和kernel，bootloader主要用于引导加载kernel，linux刚启动的时候会加载bootfs文件系统，早Docker镜像的最底层bootfs，这一层和我们典型的linux&#x2F;unix系统是一样的，包含boot加载器和内核。当boot加载完成之后，整个内核就在内存中了，此时内存的使用权由bootfs转交给内核，此时系统也会卸载bootfs rootfs（root file system），在bootfs之上，包含的就是典型linux系统中的。&#x2F;dev, &#x2F;proc ,&#x2F;bin ,&#x2F;etc等标准文件和目录。rootfs就是各种不同的操作系统发行版本，比如ubuntu ，centos等等 平时我们安装的centos是需要好几个G的，为什么这里的centos才200M？ 对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令和程序库就可以了，因为底层都是直接用的Host的kernel，自己只需要提供rootfs就可以了，由此可见，对于不同的linux发行的版本，bootfs基本上是一致的，因此不同的发行版本可以使用一个bootfs。 分层理解 分层的镜像 我们可以去下载一个镜像，发现观察下载的日志输出，可以看到是一层一层的在下载 这里的每一层就是一个文件级的记录 理解： 所有的Docker镜像都是起始于一个基础的镜像层，当进行修改或增加新的内容的时候，就会在当前的镜像之上，创建新的镜像，举一个简单的例子，假如基于Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果该镜像中添加了python包，就会在基础的镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层 该镜像相当于已经包含了三个镜像层，如下图所示（这是一个用于演示的很简单的例子） 在添加额外的镜像的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要，下图举了一个简单的例子，每个镜像包含三个文件，而镜像包含了来自两个镜像层的六个文件 上图中的镜像层跟之前的图中略有区别，主要目的是便于展示文件 下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为上层的文件7是文件5的一个更新版本 这种情况下，上层镜像层中的文件覆盖了底层镜像中的文件。这样就使得文件的更新版本作为一个新的镜像层添加到镜像当中。Docker可以通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示同一的文件系统。Linux上可用存储的引擎有： AUFS、Overlay2、Device Mapper、Btrfs以及zfs。顾名思义，每种存储引擎都基于Linux中对应文件系统或者块设备技术，并且每种存储引擎都有独特的性能特点。 Docker在Windows上仅支持windowfilter一种存储引擎，该存储引擎基于NTFS文件系统之上实现了分层和COW[1]. 下图展示了与系统显示相同的三层镜像，所有镜像层堆叠合并，对外提供统一的视图 特点 Docker默认都是只读的，容器启动时，一个新的可写层被加载到镜像的顶部！ 这一层就是我们通常所说的容器层，容器层之下的都叫镜像层 也就是说原来的你是没有动，只是在上面添加了新的东西 如何提交一个自己的镜像 Commit镜像123docker commit # 提交容器成为一个新的副本# 命令和git类似docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器 id 目标镜像名：[TAG] 实战测试： 1234567# 启动一个默认的tomcat# 发现这个默认的tomcat是没有webapps应用的，镜像的原因，官方的镜像是默认没有webapps的文件的# 自己拷贝了应该有的文件# 将操作过的容器通过commit提交为一个镜像，我们以后就使用这个修改多的镜像就可以了，这就是我们自己修改过的一个镜像 学习方式说明： 概念 ，一定要实践，实践和理论像结合，一次搞定 如果你想保存当前容器的状态，，就可以通过commit来进行提交，获得一个镜像，就好比虚拟机的快照 现在就是入门 容器数据卷什么是容器数据卷docker的理念： ​\t将环境和应用打包成为一个镜像！！ 如果数据放在容器中，那么我们删除容器的时候，数据就会丢： 需要数据持久化 MySQL，容器删了，MySQL的数据可以保存在本地 容器之间可以有一个数据共享的技术！！Docker容器中产生的数据可以同步到本地，容器删除，数据不会丢失，这就是我们的卷技术！ 也就是目录的挂载，将我们的容器的目录挂在在linux上。 就是为了容器的持久化和同步操作，容器间的数据也是可以共享的 使用数据卷 使用命令来进行挂载 1docker run -it -p 主机端口：容器端口 -v 容器内的目录：主机目录 运行的容器的： 主机上面的： 从这里可以看出，我们的数据时挂载过来了 这也就类似于双向绑定，这样即使把容器删除之后也会保留数据的，缺点是数据会有两份的 即使容器停止之后，在宿主机修改文件，容器也是会更改的 实战： 安装mysqlmysql的数据持久化问题 data 123456789101112131415161718# 1. 获取镜像docker search mysql# 2. 运行容器 做数据挂载 # 安装启动mysql的时候需要配置密码的# 官方测试$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag# 启动mysql-d 后台运行-p 端口映射-v 路径挂载-- name 名字-e 配置环境# /home/mysql/conf:/etc/mysql/conf.d /home/mysql/conf 这个时候在5.7版本的是没有数据的，8.0以上的版本可能会有docker run -d -p 3344:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysqldev mysql# 此时的mysql的最新版本和旧的版本可能是不一样的 mysql5.7成功连接 但是最新的mysql用sqlyog或者是navcat都无法成功docker run -d -p 3355:3306 -v /home/mysql01/conf:/etc/mysql -v /home/mysql01/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 经过查看之后发现是因为加密规则发生了变化， 123456789101112131415# 进入mysql8.0版本的docker exec -it acd145dcb29d /bin/bash# 进入我们的mysqlroot@acd145dcb29d:/# mysql -uroot -pEnter password: Welcome to the MySQL monitor# 修改加密规则mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27; PASSWORD EXPIRE NEVER;Query OK, 0 rows affected (0.24 sec)mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;Query OK, 0 rows affected (0.02 sec)# 修改加密规则之后修改密码mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;Query OK, 0 rows affected (0.01 sec) 此时我们再通过连接发现已经可以连接上去了： 在本地创建数据库，查看映射的路径也是没有问题的，经过测试在干掉mysql容器之后，服务器本地依然书没有数据的丢失的 具名挂载和匿名挂载12345678910111213141516# 匿名挂载-v 容器内路径docker run -d -p --name nginx01 -v /etc/nginx nginx# 查看所有的卷的情况# -v 卷名:容器内路径docker volume lsDRIVER VOLUME NAMElocal edfe864135f1168478f3f213897a44bd3fa637309aad854a37a4ea02ba2fa736 # 这个时候匿名挂载local portainer_data local 47b671908d5e1b9b7abe1b3e07ea090e1a45061f0cc6f98000c3d7e07c0d1c6elocal edfe864135f1168478f3f213897a44bd3fa637309aad854a37a4ea02ba2fa736local nginxtest # 这个是具名挂在local portainer_data 所有docker容器内的卷，没有指定目录的情况下，都是在/var/lib/docker/volumes/nginxtest/_data 我们通过具名挂载可以方便的找到我们的一个卷，大多数情况下使用具名挂载 如何确定是具名挂载还是匿名挂载，还是指定路径挂载 123456-v 容器内路径 # 匿名挂载-v 卷名：容器内路径 # 具名挂载-v /宿主机路径：容器内路径 # 指定路径挂载ro/rw # 这个是指定读写权限的 ro read only rw read write# 一旦设定了 ro 我们就改动不了了 ro意思是只能从外部改变，不能从内部改变 也就是宿主机可以改变，但是容器内不能改变docker run -d -P --name nginx05 -v nginxtest:/etc/nginx：ro/rw nginx 初识DockerFiledockerfile就是用来构建docker镜像文件的构建文件！！命令脚本 方式二 123456789101112# 通过这个脚本可以生成镜像 ， 镜像是一层一层的，脚本是一个一个命令，每个命令就是一层# 指令和参数FROM centos VOLUME [&quot;volumn01&quot;,&quot;volumn02&quot;]CMD echo &quot;---end------&quot;CMD /bin/bash# 这里的每个命令就是一层 -f 文件所在的位置 -t 生成的镜像的名字和版本 # 注意这里的后面有一个点是必须加上的docker build -f dockerfile1 -t timouscentos:1.0 . 启动自己生成的容器 上面的两个是我们在生成镜像的时候所挂载的，这个卷和外部肯定有一个同步的目录，这个是匿名挂载，找的时候是乱码 从我们的Mounts，可以看到为止 这种方式我们使用的十分多，通常我们会构建自己的镜像 假设构架你的时候没有挂载卷，要手动进行镜像挂载 -v 卷名：容器内路径 数据卷容器是多个容器之间共享数据 ， 如多个mysql数据同步 contos01就是数据卷容器，两个或者是多个容器实现数据共享 12# 通过自己写的镜像启动docker run -it --name docker03 --volumes-from docker01 5d8055e306ce docker01 docker02 docker01创建文件 docker02 docker01创建的东西，docker02也能接收到，docker run -it --name docker03 --volumes-from docker01 5d8055e306ce，只要通过这种进行挂载的，都会成功进行共用。此时就算docker01容器没有的时候，我们的02和03依然是可以访问之前创建的文件的。 最主要的还是他们都挂载在相同的目录了 mysql数据共享多个mysql实现数据共享，redis实现数据共享 123456# docker run -d -p 3355:3306 -v /home/mysqltest1/conf:/etc/mysql -v /home/mysqltest1/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7docker run -d -p 3344:3306 -e MYSQL_ROOT_PASSWORD=123456 --volumes-from mysql01 --name mysql02 mysql:5.7# 这个时候就会实现数据的共享 结论： 容器之间配置信息的传递，容器数据卷的生命周期会一直持续到没有容器使用为止 但是一旦持久化到了本地，这个时候本地的数据是不会删除的 但是这种挂载启动的时候发现mysql是无法同时登陆两个的，可能是因为二者公用的是一个数据，所以一个连接的时候另外一个不能连接 DockerFiledockerfile是用来构建docker镜像的文件命令参数脚本 构建步骤： 编写一个dockerfile文件 docker build 构建一个镜像 docker run 运行镜像 docker push 发布镜像 DockerHub 阿里云镜像仓库等 查看官方是怎么做的 这就是一个基本的命令脚本。 123456789101112131415FROM scratch # 这是一个最基础的ADD centos-7-x86_64-docker.tar.xz / #添加一个centos的镜像LABEL \\ org.label-schema.schema-version=&quot;1.0&quot; \\ org.label-schema.name=&quot;CentOS Base Image&quot; \\ org.label-schema.vendor=&quot;CentOS&quot; \\ org.label-schema.license=&quot;GPLv2&quot; \\ org.label-schema.build-date=&quot;20200809&quot; \\ org.opencontainers.image.title=&quot;CentOS Base Image&quot; \\ org.opencontainers.image.vendor=&quot;CentOS&quot; \\ org.opencontainers.image.licenses=&quot;GPL-2.0-only&quot; \\ org.opencontainers.image.created=&quot;2020-08-09 00:00:00+01:00&quot;CMD [&quot;/bin/bash&quot;] 很多官方的镜像都是基础包，很多的功能是没有的，我们通常会自己搭建自己的镜像 官方可以制作镜像，我们也可以制作自己的镜像 DockerFile构建过程 基础知识： 保留的关键字都必须是大写字母 执行顺序从上到下 #表示注释 每一条命令都是一层 DockerFile是面向开发的，我们以后要发布项目做镜像，我们就要编写dockerfile文件，这个文件十分简单 Docker镜像已经逐渐成为企业交付的标准，必须掌握 步骤 开发 部署 上限 运维 DockerFile： 构建文件，定义了一切的步骤，好比一个源代码 DockerIamages ： 通过DockerFile构建成的镜像，最终发布和运行的产品 Docker容器: 容器就是镜像运行起来提供服务的 DockerFile的指令12345678910111213141516# 上面我们都是使用别人的，现在我们就可以自己写一个镜像了FROM # 基础镜像， 一切从这里开始构建MAINTAINER # 镜像是谁写的 姓名+邮箱RUN # docker镜像运行时需要构建的路径ADD # 步骤 ， 搭建一个有tomcat 的 要加一个tomcat的压缩包，添加内容WORKDIR # 镜像的等工作目录 /或者是哪个路径VOLUME # 挂载卷EXPOSE # 指定暴露端口 在这里暴露 外面就不需要暴露了ls -a -l前者不显示，后者显示CMD # 指定这个容器启动的时候要运行的命令 只有最后一个会生效，可被替代ENTRYPOINT # 可以直接追加命令ONBUILD # 当构建一个被继承DockerFile 这个时候就会运行ONBUILD指令 触发指令COPY # 类似ADD ， 将我们的文件拷贝到镜像中ENV # 构建的时候设置环境变量 实战测试DockerHub大多数的镜像都是从基础镜像中获取的 FROM scratch 创建一个自己的centos 123456789101112131415161718192021222324252627282930# 1.编写dockerfile文件FROM centosMAINTAINER timous&lt;1844736251@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;---end-----&quot;CMD /bin/bash# 2. 通过这个文件构建镜像-f dockerfile文件路径-t 镜像名和标签docker build -f mydockerfile -t mycentos:0.1 .Successfully built 4ab9930f53eeSuccessfully tagged mycentos:0.1# 3. 测试运行 直接进入了工作路径，而不是根目录 对比之前原生的，我们多了自己添加的功能。 我们可以列出本地镜像的变更历史 CMD 和ENTRYPOINT 的区别1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889CMD # 指定这个容器启动的时候要运行的命令 只有最后一个会生效，可被替代ENTRYPOINT # 可以直接追加命令FROM centosCMD [&quot;ls&quot;,&quot;-a&quot;]# 构建镜像[root@izbp169pmuqqu68q0mhkfaz dockerfile]# docker build -f dockercmd -t cmd:0.1 .Sending build context to Docker daemon 3.072kBStep 1/2 : FROM centos ---&gt; 0d120b6ccaa8Step 2/2 : CMD [&quot;ls&quot;,&quot;-a&quot;] ---&gt; Running in 252ebc591da5Removing intermediate container 252ebc591da5 ---&gt; 48c2615d874aSuccessfully built 48c2615d874aSuccessfully tagged cmd:0.1# 运行[root@izbp169pmuqqu68q0mhkfaz dockerfile]# docker run cmd:0.1....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar# 发现我们的命令生效了# 想追加一个命令 发现错误了 它会替换 docker run cmd:0.1 ls -al[root@izbp169pmuqqu68q0mhkfaz dockerfile]# docker run cmd:0.1 -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused &quot;exec: \\&quot;-l\\&quot;: executable file not found in $PATH&quot;: unknown.# ENTRYPOINT 不需要进行替换FROM centosENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;][root@izbp169pmuqqu68q0mhkfaz dockerfile]# docker run 2b16d27edab1....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar[root@izbp169pmuqqu68q0mhkfaz dockerfile]# docker run 2b16d27edab1 -ltotal 56drwxr-xr-x 1 root root 4096 Oct 5 09:13 .drwxr-xr-x 1 root root 4096 Oct 5 09:13 ..-rwxr-xr-x 1 root root 0 Oct 5 09:13 .dockerenvlrwxrwxrwx 1 root root 7 May 11 2019 bin -&gt; usr/bindrwxr-xr-x 5 root root 340 Oct 5 09:13 devdrwxr-xr-x 1 root root 4096 Oct 5 09:13 etc# 从结果可以看出我们的ENTRYPOINT 不会替换，是直接在后面追加命令的 并没有被替换 ，而是追加了docker存在很多这样的命令的 Docker‘中很多的命令都十分的相似，我们需要去了解他们的区别。我们最好就是对比练习。 实战：Tomcat 准备镜像文件，tomcat压缩包和jdk压缩包 编写Docker文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Dockerfile 是官方的命名，我们之后启动的时候不用加-f 了，就会去找这个文件FROM centosMAINTAINER timous&lt;1844736251@qq.com&gt;COPY read.txt /usr/local/readme.txtADD jdk-8u231-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.38.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_231ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.38ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.38ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME:lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.38/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.38/bin/logs/catalina.out# JDKFROM centosMAINTAINER timous&lt;1844736251@qq.com&gt;ADD jdk-8u231-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.38.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_231ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV PATH $PATH:$JAVA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.38/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.38/bin/logs/catalina.out# 构建镜像 docker build -t mytomcat .# 启动镜像docker run -d -p 8001:8080 --name mytomcat00 -v /home/tomcat/test:/usr/local/apache-tomcat-9.0.38/webapps -v /home/tomcat/tomcatlogs:/usr/local/apache-tomcat-9.0.38/logs mytomcat# 直接在本地发布项目就可以了，在挂载的目录下就可以了 &#x3D;&#x3D;注意：这里解压之后的webapps里面也是没有东西的，相当于是阉割版的，我们需要在里面添加东西再启动才能访问8080端口，这里只需要把webapps里面的东西考进去就行了，经过测试8.x和9.x是一样的，都是阉割版的，没有webapps下面的东西&#x3D;&#x3D; 经过测试，这个就可以直接发布项目了，之后需要掌握DockerFile的编写以及命令，之后我们就可以自己写项目发布应用了。 发布自己的镜像 DockerHub 1.地址：https://hub.docker.com/ 2.确定和这个账号能够登录就行了 3.在我们本地的linux登录我们的dockerhub账户 1234567891011[root@izbp169pmuqqu68q0mhkfaz ~]# docker login --helpUsage:\tdocker login [OPTIONS] [SERVER]Log in to a Docker registry.If no server is specified, the default is defined by the daemon.Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username 4.登录完毕之后我们自己docker push就可以了 1234567[root@izbp169pmuqqu68q0mhkfaz ~]# docker login -u timousPassword: WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded 5.提交镜像 12345678910111213The push refers to repository [docker.io/library/mytomcat]c67968a0b49c: Preparing 974165b6465d: Preparing 4aa18435b87c: Preparing 19a87c01b4dd: Preparing 291f6e44771a: Preparing denied: requested access to the resource is denied # 这个时候回被拒绝 可能不是因为本地的# 尽量带上自己的版本号# 增加一个tag就可以了 还有就是也要带上自己的版本号和名字 一般的话没有名字是提交不上去的[root@izbp169pmuqqu68q0mhkfaz ~]# docker tag 6c4d4c60d337 timous/tomcat:1.0[root@izbp169pmuqqu68q0mhkfaz ~]# docker push timous/tomcat:1.0 提交的时候还是按照层级来进行发布的。 阿里云镜像服务上面也可以发布 1.创建命名空间 2.创建容器镜像 3.浏览阿里云的信息 &#x3D;&#x3D;注意：这里要按照阿里云上的名字命名，不然的话会被拒绝的&#x3D;&#x3D; 也就是参考官方文档，下面就是我们的发布的image 阿里云操作1. 登录阿里云Docker Registry1$ sudo docker login --username=我命由我不由天0000-1dgpcx registry.cn-hangzhou.aliyuncs.com 用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。 您可以在访问凭证页面修改凭证密码。 2. 从Registry中拉取镜像1$ sudo docker pull registry.cn-hangzhou.aliyuncs.com/timous/timousdocker:[镜像版本号] 3. 将镜像推送到Registry1$ sudo docker login --username=我命由我不由天0000-1dgpcx registry.cn-hangzhou.aliyuncs.com$ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/timous/timousdocker:[镜像版本号]$ sudo docker push registry.cn-hangzhou.aliyuncs.com/timous/timousdocker:[镜像版本号] 请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。 4. 选择合适的镜像仓库地址从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。 如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-hangzhou.aliyuncs.com 作为Registry的域名登录。 5. 示例使用”docker tag”命令重命名镜像，并将它通过专有网络地址推送至Registry。 1$ sudo docker imagesREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEregistry.aliyuncs.com/acs/agent 0.7-dfb6816 37bb9c63c8b2 7 days ago 37.89 MB$ sudo docker tag 37bb9c63c8b2 registry-vpc.cn-hangzhou.aliyuncs.com/acs/agent:0.7-dfb6816 使用 “docker push” 命令将该镜像推送至远程。 1$ sudo docker push registry-vpc.cn-hangzhou.aliyuncs.com/acs/agent:0.7-dfb6816 小结 还有save和load，分别是保存，可以使一个压缩包 Docker网络理解网络：docker0清空所有的环境 ip addr 三个网络，分别代表了三种不同的环境 1234567891011121314151617181920# docker 如何处理容器网络的访问 下面的该如何连接docker run -d -P --name tomcat01 tomcat# 查看容器的网络地址 # 会得到一个eth0@if201这个地址[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat01 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever206: eth0@if207: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0 valid_lft forever preferred_lft forever# 我们的linux服务器能不能ping容器的内部 从下面的结果能够看出我们可以ping通我们的docker容器的内部[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# ping 172.18.0.2PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.084 ms64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.073 ms64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.087 ms 原理 我们每启动一个docker，docker就会给docker容器分配一个ip，我们只要安装docker，就会有一个网卡docker0，桥接模式，使用的技术是evth-pair技术 再次测试ip addr的时候发现多了一个 我们在启动一个tomcat02 经过观察发现，都是一对一对出现的，这个技术就是evth-pair，就是虚拟设备的接口，都是成对出现的，一端连接协议，一边连接端口，正因为这个技术，evth-pair充当一个桥梁，连接各种虚拟设备 Openstac、Docker等都是使用的这个技术 tomcat01和tomcat02是不是能直接ping同呢？ 12345[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat02 ping 172.18.0.2PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.134 ms64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.090 ms# 经过测试，是可以ping通的 结论： tomcat01和tomcat02是一个公用的路由器，docker0 所有的容器在不指定网络的情况下，都是docker0的路由，docker会给我们分配一个可用的ip地址 小结 Docker使用的是linux的桥接 Docker中的所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件都是10M等），只要容器删除，对应的一对地址就没有了 思考，编写了一个服务，database&#x3D;ip….. springcloud feign …. 我们能不能通过名字来ping，我们希望可以通过名字来进行访问，如果能够做到这一点我们就可以进行高可用了。 –link123456789101112131415[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat02 ping tomcat01ping: tomcat01: Name or service not known# 我们无法直接ping tomcat ping通 我们该如何解决[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker run -d -P --name tomcat03 --link tomcat02 tomcat13c7e106aab64631cc484b2057292bf0b6f8e1ce3923ea3e7a3de1eb80c8bb99[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat03 ping tomcat02PING tomcat02 (172.18.0.3) 56(84) bytes of data.64 bytes from tomcat02 (172.18.0.3): icmp_seq=1 ttl=64 time=0.127 ms64 bytes from tomcat02 (172.18.0.3): icmp_seq=2 ttl=64 time=0.092 ms64 bytes from tomcat02 (172.18.0.3): icmp_seq=3 ttl=64 time=0.098 ms64 bytes from tomcat02 (172.18.0.3): icmp_seq=4 ttl=64 time=0.097 ms# 发现通过这个之后，我们可以解决这个网络的连通问题[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat02 ping tomcat03ping: tomcat03: Name or service not known# 经过测试，发现不能连接 探究inspect 123456789[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat03 cat /etc/hosts127.0.0.1\tlocalhost::1\tlocalhost ip6-localhost ip6-loopbackfe00::0\tip6-localnetff00::0\tip6-mcastprefixff02::1\tip6-allnodesff02::2\tip6-allrouters172.18.0.3\ttomcat02 d63422c29b92 # 我们看到直接在hosts的配置中直接配置了一个配置172.18.0.4\t13c7e106aab6 –link就是在hosts里面添加了一个tomcat02的地址的配置，此处的就能够直接看出来本质了，但是这个已经不推荐了 我们现在玩docker已经不建议使用了，我们需要更高级的网络，我们需要自定义网络 docker0不支持容器名字的访问 自定义网络容器互联 查看所有的docker网络， 网络模式 桥接模式 bridge docker上面大桥 01 02 0 这个是默认的 自己创建也使用这个模式 不配置网络 none 主机模式 host 和宿主机共享网络 container： 容器内网络连通（用得少， 局限很大） 测试1234567891011121314151617# 我们直接启动的默认有--net bridge 这个就是docker0docker run -d -P --name tomcat01 tomcatdocker run -d -P --name tomcat01 --net bridge tomcat# docker0 是默认的 域名是不能访问的 --link可以打通连接 我们可以自定义网络来进行部署项目--driver 桥接--subnet 子网--gateway 网关[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet88d5d361b0539b4461d073b040bbe14f0fe8bf21c6a2242bba42467aea983a51[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker network lsNETWORK ID NAME DRIVER SCOPE6e908f0c98ad bridge bridge local9fa20911f238 host host local88d5d361b053 mynet bridge localbfb5c7518713 none null local 我们自己的网络就配置好了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker network inspect mynet[ &#123; &quot;Name&quot;: &quot;mynet&quot;, &quot;Id&quot;: &quot;88d5d361b0539b4461d073b040bbe14f0fe8bf21c6a2242bba42467aea983a51&quot;, &quot;Created&quot;: &quot;2020-10-07T22:28:14.670138277+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;, &quot;Gateway&quot;: &quot;192.168.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123; &quot;b103628af5e9cf31882dda4daad6ddc9050a929e3cabcd5cf14450112f53dc7d&quot;: &#123; &quot;Name&quot;: &quot;tomcat02&quot;, &quot;EndpointID&quot;: &quot;0723ecfc892ff755a3cd6ac46e3b0b1e27d9388223e5c0ab61a589973985ac39&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;e0bfc05259b497257357904fc7be88f5ae26846f2afa3510172a5dee51eca601&quot;: &#123; &quot;Name&quot;: &quot;tomcat03&quot;, &quot;EndpointID&quot;: &quot;b53ad2db79b00c3eae4ab2a2d852f2b99cf0044eb121ef17bbc68ad3b27d9cc0&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123;&#125;, &quot;Labels&quot;: &#123;&#125; &#125;]# 再次测试ping连接，不使用--link，我们也可以直接使用名字ping通[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat02 ping 192.168.0.3PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.137 ms64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.100 ms^C--- 192.168.0.3 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1000msrtt min/avg/max/mdev = 0.100/0.118/0.137/0.021 ms[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat02 ping tomcat03PING tomcat03 (192.168.0.3) 56(84) bytes of data.64 bytes from tomcat03.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.066 ms64 bytes from tomcat03.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.110 ms64 bytes from tomcat03.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.124 ms# 我们自定义的网络，docker都帮我们维护了关系 推荐我们平时这么使用网络 好处 redis集群 不同的集群在不同的网络，，保证网络是安全的 mysql集群 网络连通的操作测试连通tomcat-01到mynet docker network inspect mynet &#x3D;&#x3D;连通之后就相当于把tomcat-01直接放进mynet里面，一个容器两个地址&#x3D;&#x3D; 这里能够看出02不能够连接，但是01能够连接。 假设要跨网络去操作别人就需要使用docker connect来进行连通 实战： 部署redis集群 在r-m-3没了的时候，我们的r-s-3就会顶上去 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# shell脚本直接创建6个redisfor port in $(seq 1 6); \\do \\mkdir -p /mydata/redis/node-$&#123;port&#125;/conftouch /mydata/redis/node-$&#123;port&#125;/conf/redis.confcat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1$&#123;port&#125;cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdone# 运行容器docker run -p 6371:6379 -p 16371:16379 --name redis-1 \\-v /mydata/redis/node-1/data:/data \\-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6372:6379 -p 16372:16379 --name redis-2 \\-v /mydata/redis/node-2/data:/data \\-v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6373:6379 -p 16373:16379 --name redis-3 \\-v /mydata/redis/node-3/data:/data \\-v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6374:6379 -p 16374:16379 --name redis-4 \\-v /mydata/redis/node-4/data:/data \\-v /mydata/redis/node-4/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6375:6379 -p 16375:16379 --name redis-5 \\-v /mydata/redis/node-5/data:/data \\-v /mydata/redis/node-5/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6376:6379 -p 16376:16379 --name redis-6 \\-v /mydata/redis/node-6/data:/data \\-v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf# 创建集群redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1[root@izbp169pmuqqu68q0mhkfaz /]# docker exec -it redis-1 /bin/sh/data # lsappendonly.aof nodes.conf/data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1# 进去测试/data # redis-cli -c 127.0.0.1:6379&gt; cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:1cluster_stats_messages_ping_sent:143cluster_stats_messages_pong_sent:145cluster_stats_messages_sent:288cluster_stats_messages_ping_received:140cluster_stats_messages_pong_received:143cluster_stats_messages_meet_received:5cluster_stats_messages_received:288127.0.0.1:6379&gt; cluster nodescdc72565a6fbbc78d4173303abb899159768f7a3 172.38.0.11:6379@16379 myself,master - 0 1602084842000 1 connected 0-546091f6e56ca65c2345de0bd30a921124a9c62dd860 172.38.0.13:6379@16379 master - 0 1602084842876 3 connected 10923-16383130eefbca879a19e897ee3b94d1a751727fc1f0f 172.38.0.14:6379@16379 slave 91f6e56ca65c2345de0bd30a921124a9c62dd860 0 1602084841000 4 connectedea144f07a760b383c79d0cb6684fad6b1451b391 172.38.0.15:6379@16379 slave cdc72565a6fbbc78d4173303abb899159768f7a3 0 1602084842575 5 connectedadb8733c26c78112f07d4c5f8b463290f8b90314 172.38.0.16:6379@16379 slave 2a4a261302515c19fbb92734fee8993b2d1f5c74 0 1602084842575 6 connected2a4a261302515c19fbb92734fee8993b2d1f5c74 172.38.0.12:6379@16379 master - 0 1602084841874 2 connected 5461-10922127.0.0.1:6379&gt; set a b-&gt; Redirected to slot [15495] located at 172.38.0.13:6379OK docker redis集群搭建成功 我们使用docker之后，所有的技术都会慢慢变得简单起来 SpringBoot微服务打包docker镜像 构建springboot项目 打包应用 编写dockerfie 构建镜像 发布运行 运行成功 我自己的项目已经部署到服务器上面了 Docker ComposeDocker Swarm","tags":["运维"]},{"title":"短信邮箱验证码详解","path":"/2022/01/07/短信邮箱验证码详解/","content":"短信验证码阿里云用户的权限的操作 开启子用户 新建一个用户组（设置添加权限） 创建一个用户（集体操作的账号） 得到的AccessKey（id和密码） &#x3D;&#x3D;保存账号如果泄露，一定要删除或者是禁用&#x3D;&#x3D; 开通阿里云短信服务 找到短信控制台面板 找到帮助文档 添加短信模板 短信的具体的内容 等待审核通过 添加签名 添加签名 等待审核通过 编写测试代码 安装Java的SDK 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;4.5.1&lt;/version&gt;&lt;/dependency&gt; import com.aliyuncs.CommonRequest;import com.aliyuncs.CommonResponse;import com.aliyuncs.DefaultAcsClient;import com.aliyuncs.IAcsClient;import com.aliyuncs.exceptions.ClientException;import com.aliyuncs.exceptions.ServerException;import com.aliyuncs.http.MethodType;import com.aliyuncs.profile.DefaultProfile;/*pom.xml&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;4.5.0&lt;/version&gt;&lt;/dependency&gt;*/public class SendSms &#123; public static void main(String[] args) &#123; DefaultProfile profile = DefaultProfile.getProfile(&quot;cn-hangzhou&quot;, &quot;&lt;accessKeyId&gt;&quot;, &quot;&lt;accessSecret&gt;&quot;); IAcsClient client = new DefaultAcsClient(profile); CommonRequest request = new CommonRequest(); request.setSysMethod(MethodType.POST); request.setSysDomain(&quot;dysmsapi.aliyuncs.com&quot;); request.setSysVersion(&quot;2017-05-25&quot;); request.setSysAction(&quot;SendSms&quot;); request.putQueryParameter(&quot;RegionId&quot;, &quot;cn-hangzhou&quot;); try &#123; CommonResponse response = client.getCommonResponse(request); System.out.println(response.getData()); &#125; catch (ServerException e) &#123; e.printStackTrace(); &#125; catch (ClientException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 编写可复用的微服务接口，实现验证码的发送可以直接放进自己的项目里面 新建springboot项目 导入依赖 12345678910111213141516&lt;!--阿里云的短息的sdk，以便于能够使用阿里云的短息服务--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;4.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--使用阿里云的json--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 邮箱验证码 导入jar包 12345678910111213141516171819202122232425262728293031&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-email --&gt;&lt;!--邮箱的验证码的使用的jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-email&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; //邮箱的测试的方法 @Test void email() throws EmailException &#123;// HtmlEmail email=new HtmlEmail();//创建一个HtmlEmail实例对象// email.setHostName(&quot;smtp.163.com&quot;);//邮箱的SMTP服务器，一般123邮箱的是// // // //smtp.123.com,qq邮箱为smtp.qq.com// email.setCharset(&quot;utf-8&quot;);//设置发送的字符类型// email.addTo(&quot;xxxxxxxxxxx@qq.com&quot;);//设置收件人// email.setFrom(&quot;xxxxxxxxxx@163.com&quot;,&quot;aa&quot;);//发送人的邮箱为自己的，用户名可以随便填// email.setAuthentication(&quot;xxxxxxxxxx@163.com&quot;,&quot;xxxxxxxx&quot;);//设置发送人到的邮箱和用户名和授权码(授权码是自己设置的)// email.setSubject(&quot;测试&quot;);//设置发送主题// email.setMsg(&quot;填写你的发送内容&quot;);//设置发送内容// email.send();//进行发送 HtmlEmail email=new HtmlEmail();//创建一个HtmlEmail实例对象 email.setHostName(&quot;smtp.163.com&quot;);//邮箱的SMTP服务器，一般123邮箱的是smtp.123.com,qq邮箱为smtp.qq.com email.setCharset(&quot;utf-8&quot;);//设置发送的字符类型 email.addTo(&quot;1913394010@qq.com&quot;);//设置收件人 email.setFrom(&quot;15978813243@163.com&quot;,&quot;邮箱验证码&quot;);//发送人的邮箱为自己的，用户名可以随便填 email.setAuthentication(&quot;15978813243@163.com&quot;,&quot;MSJHKKZZOYNLQRWN&quot;);//设置发送人到的邮箱和用户名和授权码(授权码是自己设置的) email.setSubject(&quot;测试&quot;);//设置发送主题 email.setMsg(&quot;这是一个验证码&quot;);//设置发送内容 email.send();//进行发送 &#125;","tags":["小技巧"]},{"title":"mybatisplus学习","path":"/2022/01/06/mybatisplus学习/","content":"mybatisplus官网地址：https://mp.baomidou.com/ 一、简介Mybatis-Plus（简称mp）是一个mybatis的增强工具，在Mybatis的基础上只做增强不做改变，为简化而开发、提高效率而生。 润物细无声 只做增强，不做改变，引入它不会对现有工程产生影响，如丝般柔顺 效率至上 只需简单配置，即可快速进行CRUD操作，从而节省大量的时间 丰富功能 热加载、代码生成、分页、性能分析等功能一应俱全 二、创建并初始化数据库1.创建数据库mybatis_plus 2.创建user表对应的schema脚本如下： 12345678CREATE TABLE `user`(\tid BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;,\tname VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;姓名&#x27;,\tage INT(11) NULL DEFAULT NULL COMMENT &#x27;年龄&#x27;,\temail VARCHAR(50) NULL DEFAULT NULL COMMENT &#x27;邮箱&#x27;,\tPRIMARY KEY (id)); 对应的data脚本如下： 123456INSERT INTO user (id, name, age, email) VALUES(1, &#x27;Jone&#x27;, 18, &#x27;test1@baomidou.com&#x27;),(2, &#x27;Jack&#x27;, 20, &#x27;test2@baomidou.com&#x27;),(3, &#x27;Tom&#x27;, 28, &#x27;test3@baomidou.com&#x27;),(4, &#x27;Sandy&#x27;, 21, &#x27;test4@baomidou.com&#x27;),(5, &#x27;Billie&#x27;, 24, &#x27;test5@baomidou.com&#x27;); 三、确认idea的配置1.打开配置 2、JDK的版本 3、编码配置 4、maven配置（不在全局配置的时候，一定要自己配置一个repository） 四、创建项目1、初始化项目使用spring initialozr快速初始化一个springboot工程 依赖pom文件：mysql8主要是因为在5.6和5.7的基础上改变太多了，所以我们的mysql相对来讲直接就会变成8 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;top.timous&lt;/groupId&gt; &lt;artifactId&gt;mybatis_plus&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;mybatis_plus&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mybatis-plus.version&gt;3.4.1&lt;/mybatis-plus.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis_plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动 已经引入了匹配的mysql的驱动了--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok简化实体的创建--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;top.timous.MybatisPlusApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、配置文件yaml123456789# 应用名称spring: application: name: mybatis_plus # 应用的名字 datasource: driver-class-name: com.mysql.cj.jdbc.Driver # 数据库驱动 username: root # 数据库用户 password: 123456 # 数据库密码 url: jdbc:mysql://127.0.0.1:3306/mybatis_plus?serverTimezone=UTC&amp;amp&amp;useSSL=false # url配置 3、创建实体12345678910111213141516171819package top.timous.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * @author Timous * @create 2021-01-09 17:22 **/@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Long id; //注意，这里的id必须是Long型或者是String类型的，不然会按照普通的方式，不会生成主键 private String name; private int age; private String email;&#125; 上面的注解主要是生成set、get等方法 4、创建mapper的接口12345678910111213package top.timous.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import org.springframework.stereotype.Repository;import top.timous.pojo.User;/** * @author Timous * @create 2021-01-09 17:29 **/@Repository //表示是一个持久层 下面的泛型是user，所以我们查询到的所有的数据都是User实体public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 5、测试：使用的是hikari的数据源，也是比较快的，日文是光 测试代码： 123456789// 这里可能会报错，但是不影响，因为是在mybatisplus创建之后这个接口，才会有实现类@Autowiredprivate UserMapper userMapper;//查询所有的数据@Testvoid List()&#123; List&lt;User&gt; users = userMapper.selectList(null); // 里面可以接受参数，能够接上我们的where语句 users.forEach(System.out::println);&#125; 6、mybatis日志配置主要是查看sql语句 1234# mybatis 日志mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 就类似mybatis的配置 五、mybatis-plus的CRUD操作1、插入操作12345678910@Testvoid testInsert()&#123; User user = new User(); user.setName(&quot;Timous&quot;); user.setAge(22); user.setEmail(&quot;1844736251@qq.com&quot;); int result = userMapper.insert(user);// 返回的值是影响的行数 System.out.println(&quot;影响的行数： &quot; + result); System.out.println(&quot;user id : &quot; + user.getId());&#125; 注意，这里的主键必须是Long性的数据，不然的话无法自动生成主键 2、数据库分库分表策略背景 随着业务规模的不断扩大，需要选择合适的方案应对数据规模的增长，以应对逐渐增长的访问压力和数据量，数据库的扩展方式主要包括：业务分库，主从复制、数据库分表 2.1业务分库&#x3D;&#x3D;业务分库指的是按照业务模块&#x3D;&#x3D;，将数据分散到不同的数据库服务器。例如，一个简单的电商网站，包括用户、商品、订单三个业务模块，我们可以将用户数据、商品数据、订单数据分开放到三台不同的服务器上，而不是将所有的数据都放在一台数据库服务器上。这样就变成了4个数据库同时承担压力，系统的吞吐量自然就提高了。 虽然业务分库能够分散存储和访问的压力，但同时也带来了新的问题，接下来进行详细的分析。 join操作问题 业务分库之后，原本在同一个数据库的表分到不同的数据库中，导致无法应用sql的join查询 事务问题 原本在同一个数据库的表可以在同一事务中进行修改，业务分库之后，表分散到不同的数据库，无法通过事务同一修改 成本问题 业务分库同时也给成本带来了代价，本来一台服务器搞定的事，现在要3台，如果考虑备份，就是两台变成了6台 2.2、主从复制和读写分离读写分离的基本原理是将数据库读写操作分散到不同的节点上，读写分离的基本实现是： 数据库服务器搭建主从集群，一主一从，一主多从都可以 数据库主机负责写操作，从机只负责读操作 数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据 业务服务器将写操作发给数据库主机，将读操作发给数据库的从机 需要注意的是这里用的主从集群，而不是主备集群，从机的从可以理解为仆从，仆从主要是帮主人干活，从机是需要提供读数据的功能的，而备机一般被认为仅仅提供备份功能，你提供访问功能，所以是使用主从还是主备，需要看场景，这两个并不是相同的。 2.3、数据库分表将业务数据分散到不同的数据库服务器，能够支撑百万甚至是千万用户规模业务，但如果业务继续发展，同一业务的单表数据也会大袋单台数据库服务器的处理瓶颈。例如，淘宝的几亿用户数据，如果全部放在一台服务器的一张表中，肯定是无法达到性能要求的，此时就需要进行拆分。 有垂直拆分和水平拆分，单表切分后的多个表分散在不同的数据库服务器中，可以根据实际的效果来进行确定。如果性能能够满足业务需求，是可以不拆分到多台的服务器中的，毕竟我们在上面的业务分库也会引入很多复杂性的问题。分表能够有效的分散存储压力和带来性能提升。但是和分库一样，也会引入各种复杂性。 垂直分表 垂直分表适合将表中的某些不常用的并且占用了大量空间的列拆分出去 例如，在婚恋网站中，有些字段不常用可以直接拆分出去 水平分表 水平分表比垂直分表，会引入更多的复杂性，例如ID 主键自增 以最常见的用户ID为例，可以按照1000000的范围大小进行分段，1-999999放入表1中，以此类推 复杂点：分段的大小选取，分段太小会导致切分之后子表的数量过多，增加维护的复杂度；分段太大可能会导致单表依然存在性能问题，一般建议在100万到2000万之间，具体业务需求选取合适大小的分段 优点：可以随着数据的增加平滑的扩充新的表。 缺点：分部不均匀，某个表可能只存储几千条数据 Hash 同样以ID为例，加入我们一开始就规划了10个数据库表，路由算法可以简单的用user_id%10的值来表示数据所属的数据库表编号，ID为985的用户放到编号为5的数据库中去，ID为10086的放置到编号为6的数据库的表中去 复杂点： 初始表的数量的选取，表太多的时候维护起来比较麻烦，表的数量太少可能导致单表性能存在问题 优点： 表分布比较均匀 缺点：扩充新的表很困难，所有的数据都哟啊重新进行分配 雪花算法：分布ID生成器 雪花算法是有Twitter公布的分布式主键生成算法，它能够保证不同的主键的不重复性，以及相同的表的主键的有序性 核心思想： 长度共64bit（一个long型） 首先是一个符号位，1bit标识，由于Long性在java中是带符号的，最高为是符号位，正数为0，负数为1，所以id一般为正数，最高位是0 41bit时间戳（毫秒级），存储的是时间戳的差值（当前时间-开始时间），结果约为69.73年 10bit作为机器的ID（5bit是数据中心，5bit是机器的ID，可以部署1024个节点） 12bit作为毫秒内的流水号（意味这在每毫秒可以产生4096个ID） 六、自动填充需求描述：项目中经常会遇到一些数据，每次都使用相同的方式填充，例如记录的创建时间和更新时间等 我们可以使用mybatis-plus的自动填充功能，完成这些字段的赋值工作 &#x3D;&#x3D;在数据库的设置是不方便的，因为数据库是不一样的，一般采用的是编码的设置&#x3D;&#x3D; 1、数据库修改在User表中添加datetime类型的新的字段create_time、update_time 2、实体类的修改在实体类上添加字段并且添加自动填充的注解 12345678910111213141516171819202122232425262728293031package top.timous.pojo;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import lombok.Data;import java.util.Date;/** * @author Timous * @create 2021-01-09 17:22 **/@Datapublic class User &#123; /** * AUTO 如果设置成为这个，数据库的表中的主键必须设置为自增 * ASSIGN_ID 这个是分布式ID的生成的策略： 雪花算法 */ @TableId(value = &quot;id&quot;, type = IdType.ASSIGN_ID)//雪花算法的策略就是默认值 private Long id; //这里的id必须是Long型的，不然是没有主键的生成策略的 也叫分布式id private String name; private int age; private String email; @TableField(fill = FieldFill.INSERT) private Date createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private Date updateTime;&#125; 3、实现对象处理接口&#x3D;&#x3D;不要忘记component的注解&#x3D;&#x3D; 1234567891011121314151617181920212223242526272829303132package top.timous.handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.util.Date;/** * @author Timous * @create 2021-01-10 21:30 **/@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; /** * 根据对象数据属性的名字，设置值 */ System.out.println(&quot;insertFill&quot;); this.setFieldValByName(&quot;createTime&quot; , new Date() , metaObject); this.setFieldValByName(&quot;updateTime&quot; , new Date() , metaObject); &#125; @Override public void updateFill(MetaObject metaObject) &#123; System.out.println(&quot;updateFill&quot;); this.setFieldValByName(&quot;updateTime&quot; , new Date() , metaObject); &#125;&#125; 3.1插入测试结果 3.2更新测试结果 七、乐观锁1.场景一件商品，成本价是80元，售价是100元，老板通知小李，把商品的价格增加到150元。小李正在玩游戏，耽搁了一个小时，正好一个小时后，老板觉得150元的价格太高，可能会影响销量，又通知小王，说把价格降低30元。此时小李和小王同时操作数据库。这个时候可能会影响数据库的值。 2.乐观锁与悲观锁 上面的故事，如果是乐观锁，保存价格之前会检查一下价格是不是被修改过，如果被修改则重新取出价格在进行修改。 如果是悲观锁，小李在处理的时候只能等小王操作完再进行操作。 下面演示过程： 3.模拟修改冲突3.1数据库中增加商品表1234567CREATE TABLE `product` ( `id` bigint(20) NOT NULL COMMENT &#x27;主键ID&#x27;, `name` varchar(30) DEFAULT NULL COMMENT &#x27;商品名称&#x27;, `price` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;价格&#x27;, `version` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;乐观锁版本号&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 3.2测试代码1234567891011121314151617181920@Test void testConcurrentUpdate()&#123; //小李获取数据 Product p1 = productMapper.selectById(1L); System.out.println(&quot;小李取出的价格：&quot; + p1); //小王获取数据 Product p2 = productMapper.selectById(1L); System.out.println(&quot;小王取出的价格：&quot; + p1); //小李加了50元，存入数据库 p1.setPrice(p1.getPrice()+50); productMapper.updateById(p1); //小王减了30元，存入数据库 p2.setPrice(p2.getPrice()-30); productMapper.updateById(p2); //查看最后的结果 ， 用户看到的商品的价格 Product product = productMapper.selectById(1L); System.out.println(product); &#125; 3.3测试结果 3.4乐观锁插件12345678910111213141516171819202122232425262728293031323334353637383940package top.timous.config;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;/** * @author Timous * @create 2021-01-12 12:33 **/@EnableTransactionManagement // 事务处理@Configuration@MapperScan(&quot;top.timous.mapper&quot;)public class MybatisPlusConfig &#123; /** * 乐观锁插件 */// @Bean// public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123;// return new OptimisticLockerInterceptor();// &#125; /** * 乐观锁插件 ： 新版的 * @return */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); // 乐观锁插件 return interceptor; &#125;&#125; 3.5测试代码12345678910111213141516171819202122232425262728293031/** * 模拟赔钱的过程 */ @Test void testConcurrentUpdate()&#123; //小李获取数据 Product p1 = productMapper.selectById(1L); System.out.println(&quot;小李取出的价格：&quot; + p1); //小王获取数据 Product p2 = productMapper.selectById(1L); System.out.println(&quot;小王取出的价格：&quot; + p1); //小李加了50元，存入数据库 p1.setPrice(p1.getPrice()+50); productMapper.updateById(p1); //小王减了30元，存入数据库 p2.setPrice(p2.getPrice()-30); int result = productMapper.updateById(p2);//检查版本是不是正确 //判断 if (result == 0)&#123;// System.out.println(&quot;小王更新失败！！！&quot;); //进行重试 p2 = productMapper.selectById(1L); p2.setPrice(p2.getPrice()-30); productMapper.updateById(p2); &#125; //查看最后的结果 ， 用户看到的商品的价格 Product product = productMapper.selectById(1L); System.out.println(product); &#125; 3.6测试结果 八、查询1.通过id查询多个用户1.1查询代码12345@Testvoid testSelectBatchIds()&#123; List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3)); users.forEach(System.out::println);&#125; 1.2查询结果 2.通过map查询2.1代码12345678@Testvoid testSelectByMap()&#123; Map map = new HashMap&lt;String , Object&gt;(); map.put(&quot;name&quot; , &quot;timous&quot;); map.put(&quot;age&quot; , 28); List list = userMapper.selectByMap(map); list.forEach(System.out::println);&#125; 2.2测试结果 3.分页查询3.1添加分页插件的配置1234567@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); // 乐观锁插件 interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); //添加分页插件 return interceptor;&#125; 3.2测试123456789101112131415161718192021222324252627282930313233343536373839@Testvoid testSelectPage()&#123; Page&lt;User&gt; page = new Page&lt;&gt;(1, 5); Page&lt;User&gt; userPage = userMapper.selectPage(page, null); List&lt;User&gt; records = userPage.getRecords(); records.forEach(System.out::println); System.out.println(userPage.getPages());//总页数 System.out.println(userPage.getCurrent());//当前页码 System.out.println(userPage.getTotal());//总记录数 System.out.println(userPage.hasNext());//是否有下一页 System.out.println(userPage.hasPrevious());//是否有上一页 System.out.println(userPage.getSize());//这一页的条数&#125;//会查询出来很多不必要的字段@Testvoid testSelectPageMaps()&#123; QueryWrapper&lt;User&gt; userQueryWrapper = new QueryWrapper&lt;&gt;();//可以组装各种东西 userQueryWrapper.select(&quot;id&quot; , &quot;name&quot;); Page&lt;User&gt; page = new Page&lt;&gt;(1, 5); Page&lt;User&gt; userPage = userMapper.selectPage(page , userQueryWrapper); List&lt;User&gt; records = userPage.getRecords(); records.forEach(System.out::println);&#125;//前后端传递数据不会冗余@Testvoid testSelectPageMapes()&#123; QueryWrapper&lt;User&gt; userQueryWrapper = new QueryWrapper&lt;&gt;();//可以组装各种东西 userQueryWrapper.select(&quot;id&quot; , &quot;name&quot;); Page&lt;Map&lt;String , Object&gt;&gt; page = new Page&lt;&gt;(1, 5); Page&lt;Map&lt;String , Object&gt;&gt; userPage = userMapper.selectMapsPage(page , userQueryWrapper); List&lt;Map&lt;String , Object&gt;&gt; records = userPage.getRecords(); List&lt;Map&lt;String, Object&gt;&gt; mapList = userPage.getRecords(); mapList.forEach(System.out::println);&#125; 3.3测试结果 九、删除1.删除1234567891011121314151617181920@Testvoid testDeleteUserById()&#123; int id = userMapper.deleteById(5L); System.out.println(&quot;删除了：&quot;+id+&quot;行&quot;);&#125;@Testvoid testDeleteBatchIds()&#123; int id = userMapper.deleteBatchIds(Arrays.asList(11L , 12L , 13L)); System.out.println(&quot;删除了：&quot;+id+&quot;行&quot;);&#125;@Testvoid testDeleteByMap()&#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot; , &quot;Timous&quot;); map.put(&quot;age&quot; , 28); int id = userMapper.deleteByMap(map); System.out.println(&quot;删除了：&quot;+id+&quot;行&quot;);&#125; 2.逻辑删除2.1删除物理删除: 真实删除，将对应的数据从数据库中删除，之后的查询，查询不到这条记录 逻辑删除：假删除 ， 将对应的数据中代表是否被删除的字段状态修改为“被删除状态”，之后在数据库中仍旧能够看到这条记录 使用场景：可以将数据进行恢复 ， 有关联的数据，不便删除 2.2逻辑删除流程添加delete字段 , 此处的mysql没有boolean ， 只有tinyint 1234567891011121314151617181920212223242526ALTER TABLE `user` ADD COLUMN `deleted` BOOLEAN DEFAULT FALSE; public class User &#123; /** * AUTO 如果设置成为这个，数据库的表中的主键必须设置为自增 * ASSIGN_ID 这个是分布式ID的生成的策略： 雪花算法 */ @TableId(value = &quot;id&quot;, type = IdType.ASSIGN_ID)//雪花算法的策略就是默认值 private Long id; //这里的id必须是Long型的，不然是没有主键的生成策略的 也叫分布式id private String name; private Integer age; private String email; @TableField(fill = FieldFill.INSERT) private Date createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private Date updateTime; @TableLogic private Integer deleted;&#125;@Testvoid testDeleteLogicById()&#123; int id = userMapper.deleteById(2L); System.out.println(&quot;删除了：&quot;+id+&quot;行&quot;);&#125;SELECT id,name,age,email,create_time,update_time,deleted FROM user WHERE deleted=0 yaml文件配置 123456789# mybatis 日志mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: id-type: assign_id # 这是分布式ID的配置 理论上是注解大于这的配置的 logic-delete-field: 1 # 删除为1 一般不会修改 logic-not-delete-value: 0 # 未删除为0 十、条件构造器和常用接口 查询方式 说明 setSqlSelect 设置select查询字段 where where语句，拼接+where条件 and and语句，拼接+and字段&#x3D;值 andNew and语句 ， 拼接+and（字段&#x3D;值） or or语句 ， 拼接+or 字段&#x3D;值 orNew or语句 ， 拼接+or （字段&#x3D;值） eq 等于&#x3D; allEq 基于map内容等于 ne 不等于&lt;&gt; gt 大于&gt; ge 大于等于&gt;&#x3D; lt 小于&lt; … … … … 练习wrapper","tags":["数据库"]},{"title":"springcloud初步探索","path":"/2022/01/05/springcloud初步探索/","content":"Spring Cloud Netflix回顾之前的知识~ 串一下自己会的东西，这个阶段该如何学~ 这个阶段该如何学~ 优点 单一职责原则 每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求 开发简单，开发效率提高，一个服务可能就是单一的干一件事 微服务能够被小团队单独开发，这个小团队是2~5人的开发人员组成 微服务松耦合的，是有功能意义的服务，无论是在开发阶段或者是部署阶段都是独立的 微服务能使用不同的语言开发 易于和 第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续工具，如jenkins，Hadson，bamboo 微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值 微服务允许你利用融合最新技术 微服务知识业务逻辑的代码，不会和html，css或者是其他界面混合 每个服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库 缺点 开发人员要处理分布式系统的复杂性 多服务运维难度，随着服务的增加，运维的压力也在增大 系统部署依赖 服务间的通信成本 数据的一致性 系统集成测试 性能监控.. 微服务的技术栈有哪些 微服务条目 落地技术 服务开发 SpringBoot，Spring，SpringMVC 服务配置与管理 Netflix公司的Archaius、阿里的Diamond等 服务注册与发现 Eureka、Consul、Zookeeper等 服务调用 Rest、RPC、gRPC 服务熔断器 Hystrix、Envoy 负载均衡 Ribbon、Nginx等 服务接口调用（客户端调用服务的简化工具） Feign等 消息队列 Kafka、RabbitMQ、ActiveMQ等 服务配置中心管理 SpringCloudConfig、Chef等 服务路由（API网关） Zuul等 服务监控 Zabbix、Nagios、Metrics、Specatator等 全链路追踪 Zipkin、Brave、Dapper等 服务部署 Docker、OpenStack、Kuberneres等 数据流作开发包 SpringCloud Stream（封装Redis，Rabbit，Kafka等发送接收消息） 事件消息总线 SpringCloud Bus 为什么选择SpringCloud进行微服务架构1.选型依据 整体解决方案和框架成熟度 社区热度 可维护性 学习曲线 2.当前各大IT公司用的微服务架构有哪些 阿里： dubbo+HFS 京东： JSF 新浪： Motan 当当网： DubboX …. 3.各微服务框架对比 功能点&#x2F;服务框架爱 Netflix&#x2F;springcloud Motan gRPC Thrift Dubbo&#x2F;DubboX 功能定位 完整的微服务框架 RPC框架，但整合了ZK或Consul，实现集群环境的基本服务注册&#x2F;发现 RPC框架 RPC框架 服务框架 支持Rest 是，Ribbon支持多种课插拔的序列化选择 否 否 否 否 支持RPC 否 是（Hession2） 是 是 是 支持多语言 是（Rest形式）？ 否 是 是 否 负载均衡 是（服务端zuul+客户端Ribbon），zuul-服务，动态路由，云端负载均衡Eureka（针对中间层服务器） 是（客户端） 是 是 是（客户端） 配置服务 Netflix Archaius，SpringCloud Config Server集中配置 是（zookeeper提供） 否 否 否 服务调用链监控 是（zuul），zuul提供边缘服务API网关 否 否 否 否 高可用&#x2F;容错 是（服务端Hystrix+客户端Ribbon） 是（客户端） 否 否 是（客户端） 典型应用案例 Netflix Sina Google FaceBook 社区活跃程度 高 一般 高 一般 2017年后重新开始维护，之前断更了五年 学习难度 中等 低 高 高 低 文档丰富程度 高 一般 一般 一般 高 其他 SpringCloud Bus为我们的应用程序带来了更多管理端点 支持降级 Netflix内部在开发集成gRPC IDL定义 实践的公司比较多 SpringCloud入门概述 SpringCloud，基于Springboot提供的一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，熔断器等组件，除了基于NetFlix的开源组件做高度抽象封装之外，还有一些选型中立的开源组件。 SpringCloud利用SpringBoot的开发便利性，巧妙的简化了分布式系统基础设施的开发，SpringCloud为李开发人员提供了快速构建分布式系统的一些工具，&#x3D;&#x3D;包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等&#x3D;&#x3D;他们都可以用SpringBoot的开发风格做到一键启动和部署 SpringBoot并没有重复造轮子，它只是将目前各家公司开发的比较成熟，经得起实际考验的服务框架组合起来，通过SpringBoot风格进行在封装，屏蔽掉了复杂的配置和实现原理。&#x3D;&#x3D;最终给开发者留出了一套简单易懂，易部署和易维护的分布式系统开发工具包&#x3D;&#x3D; SpringCloud是分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶 SpringBoot和SpringCloud关系 SpringBoot专注于快速方便的开发单个个体微服务 SpringCloud是关注全局的微服务协调治理框架，他将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供： 配置管理，服务发现，断路器，，路由，微代理，实践总线，全局锁，决策竞选，分布式会话等等集成服务 SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系 &#x3D;&#x3D;SpringBoot专注于凯苏、方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架&#x3D;&#x3D; Dubbo和SpringCloud技术选型1.分布式+服务治理Dubbo目前成熟的互联网架构： 应用服务化拆分+消息中间件 2.Dubbo和SpringCloud对比传统的架构 结果： Dubbo Spring 服务注册中心 zookeeper Spring Cloud Netflix Eureka 服务调用方式 RPC REST API 服务监控 Dubbo-monitor Spring Boot Admin 断路器 不完善 Spring Cloud Netflix Hystrix 服务网关 无 Spring Cloud Netflix zuul 分布式配置 无 Spring Cloud Config 服务跟踪 无 Spring Cloud Seluth 消息总线 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无 Spring Cloud Task &#x3D;&#x3D;最大区别： SpringCloud抛弃了Dubbo的RPC通信，采取的是HTTP的REST方式&#x3D;&#x3D; 严格来说，这两种方式各有优劣。虽然从一定程度来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方法的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适 &#x3D;&#x3D;品牌机与组装机的区别&#x3D;&#x3D; 很明显，SpringCloud的功能比DUBBO更加强大，涵盖面更广，而且作为Spring的拳头项目，他也能够与Spring Framework SpringBoot Spring Data Spring Batch 等其他Spring项目完美融合，这些对于微服务而言是至关重要的。使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果你是一名高手，那这些都不是问题；而Spring Cloud就像品牌机，在Spring Source 的整合下，做了大量的兼容性测试，保证机器拥有更高的稳定性，但是如果非要在使用非原装组件外的东西，就需要对其基础有足够的了解 &#x3D;&#x3D;社区支持与更新力度&#x3D;&#x3D; 最为重要的是，Dubbo停止了5年左右的更新，虽然2017.7重启了，对于技术发展的新需求，需要由开发者自行拓展升级（比如当当网弄出了DubboX），这对于很多想要采用微服务架构的中小软件组织，显然是不太合适的，中小公司没有这么强大的技术能力去修改Dubbo源码+周边的一整套解决方案，并不是每一个公司都有阿里这样的大牛 &#x3D;&#x3D;设计模式 + 微服务拆分 优秀的人吧不一定善于表达 可以指挥&#x3D;&#x3D; &#x3D;&#x3D;总结&#x3D;&#x3D; 曾风靡全球的开源RPC服务框架Dubbo在重启维护后，令许多用户为之雀跃，但同时，也迎来了一些质疑的声音。互联网技术发展迅速，Dubbo是否还能跟上时代？Dubbo与Spring Cloud相比又有何优势和差异？是否会有相关举措保证Dubbo的后续更新频率 人物： Dubbo重启维护开发的刘军，主要负责人之一 阿里巴巴中间件高级研发工程师，主导了 Dubbo 重启维护以后的几个发版计划，专注于高性能 RPC 框架和微服务相关领域。曾负责网易考拉 RPC 框架的研发及指导在内部使用，参与了服务治理平台、分布式跟踪系统、分布式一致性框架等从无到有的设计与开发过程。 文档： https://www.sohu.com/a/215931152_827544 解决的问题域不一样： Dubbo的定位是一款RPC框架，Spring Cloud的目标是微服务架构下的一站式解决方案 3.SpringCloud能干啥 Distributed&#x2F;versioned configuration Service registration and discovery Routing Service-to-service calls Load balancing Circuit Breakers Global locks Leadership election and cluster state Distributed messaging 1234Spring Cloud 是一个由众多独立子项目组成的大型综合项目，每个子项目有不同的发行节奏，都维护这自己的发布版本号。Spring Cloud通过一个资源清单BOM（Bill of Materials） 来管理每个版本的子项目清单。为避免与子项目的发不号混淆，所以没有采取版本号的方式，而是通过命名的方式。 这些版本名称的命名方式采用了伦敦地铁站的名称，同时根据字母表的顺序来对应版本时间顺序，比如最早的Release版本： Angle ， 第二个Release版本： Brixton 然后是Camden、Dalston、Edgware，目前最新的是Finchley版本。 参考书： https://www.springcloud.cc/spring-cloud-netflix.html 中文API文档：（官方文档的翻译版）https://www.springcloud.cc/spring-cloud-dalston.html 中国社区：http://www.springcloud.cn/ 中文网：https://www.springcloud.cc/ 4.SpringCloud版本选择 Spring Boot Spring Cloud 关系 1.2.x Angle版本（天使） 兼容SpringBoot 1.2.x 1.3.x Brixton版本（布里克斯顿） 兼容SpringBoot 1.3.x，兼容SpringBoot 1.4.x 1.4.x Camden版本（卡姆登） 兼容SpringBoot 1.4.x，兼容SpringBoot 1.5.x 1.5.x Dalston版本（多尔斯顿） 兼容SpringBoot 1.5.x，不兼容SpringBoot 2.0.x 1.5.x Edgware版本（埃奇韦尔） 兼容SpringBoot 1.5.x，不兼容SpringBoot 2.0.x 2.0.x Finchley版本（芬奇利） 兼容SpringBoot 2.0.x，不兼容SpringBoot 1.5.x 2.1.x Greenwich版本 实际开发的版本关系 创建项目测试 Eureka服务注册与发现1.什么是Eureka Eureka如何读 Netflix在设计Eureka在设计Eureka时，遵循的就是AP原则 Eureka是NetFlix的一个子模块，也是核心模块之一。Eureka是一个基于Rest的服务，用于定位服务，以实现云端中间层服务发现和故障转移，服务注册与发现对于微服务来说是非常重要，有了服务发现与注册，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，类似于Dubbo的注册中心，比如zookeeper； 2.原理讲解 Eureka的基本架构 SpringCloud封装了NetFlix公司开发的Eureka模块来实现注册和发现（对比zookeeper） Eureka采用了C-S的架构设计，EurekaServer作为服务注册功能的服务器，他是服务注册中心 而系统中的其他微服务。使用Eureka的客户端连接到EurekaServer并维持心跳连接，这样系统的维护人员就可以通过EurekaServer来监控系统中各个微服务是否正常运行，SpringCloud的一些其他模块（比如Zuul）就可以通过EurekaServer来发现系统中的其他微服务，并执行相关的逻辑 和Dubbo架构对比 Eureka 包含两个组件 Eureka Server he Eureka Client Eureka 提供服务注册服务，各个节点启动之后，会在EurekaServer中进行注册，这样Eureka Server 中的服务注册表中将会存所有可用的服务节点的信息，服务节点的信息可以在界面中直观的看到 Eureka Client 是一个java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询负载算法的负载均衡器。在应用启动之后，将会向Eureka Server 发送心跳（默认周期为30秒）。 如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka将会从服务注册表中把这个服务节点移除掉（默认周期为90 秒） 三大角色 Eureka Server ： 提供服务的注册与发现 Eureka Provider： 将自身的服务注册到Eureka中，从而是消费方能够找到 Service Consumer： 服务消费方从Eureka中获取注册服务列表，从而找到消费服务 盘点目前工程的状况 &#x3D;&#x3D;自我保护机制： 好死不如赖活着&#x3D;&#x3D; 一句话总结： 某时刻某个微服务不可以用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存！！！ 默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务的心跳，EurekaServer将会注销该实例（默认是90 秒）。但是当网络分区故障发生的时候，微服务与Eureka之间无法正常通行，以上行为可能变得非常危险了—-因为为服务本身是非常健康的，此时本不应该注销这个服务。Eureka通过自我保护机制来解决这个问题—-当EurekaServer节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护的模式。一旦进入该模式，EurekaServer就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何的微服务）。当网络故障恢复之后，该EurekaServer节点会自动退出自我保护模式。 在自我保护的模式中，EurekaServer会保护服务注册表中的信息，不再注销任何服务实例。当它收到的心跳数 重新恢复到阈值以上的时候，该Eureka节点会自动退出自我保护的模式。他的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销可能健康的服务实例。一句话： 好死不如赖活着 综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学就是宁可保留所有微服务（健康的微服务和不健康的微服务都会保留），也不盲目注销任何健康的服务。使用自我保护模式，可以让Eureka集群更加健壮和稳定 在SpringCloud中，可以使用eureka，server，enable-self-preservation &#x3D; false禁用自我保护模式（不推荐关闭自我保护的机制） 5.8081服务发现Discovery 对于注册进Eureka的微服务，可以通过服务发现来获得该服务的信息【对外暴露服务】 Eureka和zookeeper的区别回顾CAP原则 RDBMS（mysql orcle sqlserver） &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》 acid NoSQL（redis mongdb） &#x3D;&#x3D;&#x3D;》CAP ACID是什么 A(Atomicity) 原子性 C(Consistency) 一致性 I(Isolation) 隔离性 D(Durability) 持久性 CAP是什么 C(Consisitency) 强一致性 A(Avavilability) 可用性 P(Partition tolereance) 分区容错性 CAP的三进二： CA AP CP &#x3D;&#x3D;CAP核心理论：&#x3D;&#x3D; 一个分布式系统不可能很好的满足一致性 根据CAP定理，将NoSQL数据库粉尘了满足CA原则，满足CP原则和满足AP原则的三大类 CA： 单点集群，满足一致性。可用性的系统，通常可扩展性较差 CP： 满足一致性，分区容错的系统，通常性能不是特别高 AP： 满足可用性，分区容错性的系统，通常可能对一致性要求低一些 作为服务注册中心，Eureka比zookeeper好在哪里？ 著名的CAP理论指出，一个分布式系统不能同时满足CAP 由于分区容错性P在分布式系统中是必须要保证的，因此我们只能在A和C之间进行权衡 zookeeper保证的是CP Eureka保证的是AP zookeeper保证的是CP 当向注册中心查询服务的时候，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用，也就是说，服务注册功能对于可用性的要求高于一致性。但是zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系的时候，剩余节点会重新进行leader选举，问题在于，选举leader的时间太长，30~120秒，且选举期间整个zookeeper都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因为网络问题是的zookeeper集群失去master节点是加大概率发生的事件，虽然服务最终能够恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的 Eureka保证的是AP Eureka看明白了这一点，因此在设计的时候就优先保证可用性。Eureka各节点之间都是平等的几个节点挂掉不会影响正常几点的工作，剩余节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时，如果发现连接失败，则会自动切换到其他的节点，只要有一台Eureka还在，就能保证注册服务的可用性，只不过查到的信息可能不是最新的，除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下的集中情况 Eureka不再注册列表中移除因为长时间没收到心跳而应该过期的服务 Eureka仍然能够接受新的服务的注册和查询请求，但是不会同步到其他的节点之上（即保证当前节点依然可用） 当网络稳定时，当前实例新的注册信息会被同步到其他的节点之中 &#x3D;&#x3D;因此，Eureka可以很好的应对因网络故障导致部分节点失去联系，而不会像zookeeper那样使整个注册服务瘫痪&#x3D;&#x3D; RibbonRibbon是什么？SpringCloud Ribbon是一种基于Netflix Ribbon实现的一套客户端负载均衡的工具 简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将NetFlix的中间层服务连在一起。Ribbon的客户端组件提供一些列的玩着呢个配置项如： 连接超时，重试等等。简单的说，就是配置文件中列出LoadBanlance（简称LB： 负载均衡） 后面所有的机器，Ribbon会自动帮你基于某种规则（如简单轮询，随机连接等等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法 Ribbon能干什么？ LB，负载均衡（Load Balance），在微服务或分布式集群中经常用的一种应用 负载均衡简单的说就是将用户的请求平摊的分配到多个服务器上，从而达到系统的HA（高可用） 常见的负载均衡软件有： Nginx、Lvs（中国人做的）等 Apache Tomcat也可以实现负载均衡 dubbo、springcloud中均给我们提供了负载均衡，springcloud的负载均衡算法可以自定义 负载均衡的简单分类： 集中式LB 即在服务的消费方和提供方之间使用独立的LB设施，如Nginx ： 反向代理服务器，由该设施负责把访问请求通过某种策略转发至服务的提供方！！ 进程式LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个合适的服务器 &#x3D;&#x3D;Ribbon就属于进程内LB&#x3D;&#x3D;，它只是一个类库，集成于消费方进程，消费方通过它来获取到提供方的地址 Feign负载均衡简介：feign是声明式的web Service客户端，它让微服务之间的调用变得简单了，类似controller调用service spring cloud集成ribbon和eureka，可以使用feign时提供负载均衡的http客户端 ， 只需要创建一个接口，然后添加注解即可 feign，主要是社区，大家都习惯面向接口编程。这个是很多人员的开发规范，调用为服务访问两种方法： 微服务名字【ribbon】 微服务接口【feign】 Feign能干什么？ Feign旨在编写Java Http客户端变得更容易 前面在使用Ribbon + RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际的开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，feign在此基础上做了进一步的封装，由它来帮助我们定义和实现依赖服务接口的定义，&#x3D;&#x3D;在Feign的实现下，我们只只需要创建一个接口并使用注解的方式来配置它（类似于以前在Dao接口上标注Mapper注解，现在是一个微服务接口上标注一个Feign注解即可）&#x3D;&#x3D;即可完成对服务方的接口绑定，讲话了使用spring Cloud Ribbon时，自动封装服务调用客户端的开发量 Feign集成了Ribbon 利用Ribbon维护了MicroServiceCloud—dept的服务列表信息，并且通过轮询实现了客户端的负载均衡，而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。 服务熔断分布式系统面临的问题复杂的分布式系统结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免的失败！！！ 服务雪崩多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这个就是所谓的”扇出”，如果扇出的链路上某个微服务的调用时间相应过长或者不可用，对于微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，这就是所谓的”雪崩效应“。 对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟饱和，比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他资源紧张，导致整个系统发生更多的级联故障，这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。 我们需要&#x3D;&#x3D;弃车保帅&#x3D;&#x3D; 什么是HystrixHystrix是一个用于分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。 “断路器”本身是一种开关装置，当某个服务单元故障之后，通过断路器的故障监控（类似熔断保险丝），&#x3D;&#x3D;向调用方返回一个服务预期的，可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方法无法处理的异常，这样就可以保证服务调用方的线程不会被长时间，&#x3D;&#x3D;不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩 之间的一个断的话就会直接崩掉 Hystrix能干啥 服务降级 服务熔断 服务限流 接近实时的监控 ….. 服务熔断熔断机制是对应雪崩效应的一种微服务链路保护机制 当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息当检测到该节点的微服务调用响应正常后恢复调用链路。在SpringCloud框架里的熔断机制通过Hystrix实现。Hystrix会监控微服务间的调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand 服务降级 总结：服务熔断： 服务端 某个服务超时或者是异常，引起熔断 服务降级 客户端 从整体的网络请求负载考虑，当某个服务熔断或者关闭之后，服务将不再被调用 此时在客户端，，我们可以准备一个FallBackFactory，返回一个默认值（缺省值） 但是服务的整体水平下降了 但是好歹呢能用，比直接挂掉好 服务监控配置下面的这些东西的时候能解决高版本的页面的显示的问题 &#x3D;&#x3D;注意:这个配置的一定要是自己的监控页面所在的yaml文件，不然的话将会无法生效&#x3D;&#x3D; 123456789101112#解决http://localhost:9000/actuator/hystrix.stream无法访问的问题management: endpoints: web: exposure: include: &quot;*&quot; endpoint: health: show-details: alwayshystrix: dashboard: proxy-stream-allow-list: &quot;localhost&quot; 这个图就是监控页面的东西 步骤： 写监控页面 导入依赖 编写端口 开启配置enable 直接放入服务 Zuul路由网关概述:什么是路由网关zuul包含了对请求的路由和过滤两个最主要的功能： 其中路由功能负责将外部的请求转发到具体的微服务实例上面去，是实现外部同一访问入口的基础，而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础。Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka获得其他服务的消息，也即以后访问微服务也都是通过Zuul跳转后获得 **&#x3D;&#x3D;注意：&#x3D;&#x3D;**Zuul服务最终会注册到Eureka服务中 提供：代理+路由+过滤 三大功能 Zuul能干啥 路由 过滤 http://localhost:8080/consumer/dept/queryDeptById/1也就是把这个路径隐藏，进而把我们的真实的地址保存 官方文档：https://github.com/Netflix/Zuul 避免了暴露我们的服务，正常情况下，需要换 可以看出，我们能够得到最终的换完之后的东西 到这里，我们的这是的项目就被隐藏起来了，之后的真实我们肯定会隐藏全部的 123ignore-service： &quot;*&quot;# 我们也可以配置一个前缀prefix： /timous # 我们可以自己配置 设置公共的前缀 springcloud config 分布式配置概述分布式系统面临的– 配置文件的问题微服务意味着要将单体应用中的业务拆分成为一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要配置一些必要的信息才能运行，所以一套集中式的，动态的配置管理设施是必不可少的，springcloud提供了configserver来解决这个问题，我们每一个微服务自带着一个application.yaml，那上百的配置文件，我们岂不是要发疯了。 什么是springcloud config 分布式配置中心 SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环节提供了一个中心化的外部配置 SpringCloud Config分为服务端和客户端两部分 服务端也被称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密，解密信息等访问端口 客户端则是通过制定的配置中心来管理应用资源，以及业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理。并且可以通过git客户端工具来方便的管理和访问配置内容 SpringCloud Config分布式配置中心能干嘛 集中管理配置文件 不同的管理不同的配置，动态化的配置更新，分环境部署，比如 &#x2F;dev &#x2F;test 运行期间动态调整配置，不在需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取自己的信息 当配置发生变化的时候，服务不需要重新启动，即可获得感知到配置文件的变化，并应用新的配置 将配置信息以REST接口的形式暴露 SpringCloud Config分布式配置中心与git整合由于SpringCloud Config是默认使用GIt进行存储配置文件（也有其他的方式，比如支持svn和本地文件），但是最推荐的还是git而且使用https&#x2F;http的访问形式 建立项目： 1.导入依赖 2.编写配置文件 3.开启这个功能 EnableXXXXX 4.配置类 Spring Cloud Alibaba1.0在服务器启动Nacos和sentinel1.0.1上传对应的文件 1.0.2启动Nacos1234#启动Nacos（linux的单机模式）sh startup.sh -m standalone#查看对应的端口的运行的程序（nacos的是8848）netstat -tunlp | grep 8848 如下图所示,Nacos启动成功： 可以在浏览器访问： 1.0.3启动sentinel1234# 启动sentinel的命令java -jar sentinel-dashboard-1.7.2.jar &amp; nohub #查看对应的端口的进程netstat -tunlp | grep 8080 sentinel对应的是8080的端口，所以应该查看8080对应的端口号 在浏览器访问对应的sentinel 1.1什么是Spring Cloud？是一些列分布式框架的集合，基于SpringBoot进行开发的。是一种规范，不是一个具体的实现，只是一种接口。 将不同公司生产的不同组件进行集成，以SpringBoot的风格进行集成，这样开发者就不需要关注底层的整合实现，而是开箱即用。需要哪个组件就使用springboot整合起来，非常的方便。是SpringBoot的分支。 1.2什么是Spring Cloud Alibaba？Spring Cloud Netflix （之前做的是收费视频的 ， 现已经闭源了） Spring Cloud Alibaba（Spring Cloud官网：https://spring.io/projects/spring-cloud） Spring Cloud Alibaba 工程结构 Spring Boot—》 Spring Cloud —》 Spring Cloud Alibaba（版本问题官网可以查询到） 版本的命名问题是地铁的站（伦敦的地铁站） 1.3上手代码父工程依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;top.timous&lt;/groupId&gt; &lt;artifactId&gt;SpringCLoudAlibabaLearn&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;provider&lt;/module&gt; &lt;module&gt;consumer&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 2服务治理2.0服务注册 + 服务发现 2.1创建子工程pom文件： 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;SpringCLoudAlibabaLearn&lt;/artifactId&gt; &lt;groupId&gt;top.timous&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;provider&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application文件: 123456789spring: cloud: nacos: discovery: # 对应的nacos的注册中心的地址 对应的就是域名 + 端口 server-addr: clh.timous.top:8848# 应用的名称 application: name: provider 启动对应的provider程序：（启动之后对应的nacos的页面） 启动了两个不同端口的provider程序： 2.2创建consumer服务pom文件： 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;SpringCLoudAlibabaLearn&lt;/artifactId&gt; &lt;groupId&gt;top.timous&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;consumer&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml文件 123456789server: port: 8100spring: cloud: nacos: discovery: server-addr: clh.timous.top:8848 application: name: consumer 服务发现的代码： 12345678910111213141516171819202122232425package top.timous.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.discovery.DiscoveryClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * @author Timous * @create 2022-04-05 23:55 **/@RestControllerpublic class ConsumerController &#123; @Autowired private DiscoveryClient discoveryClient;//返回对应的实例 @GetMapping(&quot;/instance&quot;) public List&lt;ServiceInstance&gt; instances()&#123; List&lt;ServiceInstance&gt; provider = discoveryClient.getInstances(&quot;provider&quot;); return provider; &#125;&#125; 从下面的图中可以看出，对应的值就获取到了（刚才的两个服务的发现） 2.3写测试接口","tags":["微服务"]},{"title":"springboot原理探究","path":"/2022/01/04/springboot原理探究/","content":"&#x3D; 微服务阶段javase: oop mysql:jdbc html+css+js+jquery+框架： 视图（框架不熟练 css不好） javaweb： 独立开发MVC三层架构的网站： 原始 ssm： 框架： 简化了我们的开发流程，配置也开始较为复杂； war tomcat中运行 spring再简化： springboot； 微服务架构！ 打成jar包，内嵌tomcat 服务越来越多： springcloud； 第一个springboot项目 官网可以直接下载项目的例子 IDEA也集成了这个网站 xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\txsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\t&lt;!--有一个父项目--&gt;\t&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\t&lt;/parent&gt;\t&lt;!--坐标--&gt;\t&lt;groupId&gt;com.example&lt;/groupId&gt;\t&lt;artifactId&gt;demo&lt;/artifactId&gt;\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\t&lt;name&gt;demo&lt;/name&gt;\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\t&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;\t&lt;/properties&gt;\t&lt;dependencies&gt; &lt;!--web依赖： tomcat dispatcherServlet xml等--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;\t&lt;/dependencies&gt;\t&lt;!--所有的springboot依赖都是使用spring-boot-starter开头的--&gt;\t&lt;!--打jar包插件--&gt;\t&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;\t&lt;/build&gt;&lt;/project&gt; 启动类 1234567891011121314package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;//程序的主入口，不能删也不能改 本身就是spring 的组件@SpringBootApplicationpublic class DemoApplication &#123;\tpublic static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args);\t&#125;&#125; 测试类 1234567891011121314151617181920package com.example.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;// 自动装配@Controller@RestControllerpublic class HelloController &#123; //http://localhost:8080/hello接口 @RequestMapping(&quot;hello&quot;) public String hello()&#123; //调用业务接受前端的参数 return &quot;hello world!&quot;; &#125;&#125; 使用tomcat作为默认的服务器。 cmd控制面板执行 原理探究自动配置pom.xml spring-boot-dependencies: 核心依赖在父工程中 这里我们在引入一些springboot依赖的时候不需要指定版本，就是因为有这些版本仓库 启动器启动器： 说白了就是springboot的启动场景，比如spring-boot-starter-web,他就会帮助我们自动导入web环境的所有的依赖， springboot会将所有的功能场景都有对应的启动器，如果我们要使用什么功能，我们只需要找到对应的启动器就可以了。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 主程序123456789101112131415package com.timous;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;//@SpringBootApplication 标注这个类是一个springboot的应用@SpringBootApplicationpublic class Springboot01HelloworldApplication &#123; //将springboot应用启动 public static void main(String[] args) &#123; SpringApplication.run(Springboot01HelloworldApplication.class, args); &#125;&#125; 注解 @SpringBootConfiguration # sprigboot的配置 @Configuration # spring配置类 @Component # 说明这也是一个spring的组件 @EnableAutoConfiguration # 自动配置 @AutoConfigurationPackage # 自动配置包 @Import({Registrar.class}) # 导入选择器 自动配置包注册 @Import({AutoConfigurationImportSelector.class}) # 自动配置导入选择 # 获取所有的配置 List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); 12345获取候选的配置： protected List getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List configurations &#x3D; SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, “No auto configuration classes found in META-INF&#x2F;spring.factories. If you are using a custom packaging, make sure that file is correct.”); return configurations;} 12345678910111213META-INF/spring.factories： 自动配置的核心文件![image-20200912121721413](https://raw.githubusercontent.com/timoustop/PicGoSave/main/2026/typora/202601112047791.png)加载![image-20200912123059356](https://raw.githubusercontent.com/timoustop/PicGoSave/main/2026/typora/202601112047608.png)```javaProperties properties = PropertiesLoaderUtils.loadProperties(resource); //所有的资源加载到配置类 源码解析： &#x3D;&#x3D;结论： springboot所有的自动配都在启动中被扫描并加载： 扫描了META-INF&#x2F;spring.factories ， 但是不一定生效，要判断条件是否成立，只要导入对应的start，就会有对应的启动器，自动装配就会生效，然后就配置成功了&#x3D;&#x3D; springboot在启动的时候，从类路径下META-INF&#x2F;spring.factories 获取指定的值 将这些自动配置的类导入容器，自动配置类就会生效，进行自动配置 以前我们需要配置的东西，springboot帮我们配置了 整个javaee，解决方案和自动配置的东西都在spring-boot-autoconfigure这个包下 它会把所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器 容器中也会存在非常多的xxxautoconfiguration的文件，就是这些类给容器导入了这个场景所需要的所有的组件，并且自动配置， @Configuration， javaConfig 有了这些自动配置类，我们就不用进行配置了。 SpringApplocation 推断应用的类型是普通项目还是web项目 查找并加载所有可用的初始化器，设置到initializers属性中 找出所有的应用程序监听器，设置到listeners属性中 推断并设置main方法的定义类，找到运行的主类 构造器12345678910111213141516171819public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; this.sources = new LinkedHashSet(); this.bannerMode = Mode.CONSOLE; this.logStartupInfo = true; this.addCommandLineProperties = true; this.addConversionService = true; this.headless = true; this.registerShutdownHook = true; this.additionalProfiles = new HashSet(); this.isCustomEnvironment = false; this.lazyInitialization = false; this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet(Arrays.asList(primarySources)); this.webApplicationType = WebApplicationType.deduceFromClasspath(); this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class)); this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = this.deduceMainApplicationClass(); &#125; 关于spingboot谈谈你的理解： 自动装配 run() 全面接管springmvc的配置！！！实操 spingboot配置 官方的所有配置 https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#server-properties 全局配置文件的名字application.yaml1234567891011121314151617181920212223server: port: 8081# 注入到我们的配置类之中# 对象student: name: timous age: 3# 行内写法students: &#123;name: timous,age: 3&#125;# 数组pets: - cat - dog - pigpet: [cat,dog,pig]# porperties只能存键值对# yaml对于空格的要求十分严格 yaml可以直接给实体类赋值 需要导入一个jar12345&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\t&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 给实体类赋值： yaml：12345678910111213person: name: 陈留红 age: 3 happy: false birth: 2019/11/02 maps: &#123;k1: v1,k2: v2&#125; lists: - code - music - girl dog: name: 杜志明 age: 3 pojo:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152// Personpackage com.timous.pojo;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String , Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; public Person() &#123; &#125; public Person(String name, Integer age, Boolean happy, Date birth, Map&lt;String, Object&gt; maps, List&lt;Object&gt; lists, Dog dog) &#123; this.name = name; this.age = age; this.happy = happy; this.birth = birth; this.maps = maps; this.lists = lists; this.dog = dog; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Boolean getHappy() &#123; return happy; &#125; public void setHappy(Boolean happy) &#123; this.happy = happy; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; public Map&lt;String, Object&gt; getMaps() &#123; return maps; &#125; public void setMaps(Map&lt;String, Object&gt; maps) &#123; this.maps = maps; &#125; public List&lt;Object&gt; getLists() &#123; return lists; &#125; public void setLists(List&lt;Object&gt; lists) &#123; this.lists = lists; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, happy=&quot; + happy + &quot;, birth=&quot; + birth + &quot;, maps=&quot; + maps + &quot;, lists=&quot; + lists + &quot;, dog=&quot; + dog + &#x27;&#125;&#x27;; &#125;&#125;//Dogpackage com.timous.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class Dog &#123; @Value(&quot;杜志明&quot;) private String name; @Value(&quot;3&quot;) private Integer age; public Dog() &#123; &#125; public Dog(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 测试类：12345678910111213141516171819202122232425package com.timous;import com.timous.pojo.Dog;import com.timous.pojo.Person;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass Springboot02ConfigApplicationTests &#123; @Autowired private Dog dog; @Autowired private Person person; @Test void contextLoads() &#123; System.out.println(dog); System.out.println(person); &#125;&#125; ConfigurationProperties的作用 将配置文件中配置的每一个属性映射到这个组中，告诉spingboot将本类中的所有属性和配置文件中相关的配置文件进行绑定 将参数prefix &#x3D; “person”： 将配置文件中的person下面的所有属性一一对应 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能 &#x3D;&#x3D;使用：可以在mybatis配置的时候写入url等加载的东西&#x3D;&#x3D; 123@PropertySource(value = &quot;classpath:timous.poperties&quot;) 指定配置文件加载 @value(&quot;$&#123;name&#125;&quot;) spel表达式取出配置文件的值 在赋值的时候可以使用多种配置方式 yaml支持spel表达式：1234567891011121314person: name: 陈留红$&#123;random.uuid&#125; age: $&#123;random.int&#125; happy: false birth: 2019/11/02 hello: happy maps: &#123;k1: v1,k2: v2&#125; lists: - code - music - girl dog: name: $&#123;person.hello:hello&#125;_杜志明 age: 3 @ConfigurationProperties和@Value对比 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个一个指定 松散绑定（松散语法） 支持 不支持 SpEl 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 在@ConfigurationProperties配置文件可以使last-name,实体类可以使lastName cp只需要写一次即可，value则需要每个字段都添加 松散绑定： 这什么意思呢？比如我们在yaml中写的last-name，这个和lastName是一样的，-后面跟着的字母默认是大写。这就是松散绑定 JSR303数据校验，这个就是我们可以在字段是增加一层过滤验证，可以保证数据的合法性 复杂类型封装，yaml还可以封装对象，使用@value就不支持 结论 配置yaml和配置properties都可以获取到值，强烈推荐yaml 如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下@value 如果说，我们专门编写一个javaBean来和配置文件进行映射，就直接使用@configurationProperties，不要犹豫 JSR303校验 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.timous.pojo;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;import org.springframework.validation.annotation.Validated;import javax.validation.constraints.Email;import java.util.Date;import java.util.List;import java.util.Map;@Component@ConfigurationProperties(prefix = &quot;person&quot;)@Validated //数据校验//@PropertySource(value = &quot;classpath:timous.poperties&quot;) 指定配置文件加载public class Person &#123; @Email(message=&quot;邮箱格式错误&quot;) private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String , Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; public Person() &#123; &#125; public Person(String name, Integer age, Boolean happy, Date birth, Map&lt;String, Object&gt; maps, List&lt;Object&gt; lists, Dog dog) &#123; this.name = name; this.age = age; this.happy = happy; this.birth = birth; this.maps = maps; this.lists = lists; this.dog = dog; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Boolean getHappy() &#123; return happy; &#125; public void setHappy(Boolean happy) &#123; this.happy = happy; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; public Map&lt;String, Object&gt; getMaps() &#123; return maps; &#125; public void setMaps(Map&lt;String, Object&gt; maps) &#123; this.maps = maps; &#125; public List&lt;Object&gt; getLists() &#123; return lists; &#125; public void setLists(List&lt;Object&gt; lists) &#123; this.lists = lists; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, happy=&quot; + happy + &quot;, birth=&quot; + birth + &quot;, maps=&quot; + maps + &quot;, lists=&quot; + lists + &quot;, dog=&quot; + dog + &#x27;&#125;&#x27;; &#125;&#125;person: name: 陈留红$&#123;random.uuid&#125; age: $&#123;random.int&#125; happy: false birth: 2019/11/02 hello: happy maps: &#123;k1: v1,k2: v2&#125; lists: - code - music - girl dog: name: $&#123;person.hello:hello&#125;_杜志明 age: 3 Constraint 详细信息 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max, min 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(value) 被注释的元素必须符合指定的正则表达式 Constraint 详细信息 @Email 被注释的元素必须是电子邮箱地址 @Length 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range 被注释的元素必须在合适的范围内 所在位置： 配置文件的位置： 最优先的： &#x3D;&#x3D;file:&#x2F;&gt;classpath:&#x2F;&gt;&#x3D;&#x3D;其他的两个不生效，这里是我自己测试的 yaml： 12345678910111213spring: profiles: active: test # 这是哪个激活的---server: port: 8082spring: profiles: dev---server: port: 8083spring: profiles: test 自动配置原理自动配置就是conditionalOn 进而来判断是否生效，会有prifix，这个时候里面的所有属性都能配置了，在配置文件能配置的东西都存在固有的规律，都存在一个xxxxProperties xxxxautoConfiguation（有默认值，properties可以有，我们的配置就会生效）会绑定properties，而properties会去绑定配置文件。 @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean @ConditionalOnJavaMissingBean 容器中不存在指定Bean @ConditionalOnExpression 满足SpEl表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResouce 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动装配精髓： &#x3D;&#x3D;springboot启动会加载大量的自动配置类&#x3D;&#x3D; &#x3D;&#x3D;我们看我们需要的功能有没有在springboot默认好的自动配置类中；&#x3D;&#x3D; &#x3D;&#x3D;我们再来看这个自动配置类中到底配置了那些组件（只要我们要用的组件存在其中，我们就不要手动配置了）&#x3D;&#x3D; &#x3D;&#x3D;给容器中自动配置类添加组件的时候，会从poperties类中获取某些属性，我们只需要在配置文件中指定这些属性的值即可&#x3D;&#x3D; &#x3D;&#x3D;xxxxAutoConfiguration： 自动配置类： 会给容器中添加组件&#x3D;&#x3D; &#x3D;&#x3D;xxxxProperties: 封装配置文件中相关属性&#x3D;&#x3D; Debug调试生效的 未生效的 缺少条件未生效的 SpringBoot web开发 创建应用 选择模块 配置文件 业务代码编写 spingboot到底帮我们配置了什么，能不能修改，能修改那些东西，能不能扩展 xxxxAutoConfiguration 向容器中自动配置组件 xxxxPoperties：自动配置类自动装配我们自定义的配置文件 要解决的问题 导入静态资源，…. 首页问题 jsp，模板引擎thymeleaf 装配扩展springmvc 视图解析器，增删改查 拦截器 国际化 静态资源1234567891011121314151617181920@Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; &#125; 什么是webjars：https://www.webjars.org/ http://localhost:8080/webjars/jquery/3.5.1/jquery.js： 启动之后访问这个路径，能够看到jquery的js文件 静态资源文件的位置： 123private String staticPathPattern = &quot;/**&quot;;private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;; 测试 能够访问到public下面的静态资源，通过测试，其他的两个也都是能访问的 总结： 在springboot中，我们可以使用以下的几种方式处理静态资源 webjars http://localhost:8080/webjars/jquery/3.5.1/jquery.js public，static，&#x2F;**，resources http://localhost:8080/1.js 优先级 resources》static（个人使用，默认）》public 首页如何定义依旧可以放置在上述的四个文件之中 修改图标的时候新版的是被取消了的 Thymeleaf模板引擎导入依赖： 123456789&lt;!--thymeleaf 我们都是基于3.x开发的--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt; &lt;/dependency&gt; 只要使用thymeleaf，只需要导入对应的依赖就可以了！我们将html页面放在templates下面 12345private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;public static final String DEFAULT_SUFFIX = &quot;.html&quot;; controller1234567891011121314151617181920package com.timous.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;//在templates下的所有的页面，只能通过conroller来跳转//这个需要模板引擎的支持 thymeleaf@Controllerpublic class IndexController &#123; @RequestMapping(&quot;/test&quot;) public String index(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello springboot&quot;); return &quot;test&quot;; &#125;&#125; html:12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--所有的html都可以被thymelef接管--&gt;&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;test&lt;/div&gt;&lt;div th:utext=&quot;$&#123;msg&#125;&quot;&gt;test&lt;/div&gt;&lt;hr&gt;&lt;!--建议采用不写再标签里面--&gt;&lt;h3 th:each=&quot;user:$&#123;users&#125;&quot; th:text=&quot;$&#123;user&#125;&quot;&gt;&lt;/h3&gt;&lt;h3 th:each=&quot;user:$&#123;users&#125;&quot;&gt;[[$&#123;user&#125;&#125;]]&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; thymeleaf命令 Feature Attributes Fragment inclusion th:insert th:replace Fragment iteration th:each Conditional evaluation th:if th:unless th:switch t:case Local variable definition th:object th:with General attribute modification th:attr th:attrprepend th:attrappend Specific attribute modification th:value th:herf th:src …. Text(tag body modification) th:text th:utext Fragment specification th:fragment Fragment removal th:remove 扩展装配springmvc 自定义视图解析器 1234567891011121314151617181920212223242526272829package com.timous.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import java.util.Locale;// 如果你想定制一些功能，只要写这个组件，然后将他交给springboot，springboot就会帮我们自动装配 l//全面扩展springmvc dispacthservlet@Configurationpublic class MyMvcConfig implements WebMvcConfigurer&#123; //public interface ViewResolver 实现了试图解析器接口的类，我们就可以把他看成视图解析器 @Bean public ViewResolver MyViewResolver()&#123; return new MyViewResolver(); &#125; //自定义了一个试图解析器 public static class MyViewResolver implements ViewResolver &#123; @Override public View resolveViewName(String s, Locale locale) throws Exception &#123; return null; &#125; &#125;&#125; 使用的bug的方式查看自己配置的视图 试图跳转 12345678910111213141516package com.timous.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;//如果我们要扩展springmvc，官方建议我们这样做@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; //视图跳转 @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/kuang&quot;).setViewName(&quot;test&quot;); &#125;&#125; 不能添加@EnableWebMvc的原因 1234567891011121314151617181920package com.timous.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;//如果我们要扩展springmvc，官方建议我们这样做@Configuration//这就是导入了一个类DelegatingWebMvcConfiguration.class 从容器中获取所有的webmvcconfig： 也就相当于自动崩盘了//WebMvcConfigurationSupport//@EnableWebMvc public class MyMvcConfig implements WebMvcConfigurer &#123; //视图跳转 @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/kuang&quot;).setViewName(&quot;test&quot;); &#125;&#125; &#x3D;&#x3D;在springboot中，有非常多的xxxConfiguration帮助我们进行扩展配置，只要看见了这个东西，我们要注意他们扩展了啥&#x3D;&#x3D; 员工管理系统1.首页配置所有页面的静态资源都需要thymeleaf来进行接管 ​ 1.所有页面的静态资源都需要使用thymeleaf进行接管 ​ 2.url ： @{} 2.页面的国际化： 注意点： ​ 1.需要配置i18n文件 ​ 2.如果我们需要在项目中进行按钮切换，我们需要自定义一个组件LocaleResolver ​ 3.记得将自己的配置组件配置到spring容器中@Bean ​ 4.#{} 3.登录+拦截 4.员工列表展示 提取公共页面 th:fragment=&quot;topbar&quot; th:replace=&quot;~{/commons/commons::sidebar(active=&#39;list.html&#39;)}&quot; 如果要传递参数，可以使用（）传递，接受判断即可 列表循环展示 5.添加员工 按钮提交 跳转添加页面 添加员工成功 返回首页 crud搞定 后端： 前端如何调整 ， 推荐使用模板 模板 框架 自己手动组合拼接 栅格系统 导航栏 侧边栏 表单 写网站1.前端搞定： 页面什么样子 2.设计数据库 3.前端让他能够自动运行，独立化工程 4.数据接口对接： json 对象 Dataspring: bean 整合mybatis需要的依赖 12345&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; 导入包 配置文件 mybatis配置 编写sql 业务层调用dao controller调用service springsecurity(安全)在web开发，安全是第一位的！过滤器，拦截器 功能性需求： 否 做网站后台： 安全啥时候考虑？ 设计之初 漏洞： 用户隐私泄露等 架构一旦确定，不好增加代码，需要改动 shiro，springsecurity区别： 类和名字不一样 功能： 认证，授权（用户有啥权限） springsecurity身份认证和权限 功能权限 访问权限 菜单权限 等 之前都是拦截器和过滤器做的，大量的原生代码。繁琐冗余 mvc—-spring—-springboot—-框架 Aop，横切 简介： springsecurity是针对springboot项目的安全框架，也是springboot底层安全模块默认的技术选型，他可以实现强大的web安全控制，对于安全控制，我们只需要引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理！ 记住下面的几个类： WebSecurityConfigfigurerAdapter： 自定义security策略 AuthentictionManagerBuilder： 自定义认证策略 @EnableWebSecurity： 开启websecurity模式 spring security的两个主要目标是认证和授权（访问控制） 认证Authentication 授权Authorization 这个概念是通用的，而不是只在spring security中存在 参考官网 查看自己的版本的帮助文档 Swagger目标： 了解swagger的作用和感念 了解前后端分离 在springboot中集成swagger Swagger简介前后端分离 vue+springboot 后端时代： 前端只需要管理静态页面 html&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》 后端 模板引擎 jsp ejb&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》 后端是主力 前端比较好些 之前是工具画的 前后端分离时代 后端： 后端控制层（controller） 服务层 （service） 数据访问层（dao）【后端团队】 前端： 前端控制层，视图层【前端团队】 伪造后端数据，json。已经存在。不需要后端，前端工程依旧能够跑起来 前后端如何交互？ &#x3D;&#x3D;&#x3D;&#x3D;》 api 前后端相对独立，并且松耦合； 前后端甚至可以部署在不同的服务器上 产生一个问题： 前后端集成联调，前端人员和后端人员无法做到及时协调，需要尽早解决，最后导致问题集中爆发； 解决方案： 指定一个schema【计划的提纲】 ，实时更新最新的api，降低集成风险； 早些年： 制定word计划文档； 前后端分离： 前端测试后端接口： postman 后端提供接口需要实时更新最新的消息以及改动 swagger 号称世界最流行的api框架 restful api 文档在线自动生成工具 &#x3D;》 &#x3D;&#x3D;api 文档与api定义同步更新&#x3D;&#x3D; 直接运行，可以在线测试api接口 支持多种语言 java php等 官网： https://swagger.io/ 在项目中使用swagger需要springbox： 导入jar包 swagger2 swagger UI springboot集成swagger1.新建项目 2.导入相关依赖 1234567891011121314&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; 3.编写一个helloworld程序 4.配置swagger&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》config 123456789101112package com.timous.config;import org.springframework.context.annotation.Configuration;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration//开启swagger2@EnableSwagger2public class SwaggerConfig &#123;&#125; 5.测试运行 3.0.0版本的不能运行 配置Swaggerswagger的bean实例Docket； swagger配置扫描接口select（Docket的） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.timous.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;import java.util.ArrayList;@Configuration//开启swagger2@EnableSwagger2public class SwaggerConfig &#123; //swagger的bean实例 @Bean public Docket docket()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() //Predicate&lt;RequestHandler&gt; selector配置要扫描的接口的方式 //basePackage指定要扫描的包 //any()扫描全部 //none()都不扫描 //withClassAnnotation(&quot;Controller.class&quot;)扫描类上的注解 Controller 只扫描带有controller 的接口 //withMethodAnnotation() 扫描方法的注解 .apis(RequestHandlerSelectors.basePackage(&quot;com.timous.controller&quot;)) //过滤 过滤什么路径 .paths(PathSelectors.ant(&quot;/timous/**&quot;)) .build();//build工厂模式 &#125; //配置swagger信息apiInfo private ApiInfo apiInfo()&#123; return new ApiInfo(&quot;陈留红的swaggerApi文档&quot;, &quot;这个作者很nb&quot;, &quot;v1.0&quot;, &quot;http://timous.top&quot;, //作者信息 new Contact(&quot;陈留红&quot;, &quot;http://timous.top&quot;, &quot;1844736251@qq.com&quot;), &quot;Apache 2.0&quot;, &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList()); &#125;&#125; 配置是否自动启动：12//是否启动swagger 如果为false则swagger不能访问.enable(false) 我只希望我的swagger在生产环境中使用在发布的时候不使用？ 配置yaml然后在生产环境中配置环境 判断是不是生产环境（flag &#x3D; false） 注入enable值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.timous.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.Environment;import org.springframework.core.env.Profiles;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;import java.util.ArrayList;@Configuration//开启swagger2@EnableSwagger2public class SwaggerConfig &#123; //swagger的bean实例 @Bean public Docket docket(Environment environment)&#123; //设置要显示的swagger环境 Profiles profiles = Profiles.of(&quot;dev&quot; , &quot;test&quot;); //获取项目的配置环境 //判断是否处在自己设定的环境当中 boolean flag = environment.acceptsProfiles(profiles); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(flag) .select() //Predicate&lt;RequestHandler&gt; selector配置要扫描的接口的方式 //basePackage指定要扫描的包 //any()扫描全部 //none()都不扫描 //withClassAnnotation(&quot;Controller.class&quot;)扫描类上的注解 Controller 只扫描带有controller 的接口 //withMethodAnnotation() 扫描方法的注解 .apis(RequestHandlerSelectors.basePackage(&quot;com.timous.controller&quot;)) .build();//build工厂模式 &#125; //配置swagger信息apiInfo private ApiInfo apiInfo()&#123; return new ApiInfo(&quot;陈留红的swaggerApi文档&quot;, &quot;这个作者很nb&quot;, &quot;v1.0&quot;, &quot;http://timous.top&quot;, //作者信息 new Contact(&quot;陈留红&quot;, &quot;http://timous.top&quot;, &quot;1844736251@qq.com&quot;), &quot;Apache 2.0&quot;, &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList()); &#125;&#125; 配置API文档的分组 1.groupName(&quot;陈留红&quot;) 如何配置多个分组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//多个人可以配置多个分组，这样就可以进行协同开发 @Bean public Docket docket1()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;a&quot;); &#125; @Bean public Docket docket2()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;b&quot;); &#125; @Bean public Docket docket3()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;c&quot;); &#125; @Bean public Docket docket4()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;d&quot;); &#125; //swagger的bean实例 @Bean public Docket docket(Environment environment)&#123; //设置要显示的swagger环境 Profiles profiles = Profiles.of(&quot;dev&quot; , &quot;test&quot;); //获取项目的配置环境 //判断是否处在自己设定的环境当中 boolean flag = environment.acceptsProfiles(profiles); return new Docket(DocumentationType.SWAGGER_2) .groupName(&quot;陈留红&quot;) .apiInfo(apiInfo()) .enable(flag) .select() //Predicate&lt;RequestHandler&gt; selector配置要扫描的接口的方式 //basePackage指定要扫描的包 //any()扫描全部 //none()都不扫描 //withClassAnnotation(&quot;Controller.class&quot;)扫描类上的注解 Controller 只扫描带有controller 的接口 //withMethodAnnotation() 扫描方法的注解 .apis(RequestHandlerSelectors.basePackage(&quot;com.timous.controller&quot;)) .build();//build工厂模式 &#125; 此外swagger还可以进行测试功能 实体类：12345678910111213141516171819202122232425package com.timous.pojo;import io.swagger.annotations.Api;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructor//给实体类增加注释，方便我们能够进行识别@ApiModel(&quot;用户实体类&quot;)//@Api(&quot;注释&quot;) 和上面的等价public class User &#123; @ApiModelProperty(&quot;id&quot;) private int id; @ApiModelProperty(&quot;用户名&quot;) private String username; @ApiModelProperty(&quot;密码&quot;) private String password;&#125; controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.timous.controller;import com.timous.pojo.User;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; //默认请求/error @GetMapping(value = &quot;/hello&quot;) public String hello()&#123; return &quot;hello&quot;; &#125; //只要我们的接口中存在实体类，他就会被扫描 @PostMapping(&quot;/user&quot;) public User user()&#123; return new User(); &#125; //接口 给接口加注释 不是放在类上面的，是放在方法上面的 @ApiOperation(&quot;hello控制类&quot;) @GetMapping(&quot;/hello2&quot;) public String hello(@ApiParam(&quot;用户名&quot;) String username)&#123; return &quot;hello&quot;+username; &#125; @ApiOperation(&quot;post测试&quot;) @PostMapping(&quot;/postt&quot;) public User postt(@ApiParam(&quot;用户名&quot;) User user)&#123; int i = 5/0; return user; &#125;&#125; swagger1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.timous.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.Environment;import org.springframework.core.env.Profiles;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;import java.util.ArrayList;@Configuration//开启swagger2@EnableSwagger2public class SwaggerConfig &#123; //多个人可以配置多个分组，这样就可以进行协同开发 @Bean public Docket docket1()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;a&quot;); &#125; @Bean public Docket docket2()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;b&quot;); &#125; @Bean public Docket docket3()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;c&quot;); &#125; @Bean public Docket docket4()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;d&quot;); &#125; //swagger的bean实例 @Bean public Docket docket(Environment environment)&#123; //设置要显示的swagger环境 Profiles profiles = Profiles.of(&quot;dev&quot; , &quot;test&quot;); //获取项目的配置环境 //判断是否处在自己设定的环境当中 boolean flag = environment.acceptsProfiles(profiles); return new Docket(DocumentationType.SWAGGER_2) .groupName(&quot;陈留红&quot;) .apiInfo(apiInfo()) .enable(flag) .select() //Predicate&lt;RequestHandler&gt; selector配置要扫描的接口的方式 //basePackage指定要扫描的包 //any()扫描全部 //none()都不扫描 //withClassAnnotation(&quot;Controller.class&quot;)扫描类上的注解 Controller 只扫描带有controller 的接口 //withMethodAnnotation() 扫描方法的注解 .apis(RequestHandlerSelectors.basePackage(&quot;com.timous.controller&quot;)) .build();//build工厂模式 &#125; //配置swagger信息apiInfo private ApiInfo apiInfo()&#123; return new ApiInfo(&quot;陈留红的swaggerApi文档&quot;, &quot;这个作者很nb&quot;, &quot;v1.0&quot;, &quot;http://timous.top&quot;, //作者信息 new Contact(&quot;陈留红&quot;, &quot;http://timous.top&quot;, &quot;1844736251@qq.com&quot;), &quot;Apache 2.0&quot;, &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList()); &#125;&#125; 总结：1.我们可以通过swagger给一些比较难理解的接口或者属性增加注释信息 2.接口文档是实时更新的 3.可以在线测试 可以解决很多问题，及时， 几乎所有的大公司都有使用 ， 更符合迭代开发的需求 &#x3D;&#x3D;注意&#x3D;&#x3D;：在正式发布的时候，关闭swagger！！！出于安全考虑，并且可以节省内存，运行时间会增加 任务异步任务~（多线程）1.加异步任务的注解@Async 2.加开启异步任务的注解@EnableAsync // 开启某个功能 定时任务~1234567TaskScheduler ： 任务调度者TaskExecutor : 任务执行者 @EnableScheduling@Scheduled //什么时候执行Cron表达式 ： 中国人不是很喜欢 邮件发送~需要时间配置yaml： 1234567891011spring: mail: username: 1844736251@qq.com password: knbexyliwidpcjff host: smtp.qq.com # 开启加密验证 properties: main: smtp: ssl: enable: true 测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.timous;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSenderImpl;import org.springframework.mail.javamail.MimeMessageHelper;import javax.mail.MessagingException;import javax.mail.internet.MimeMessage;import java.io.File;@SpringBootTestclass Springboot09TestApplicationTests &#123; @Autowired JavaMailSenderImpl mailSender; @Test void contextLoads() &#123; //一个简单的邮件 SimpleMailMessage message = new SimpleMailMessage(); message.setSubject(&quot;陈留红，你好~&quot;); message.setText(&quot;谢谢你的课程！！！&quot;); message.setTo(&quot;190027394@qq.com&quot;); message.setFrom(&quot;1844736251@qq.com&quot;); mailSender.send(message); &#125; @Test void contextLoads2() throws MessagingException &#123; //一个复杂的邮件 MimeMessage message = mailSender.createMimeMessage(); //组装 MimeMessageHelper helper = new MimeMessageHelper(message , true ); helper.setSubject(&quot;Timous科技&quot;); helper.setText(&quot;&lt;p style=&#x27;color:red&#x27;&gt;欢迎您&lt;/p&gt;&quot; , true); //附件 helper.addAttachment(&quot;1.jpg&quot; , new File(&quot;D:\\\\goolge\\\\1.jpg&quot;)); helper.addAttachment(&quot;2.jpg&quot; , new File(&quot;D:\\\\goolge\\\\1.jpg&quot;)); helper.setTo(&quot;190027394@qq.com&quot;); helper.setFrom(&quot;1844736251@qq.com&quot;); mailSender.send(message); &#125;&#125; 此外，你也可以自己封装一些东西 分布式Dubbo+Zookeeper+springboot什么是分布式系统分布式定义： 分布式系统时若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统 http或者是rpc连接（使用普通的廉价的计算机来进行实现服务） &#x3D;&#x3D;流动计算架构&#x3D;&#x3D; RPC协议（本质和http协议一样）进程之间的通信方式，不用管网络通信 RPC核心： 序列化（方便数据的传输） 和 通信 netty： 一个月 18年重启 RPC框架 不可能把springcloud干掉 服务提供者(Provider)：暴露服务的提供方，服务提供者在启动时，像注册中心注册自己提供的服务 服务消费者(Consumer)：调用远程服务的消费方，服务消费者在启动时，向注册中心订阅自己需要的服务，服务消费者，从服务提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选领一台调用 注册中心(Registry)： 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者 监控中心(Monitor)：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 dubbo环境搭建步骤： &#x3D;&#x3D;提供者提供服务&#x3D;&#x3D; 导入依赖 配置注册中心的地址，以及发现服务名和要扫描的包 在想要被注册的服务上面加一个@service，一定要是dubbo的 &#x3D;&#x3D;消费者如何消费&#x3D;&#x3D; 配置注册中心的地址，配置自己的服务名字 从远程注入服务~ 此处的所有的都要打开zookeeper 注册中心拿到的类1234567891011121314151617181920212223package com.timous.service;import org.apache.dubbo.config.annotation.DubboReference;import org.springframework.stereotype.Service;@Service//放到容器中public class UserService &#123; //想拿到provider提供的票 要去注册中心拿到我们的服务 @DubboReference//引用 pom坐标 可以定义路径相同的接口名 TicketService ticketService; public void buyTicket()&#123; String ticket = ticketService.getTicket(); System.out.println(&quot;在注册中心拿到了ticket====》&quot;+ticket); &#125;&#125; 注意此处如果要显示消费者的话，需要打断点，应该是默认就会关闭的 消费者配置12345678910server: port: 8002# 消费者去哪里拿 需要暴露自己的名字# 注册中心的地址dubbo: application: name: consumer-server registry: address: zookeeper://127.0.0.1:2181 提供者配置123456789101112server: port: 8080# 服务应用的名字# 注册中心的地址#dubbo: application: name: provider-server registry: address: zookeeper://127.0.0.1:2181 scan: base-packages: com.timous.service pom文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.timous&lt;/groupId&gt; &lt;artifactId&gt;provider-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;provider-server&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.0.RELEASE&lt;/spring-boot.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--导入依赖--&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-framework --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-recipes --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--日志会冲突--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.timous.ProviderServerApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 聊聊现在和未来回顾以前，架构： 三层架构mvc，架构本质就是为了解耦 开发框架 spring IOC AOP spring是一个轻量级的开源框架 容器 目的： 解决企业开发的复杂性问题 spring 春天，也十分复杂，配置文件过于复杂，为了简化，springboot应运而生，新一代javaee的开发标准，开箱即用 他可以&#x3D;&#x3D;自动帮我们配置很多的东西&#x3D;&#x3D;，我们拿来即用，springboot并不是新东西，就是spring的升级版 约定大于配置 IOC： 控制反转 约泡： 泡温泉 泡茶 ，，，，泡友 网上附近的人 打招呼 加微信 聊天 天天聊—》约 浴场： 温泉 茶庄 ，，，， 泡友 直接进温泉就有人和你一起 原来我们都是自己一步步操作，现在交给容器了 我们需要去拿就可以了 AOP ： 切面（本质是动态代理） 为了解决什么？ 不影响业务本来的情况下实现动态增加功能，大量应用在日志，事务等 随着公司体系越来越大，用户越来越多， 微服务架构—》新架构 模块化，功能化! 用户模块，支付模块，签到模块，娱乐模块，，， 人过于多，一台服务器解决不了，再增加服务器，横向解决问题 假设A服务器占用98%的资源B只占用10%—–》负载均衡； 将原来的整体项目，分成模块项目，用户是一个单独的项目，签到也是一个独立的项目，项目和项目之间需要通信，如何通信？ 万一用户非常多而签到十分少，这个时候给用户多一点服务器，给签到少一点服务器 微服务架构问题： ​\t分布式架构会遇到的四个核心问题 1.这么多服务，客户端该如何去访问？ 2.这么多服务之间如何通信 3.这么多服务如何治理呢？（）同一的服务管理平台 4，服务器挂了咋办 解决方案： springcloud ， 是一套生态，就是为了解决以上分布式架构的四个问题，但是想使用springcloud必须要掌握springboot。因为springcloud是基于springboot的 1.spring cloud netflix 出来了一套解决方案 一站式解决方案，我们都可以直接去拿 2018年底，宣布无限期停止维护 会脱节 api网关，zuul组件 Feign（HTTP） 基于http通信方式，同步并阻塞 服务注册于发现 eureka 熔断机制 Hystrix 2.Apache Dubbo Zookeeper ， 第二套解决系统 api网关 没有 第三方组件或者是自己实现 Dubbo 是一个高性能的基于java实现的RPC通信框架！！！ 服务注册与发现，交给了第三方的zookeeper： 动物园管理者 （hadoop hive） 没有熔断机制， 生态机制不完善 借助了Hystrix dubbo之前停更，现在又开始维护了 3.springcloud alibaba 一站式解决方案 目前又提出了一种方案： 服务网格： 下一代微服务标准，论文特别多关注server mesh 代表解决方案： istio （未来可能需要掌握） 万变不离其宗，一通百通 api网关 服务路由 RPC框架 异步调用 服务注册与发现 ， 高可用 熔断机制 服务降级 如果可以基于这四个问题开发一套解决方案，也叫springcloud微服务解决方案 为什么要解决这些问题？ 网络是不可靠的 前端需要变化，所以需要跑起来之后确定了之后才会","tags":["源码"]},{"title":"jar包下载问题","path":"/2022/01/03/jar包下载问题/","content":"jar包下载慢的问题的解决在maven的配置文件中增加如下的配置 12345678910111213141516171819202122232425262728293031323334353637&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;!-- 阿里云仓库 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库1 --&gt; &lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库2 --&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 配置完成即可快速下载jar包","tags":["小技巧"]},{"title":"shadingJDBC","path":"/2022/01/03/shadingJDBC/","content":"ShardingJDBC1.yum安装mysql1.1下载mysql的rpm地址http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/ 1.2配置mysql扩展源1rpm -ivh http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql57-community-release-el7-10.noarch.rpm 1.3yum安装mysql1yum install mysql-community-server -y 1.4启动mysql设置开机自启动1234systemctl start mysqldsystemctl status mysqldsystemctl stop mysqldsystemctl enable mysqld 1.5使用mysql初始密码进行登录12345gerp &quot;password&quot; /var/log/mysqld.logmysql -uroot -p出来的密码或者是以下的做法mysql -uroot -p$(awk &#x27;/temporary password/&#123;print $NF&#125;&#x27; /var/log/mysqld.log) 1.6修改数据库的密码数据库的默认的规则是必须携带大小写字母、特殊符号，字符串长度大于8，否则会报错 因此设定较为简单的密码是首先要修改set gloable validate_password_policy和length 12set global validate_password_policy=0;set global validate_password_length=1; 1.7修改密码1234567set password for root@localhost = password(&#x27;123456&#x27;);# 或者alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;# 给用户授权grant all on *.* to root@&#x27;%&#x27; identified by &#x27;123456&#x27;;# 刷新flush privileges; 1.8登录测试 通过测试，能够进行登录 2主从复制的配置2.1Master节点的配置12345678910111213vim /etc/my.cnf[mysqld]## 同一局域网内，注意要唯一server-id=100### 开启二进制日志 可以随便取（关键）log-bin=mysql-bin### 复制过滤： 不需要备份的数据库不输出（mysql库一般不同步）binlog-ignore-db=mysql### 为每个session分配内存，在事务过程中用来存储二进制日志的缓存binlog_cache_size=1M### 主从复制的格式（mixed ， statement ， row 默认格式是statement）binlog_format=mixed 2.2slave节点的配置123456789101112131415161718192021222324252627282930313233vim /etc/my.cnf[mysqld]## 同一局域网内，注意要唯一server-id=102### 开启二进制日志功能 ， 已备份slave作为其他slave的Master时使用log-bin=mysql-slave-bin### relay_log配置中继日志relay_log=edu-mysql-relay-bin### 复制过滤： 不需要备份的数据库不输出（mysql库一般不同步）binlog-ignore-db=mysql### 如果需要同步函数或者是存储过程log_bin_trust_function_creators=true### 为每个session分配内存，在事务过程中用来存储二进制日志的缓存binlog_cache_size=1M### 主从复制的格式（mixed ， statement ， row 默认格式是statement）binlog_format=mixed[mysqld]## 同一局域网内，注意要唯一server-id=101### 开启二进制日志功能 ， 已备份slave作为其他slave的Master时使用log-bin=mysql-slave-bin### relay_log配置中继日志relay_log=edu-mysql-relay-bin### 复制过滤： 不需要备份的数据库不输出（mysql库一般不同步）binlog-ignore-db=mysql### 如果需要同步函数或者是存储过程log_bin_trust_function_creators=true### 为每个session分配内存，在事务过程中用来存储二进制日志的缓存binlog_cache_size=1M### 主从复制的格式（mixed ， statement ， row 默认格式是statement）binlog_format=mixed 2.3在master服务器上进行授权123456789## 登录数据库mysql -uroot -p123456## 进行授权grant replication slave , replication client on *.* to &#x27;root&#x27;@&#x27;47.105.129.77&#x27; identified by &#x27;123456&#x27;;## 刷新权限flush privileges;##查看mysql具有哪些用户及对应的IP权限（可以不执行，只是一个查看）select user , host from mysql.user; 2.4查看对应的binlog文件名和位置（master节点执行）1show master status; 2.5配置从服务器的连接1234## 连接对应的主数据库change master to master_host=&#x27;81.69.232.6&#x27; , master_user=&#x27;root&#x27; , master_password=&#x27;123456&#x27; , master_port=3306, master_log_file=&#x27;mysql-bin.000001&#x27; , master_log_pos=1247;## 启动 2.6经过测试，主从复制就会完成了3.读写分离的springboot实现3.1pom.xml文件配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;top.timous&lt;/groupId&gt; &lt;artifactId&gt;shadingjdbctest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;shadingjdbctest&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;shading-sphere.version&gt;4.0.0-RC1&lt;/shading-sphere.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--web的基本依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis的jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok简化实体类的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--测试的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--shardingjdbc 的starter包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;shading-sphere.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-core-common&lt;/artifactId&gt; &lt;version&gt;$&#123;shading-sphere.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;com.alibaba&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;druid&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;1.2.3&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;top.timous.ShadingjdbctestApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.2yml文件配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950server: port: 8080spring: main: allow-bean-definition-overriding: true shardingsphere: props: sql: show: true #配置数据源 datasource: # ds1 一个主的mysql ds2 和 ds3都是slave从库 names: ds1,ds2,ds3 # 配置数据源的具体的信息 ds1: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://81.69.232.6:3306/ksd_order_db?useUnicide=true&amp;characterEncoding=utf-8&amp;tinyIntlisBit=false&amp;useSSL=false&amp;serverTimeZone=GMT%2b8 username: root password: 123456 maxPoolSize: 100 minPoolSize: 5 ds2: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://121.4.161.181:3306/ksd_order_db?useUnicide=true&amp;characterEncoding=utf-8&amp;tinyIntlisBit=false&amp;useSSL=false&amp;serverTimeZone=GMT%2b8 username: root password: 123456 maxPoolSize: 100 minPoolSize: 5 ds3: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://47.105.129.77:3306/ksd_order_db?useUnicide=true&amp;characterEncoding=utf-8&amp;tinyIntlisBit=false&amp;useSSL=false&amp;serverTimezone=GMT%2b8 username: root password: 123456 maxPoolSize: 100 minPoolSize: 5 # 不配置下面的话写入的时候会出现问题 ， 会报错 下面才是读写分离的 sharding: default-data-source-name: ds1 # 之后下面配置的就是我们的策略等规则的东西 可以不用配置 masterslave: name: ms master-data-source-name: ds1 slave-data-source-names: ds2,ds3 load-balance-algorithm-type: round_robinmybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: top.timous.entity 3.3代码的基本结构 3.4controller层12345678910111213141516171819202122232425262728293031323334353637383940package top.timous.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import top.timous.entity.User;import top.timous.mapper.UserMapper;import java.util.Date;import java.util.List;/** * @author Timous * @create 2021-03-23 18:33 **/@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserMapper userMapper; @GetMapping(&quot;/save&quot;) public String insert()&#123; User user = new User(); user.setAge(12); user.setBirthday(new Date()); user.setNickname(&quot;timous1&quot;); user.setPassword(&quot;123456&quot;); userMapper.addUser(user); return &quot;success&quot;; &#125; @GetMapping(&quot;/listuser&quot;) public List&lt;User&gt; listUser()&#123; return userMapper.findUser(); &#125;&#125; 3.5mapper层123456789101112131415161718192021222324252627282930313233package top.timous.mapper;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import org.springframework.stereotype.Component;import top.timous.entity.User;import java.util.List;/** * @author Timous * @create 2021-03-23 18:29 **/@Mapperpublic interface UserMapper &#123; /** * 插入用户 */ @Insert(&quot;insert into ksd_user(nickname , password , age , birthday) values (#&#123;nickname&#125; , &quot; + &quot;#&#123;password&#125; , #&#123;age&#125; ,#&#123;birthday&#125;)&quot;) void addUser(User user); /** * 查找所有的用户 */ @Select(&quot;select * from ksd_user&quot;) List&lt;User&gt; findUser();&#125; 3.6mapper.xml12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org/DTD Mapper 3.0&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;top.timous.mapper.UserMapper&quot;&gt;&lt;/mapper&gt; 3.7entity层123456789101112131415161718192021222324package top.timous.entity;import lombok.Data;import java.util.Date;/** * @author Timous * @create 2021-03-23 18:27 **/@Datapublic class User &#123; //id private Integer id; //昵称 private String nickname; //密码 private String password; //年龄 private Integer age; //出生日期 private Date birthday;&#125; 3.8数据库的表 3.9测试的结果 在读的时候是ds2和ds3轮询的规则 ， 在写的时候是写入ds1的。 4.分库分表4.1为什么分库分表单个的mysql在超过2k的时候就会出现问题 ， 最好是并发量控制在1k左右。 目的： 解决高并发，和数据量大的问题 4.2水平拆分和垂直拆分水平拆分： 同一个拆分为多个数据表 垂直拆分： 一般是针对各个服务进行拆分，也就是业务的模块 表的垂直拆分： 字段的使用频率不一，可以拆分为两个表","tags":["数据库"]},{"title":"redis初步学习","path":"/2022/01/02/redis初步学习/","content":"Redis.config详解工作中小小的东西都会脱颖而出 单位 1.配置文件对于大小写是不敏感的 2.可以包含多个文件，共同组合为一个配置文件 网络 123bind 127.0.0.1 绑定的ipprotected-mode yes 是否受到保护，一般的时候都是开启的port 6379 默认的端口号 通用GENERAL 12345678910111213141516daemonize yes 默认为no ， 以守护进程的方式运行为yes，这里，我们修改为了yespidfile /var/run/redis_6379.pid 如果以后台的方式运行，我们就需要指定一个pid文件# 日志# Specify the server verbosity level.# This can be one of:# debug (a lot of information, useful for development/testing) # verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably)# warning (only very important / critical messages are logged)loglevel noticelogfile &quot;&quot; # 日志的文件输出名字databases 16 # 数据库的数量，默认有16 个数据库always-show-logo yes # 默认显示redis的logo 快照SNAPSHOTTING 持久化，在规定的时间内操作了多少次，则会持久化到文件 .rdb .aof , redis是内存数据库，如果没有持久化，那么数据会断电即失的。 1234567891011121314save 900 1 # 900是时间 1 是次数 如果900秒内，如果至少有一个key进行修改，就进行持久化操作save 300 10 # 如果300秒内，如果至少有10个key进行修改，就进行持久化操作save 60 10000 # 如果60秒内，如果至少有10000个key进行修改，就进行持久化操作# 之后学习会自己定义这个测试stop-writes-on-bgsave-error yes # 持久化如果出错，是否还需要继续工作rdbcompression yes # 是否压缩rdb文件 ， 需要消耗一些cpu的资源 ， 可以关掉rdbchecksum yes # 保存rdb文件的时候进行错误的校验dbfilename dump.rdb # 持久化生成的rdb文件dir ./ # 文件保存的目录 REPLICATION 复制，后面讲主从复制的时候进行讲解 安全SECURITY 可以在这里设置密码，默认是没有密码的！ 1234567891011121314127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; config get requirepass # 获取密码1) &quot;requirepass&quot;2) &quot;&quot;127.0.0.1:6379&gt; config set requirepass &quot;123456&quot; # 设置密码OK127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; auth 123456 # 使用密码进行登录OK127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;123456&quot; 限制 CLIENTS 1234567891011121314maxclients 10000 # 设置最大客户端的数量maxmemory &lt;bytes&gt; # redis 配置的最大内存容量maxmemory-policy noeviction # 内存到上限之后的处理策略\t# 移除一些过期的key\t# 报错\t# ... 1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） 2、allkeys-lru ： 删除lru算法的key 3、volatile-random：随机删除即将过期key 4、allkeys-random：随机删除 5、volatile-ttl ： 删除即将过期的 6、noeviction ： 永不过期，返回错误 APPEND ONLY MODE 模式 aof配置 1234567appendonly no # 默认是不开启的，默认使用的是rdb方式持久化，在大部分的情况下，rdb完全够用了！appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字 .rdbappendfsync always # 每次修改都会sync ， 消耗性能appendfsync everysec # 每秒执行一次 sync 可能会丢失1s的数据appendfsync no # 不执行sync ， 这个时候操作系统自己同步数据，速度最快 具体的配置，我们在redis持久化中去详细解释 Redis持久化面试和工作中，持久化都是重点！ Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以Redis提供了持久化功能！ RDB（Redis Database） 什么是RDB 在主从复制中，rdb就是备用的!从机上面 在指定的间隔时间内内存中的快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何的IO操作的。这就确保了极高的性能。如果需要进行大规模的数据的恢复，且对于数据恢复的完整性不是非常敏感。那RDB方式比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般的情况下，不需要修改这个配置。 有时候在生产环境我们会对这个数据进行备份！ &#x3D;&#x3D;RDB文件默认的保存是dump.rdb&#x3D;&#x3D;都是在配置文件中配置的 触发机制 1、save规则满足的情况下，会自动触发RDB规则 2、执行flushall命令，也会触发我们的RDB规则 3、退出redis，也会产生rdb文件 备份就会自动生成一个.rdb文件 如何恢复rdb文件 1、只需要将rdb文件放在我们的redis启动的目录就可以，redis启动的时候会自动检查dump.rdb，恢复其中的数据 2、查看需要的位置 123127.0.0.1:6379&gt; config get dir1) &quot;dir&quot;2) &quot;/usr/local/bin&quot; # 如果在这个目录下存在dump.rdb文件，启动的时候就会自动恢复其中的数据 几乎就他自己的默认的配置就够用了，但是我们还需要去学习 优点： 1、适合大规模的数据恢复！ dump.rdb 2、对数据的完整性要求不高！ 缺点： 1、需要一定的时间间隔进行操作！如果redis意外宕机，这个最后一次修改的数据就没了。 2、fork进程的时候，会占用一定的内存空间 AOF (Append Only File)将我们的所有的命令都记录下来，history，恢复的时候会把这个文件全部执行一遍 是什么 以日志的形式来记录每一个写的操作，将redis执行过的所有指令记录下来（读操作不记录），只追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 &#x3D;&#x3D;AOF保存的文件默认是appendonly.aof&#x3D;&#x3D; append 我们只需要将配置改为yes就行了 ， 重启redis就可以生效了。 如果AOF文件有错误，这个时候redis是不能启动的，我们需要修复配置文件，redis给我们提供了这样一个工具redis-check-aof --fix 之后就能正常的启动了。 重写规则： 如果aof文件大于64MB就会fork一个新的进程来讲我们的文件进行重写 默认就是文件的无限制的追加 ，文件会越来越大，会有重写 AOP的优点和缺点 123456789appendonly no # 默认是不开启的，默认使用的是rdb方式持久化，在大部分的情况下，rdb完全够用了！appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字 .rdbappendfsync always # 每次修改都会sync ， 消耗性能appendfsync everysec # 每秒执行一次 sync 可能会丢失1s的数据appendfsync no # 不执行sync ， 这个时候操作系统自己同步数据，速度最快# rewrite 重写 优点： 1、每一次修改都同步，文件的完整性会更加的好！ 2、每秒同步一次，可能会丢失一秒的数据！ 3、从不同步，效率最高 缺点： 1、相对数据文件来说，aof远远大于rdb，修复的速度也比rdb慢！ 2、aof运行的效率也要比rdb慢，redis默认的配置是rdb，不是aof 扩展：1、RDB持久化方式能够在指定时间的间隔内对你的数据进行快照存储 2、AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件的末尾，redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。 3、&#x3D;&#x3D;只做缓存 ， 如果你只希望你的数据在服务器运行的时候存在，你也可以不使用持久化&#x3D;&#x3D; 4、同时开启两种持久化方式 这种情况下，当redis重启的时候，会优先载入AOF文件来恢复原始的数据，因为在通常的情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 RDB数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要使用AOF文件呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化，不好备份），快速重启，而且AOF可能有潜在的Bug，留作一个万一的手段。 5、性能建议 因为RDB文件只用做后备用途，建议只在slave上持久化RDB文件，而且只要15分钟做一次备份就够了，只保留save 900 1这条规则 如果Enable AOF，好处是在恶劣的情况下也只会丢失不超过2秒的数据，启动脚本简单制load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewriter 的最后rewriter过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewriter的频率，AOF重写的基础大小，可以设到5G以上，默认超过原大小的100%大小重写可以改到适当的频率。 如果不Enable AOF ， 仅靠Master-Slave Replication实现高可用性也可以，能省掉一大笔IO，也减少了rewriter时带来的系统波动。代价是如果Master&#x2F;Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master&#x2F;Slave中的RDB文件，载入较新的那个，微博就是这种框架。 Redis发布订阅Redis发布订阅（pub&#x2F;sub）是一种&#x3D;&#x3D;消息通信模式：&#x3D;&#x3D;发送者发送消息，订阅者接受消息 微信、微博、关注系统 Redis客户端可以订阅任意数量的频道。 订阅发布消息图： 第一个： 消息发送者 第二个： 频道 第三个： 消息订阅者 下图展示了频道channel1，以及订阅这个频道的三个客户端— client2、client5和client1之间的关系 当有新消息通过PUBLISH命令发送给频道channel1时，这个消息就会被发送给订阅它的三个客户端： 命令 这些命令被用于广泛用于构建及时通信应用，比如网络聊天室（chatroom）和及时广播、实时提醒等。 测试 订阅端： 123456789101112127.0.0.1:6379&gt; SUBSCRIBE timous # 订阅一个频道 timousReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;timous&quot;3) (integer) 1# 等待读取推送的信息1) &quot;message&quot; # 消息2) &quot;timous&quot; # 那个频道的消息3) &quot;hello world&quot; # 消息的具体内容1) &quot;message&quot;2) &quot;timous&quot;3) &quot;hello redis&quot; 发送端： 1234127.0.0.1:6379&gt; PUBLISH timous &quot;hello world&quot; # 发送者发布消息到频道(integer) 1127.0.0.1:6379&gt; PUBLISH timous &quot;hello redis&quot; # 发送者发布消息到频道(integer) 1 原理 Redis是使用C实现的，通过分析Redis源码里的pubsub.c文件，了解发布和订阅机制的底层实现，籍此加深对Redis的理解。 Redis通过PUBLISH、SUBSCRIBE 和PSUBSCRIBE等命令实现发布和订阅功能。 通过SUBSCRIBE命令订阅某频道后，redis-server 里维护了-个字典，字典的键就是一个个 channel，而字典的值则是一 个链表，链表中保存了所有订阅这个channel的客户端。SUBSCRIBE命令的关键，就是将客户端添加到给定channel的订阅链表中。 通过PUBLISH命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。 Pub&#x2F;Sub从字面上理解就是发布(Publish) 与订阅(Subscribe) ,在Redis中, 你可以设定对某-个key值进行消息发布及消息订阅，当-个key值 上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天,群聊等功能。 使用场景1、实时消息系统 2、实时聊天！（频道当做聊天室，将信息回显给所有人即可） 3、订阅、关注系统 稍微复杂的场景使用消息中间件 Redis主从复制概念主从复制，是指将一台Redis服务器的数据， 复制到其他的Redis服务器。前者称为主节点(master&#x2F;leader),后者称为从节点(slave&#x2F;follower);数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。默认情况下&#x3D;&#x3D;每台Redis服务器都是主节点;且一个主节点可以有多个从节点(或没有从节点，但-个从节点只能有一个主节点&#x3D;&#x3D;。主从复制的作用主要包括: 1、数据冗余:主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 2、故障恢复:当主节点出现问题时，可以由从节点提供服务,实现快速的故障恢复;实际上是一种服务的冗余。 3、负载均衡:在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点) .分担服务器负载;其是在写少读多的场景下，通过多个从节点分担读负载，可以大提高Redis服务器的并发量。 4、高可用基石:除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。 一般来说， 要将Redis运用于工程项目中，只使用一台Redis是万万不能的（可能会宕机，一般是3台服务器）， 原因如下: 1、从结构上，单个Redis服务器会发生单点故障,并且一 台服务器需要处理所有的请求负载.压力较大; 2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G， 也不能将所有内存用作Redis存储内存，-般来说，&#x3D;&#x3D;单台Redis最大使用内存不应该超过20G&#x3D;&#x3D;.电商网站上的商品，-般都是一-次 上传，无数次浏览的，说专业点也就是“多读少写”。对于这种场景，我们可以使如下这种架构: 主从复制，读写分离，80%的情况下都是进行读操作！减缓服务器压力，架构中经常使用！一主二从！redis集群至少要3台redis服务器！ 只要在公司中，主从复制是必须的。 环境配置只配置从库，不配置主库 123456789101112127.0.0.1:6379&gt; info replication # 查看当前库的信息# Replicationrole:master # 角色 masterconnected_slaves:0 # 没有从机master_replid:ba9569ee72d2bfd5199f4f3bf9d9fca5ec32a9c6master_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0 启动四台服务器的redis的服务。 复制三个配置文件，修改对应的信息： 1、端口 2、pid 3、log文件的名字 4、dump.rdb的名字 修改完毕之后启动三个redis服务可以通过进程信息查看： 一主二从&#x3D;&#x3D;默认情况下每台Redis服务器都是主节点;且一个主节点可以有多个从节点(或没有从节点，但-个从节点只能有一个主节点。&#x3D;&#x3D;我们一帮情况下只需要配置从机就行了，认老大。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051127.0.0.1:6380&gt; slaveof 127.0.0.1 6379 # 认老大OK127.0.0.1:6380&gt; info replication # 查看讯息# Replicationrole:slave # 是一个从机master_host:127.0.0.1master_port:6379master_link_status:upmaster_last_io_seconds_ago:4master_sync_in_progress:0slave_repl_offset:0slave_priority:100slave_read_only:1connected_slaves:0master_replid:890f958f7be6d7e9922f309d307c855fa7b94297master_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:0# ===============================================127.0.0.1:6379&gt; info replication# Replicationrole:master # 主机connected_slaves:1 # 有一个从机 slave0:ip=127.0.0.1,port=6380,state=online,offset=14,lag=0 # 从机的信息master_replid:890f958f7be6d7e9922f309d307c855fa7b94297master_replid2:0000000000000000000000000000000000000000master_repl_offset:14second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:14# ====================127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:2 # 有两个从机slave0:ip=127.0.0.1,port=6380,state=online,offset=238,lag=0slave1:ip=127.0.0.1,port=6381,state=online,offset=238,lag=0master_replid:890f958f7be6d7e9922f309d307c855fa7b94297master_replid2:0000000000000000000000000000000000000000master_repl_offset:238second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:238 两个配置完成之后就有两个： 真是的主从配置，在配置文件中配置，这样的话是永久的，我们这里使用的是命令，这里是暂时的 细节了解 主机可以写，从机不能写，只能读！主机中的所有的信息都会被从机保存 测试： 主机断开连接，从机依旧是连接到主机的，但是没有写操作，主机如果回来，从机依旧可以获得主机的信息。 如果是使用的命令行的配置，重启之后就是主机了。只要变为从机，数据立刻就会从主机获得。 复制原理 Slave启动成功连接到master后会发送一个sync同步的命令。 Master接到命令之后，启动后台的存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕之后，&#x3D;&#x3D;master将传送整个文件到salve&#x3D;&#x3D;，并完成一次完全同步。 全量复制：&#x3D;&#x3D;而salve服务在接收到数据库文件数据库，将其存盘并加载到内存中&#x3D;&#x3D;。 增量复制：&#x3D;&#x3D;Master继续将新的所有收集到的修改命令一次传给slave，完成同步&#x3D;&#x3D; 但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定会在从机中看到。 层层链路 上一个master连接下一个slave 工作中不会使用。 如果没有老大，这个时候能不能选择一个老大？哨兵模式出来之前都是手动来进行操作的。 如果主机断开了连接，可以使用下面的命令让自己变成主机slaveof no one： 123456789101112131415127.0.0.1:6380&gt; slaveof no oneOK127.0.0.1:6380&gt; info replication# Replicationrole:masterconnected_slaves:1slave0:ip=127.0.0.1,port=6381,state=online,offset=1546,lag=1master_replid:2b01943101d3aab615f57514fb11c7e7278f4148master_replid2:0b581ea15c1cf9ba9a8803916b0c3e1f633e7d44master_repl_offset:1546second_repl_offset:1547repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1243repl_backlog_histlen:304 如果这个时候老大修复，就只能进行重新进行 哨兵模式（自动选举老大的模式） 概述 主从切换技术的方法是:当主服务器宕机后，需要手动把一台从服务 器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。 这不是-种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel (哨兵)架构来解决这个问题。 谋朝算位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。 哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程， 作为进程，它会独立运行。其原理是哨兵通过发送命令,等待Redis服务器响应,从而监控运行的多个Redis实例。 这里的哨兵有两个作用 通过发送命令,让Redis服务器返回监控其运行状态，包括主服务器和从服务器。 当哨兵监测到master宕机， 会自动将slave切换成master,然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。 然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。 假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马.上进行failover过程,仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行-次投票，投票的结果由-个哨兵发起，进行ailover故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。 配置测试 1、配置哨兵配置文件sentinel.conf 12sentinel monitor myredis 127.0.0.1 6379 1sentinel monitor # 被监控的名称 主机地址 主机端口 1 # 后面的1表示主机挂了之后从机投票来判断让谁接替成为主机，票数最多的就会成为主机 2、启动哨兵！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283[root@izbp169pmuqqu68q0mhkfaz bin]# redis-sentinel cconfig/sentinel.conf 18689:X 08 Aug 2020 18:54:16.763 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo18689:X 08 Aug 2020 18:54:16.763 # Redis version=6.0.6, bits=64, commit=00000000, modified=0, pid=18689, just started18689:X 08 Aug 2020 18:54:16.763 # Configuration loaded _._ _.-``__ &#x27;&#x27;-._ _.-`` `. `_. &#x27;&#x27;-._ Redis 6.0.6 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ &#x27;&#x27;-._ ( &#x27; , .-` | `, ) Running in sentinel mode |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;| Port: 26379 | `-._ `._ / _.-&#x27; | PID: 18689 `-._ `-._ `-./ _.-&#x27; _.-&#x27; |`-._`-._ `-.__.-&#x27; _.-&#x27;_.-&#x27;| | `-._`-._ _.-&#x27;_.-&#x27; | http://redis.io `-._ `-._`-.__.-&#x27;_.-&#x27; _.-&#x27; |`-._`-._ `-.__.-&#x27; _.-&#x27;_.-&#x27;| | `-._`-._ _.-&#x27;_.-&#x27; | `-._ `-._`-.__.-&#x27;_.-&#x27; _.-&#x27; `-._ `-.__.-&#x27; _.-&#x27; `-._ _.-&#x27; `-.__.-&#x27; 18689:X 08 Aug 2020 18:54:16.764 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.18689:X 08 Aug 2020 18:54:16.767 # Sentinel ID is 268cf2a7ec387b1ac1bbb8a4a064df21a12f66ea18689:X 08 Aug 2020 18:54:16.767 # +monitor master myredis 127.0.0.1 6379 quorum 118689:X 08 Aug 2020 18:54:16.767 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 637918689:X 08 Aug 2020 18:54:16.769 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379#############################################################我们的主机挂掉之后产生了新的主机18689:X 08 Aug 2020 18:55:48.279 # +elected-leader master myredis 127.0.0.1 637918689:X 08 Aug 2020 18:55:48.279 # +failover-state-select-slave master myredis 127.0.0.1 637918689:X 08 Aug 2020 18:55:48.334 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 637918689:X 08 Aug 2020 18:55:48.334 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 637918689:X 08 Aug 2020 18:55:48.386 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 637918689:X 08 Aug 2020 18:55:49.016 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 637918689:X 08 Aug 2020 18:55:49.016 # +failover-state-reconf-slaves master myredis 127.0.0.1 637918689:X 08 Aug 2020 18:55:49.073 * +slave-reconf-sent slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 637918689:X 08 Aug 2020 18:55:50.031 * +slave-reconf-inprog slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 637918689:X 08 Aug 2020 18:55:50.031 * +slave-reconf-done slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 637918689:X 08 Aug 2020 18:55:50.093 # +failover-end master myredis 127.0.0.1 637918689:X 08 Aug 2020 18:55:50.093 # +switch-master myredis 127.0.0.1 6379 127.0.0.1 638118689:X 08 Aug 2020 18:55:50.093 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 638118689:X 08 Aug 2020 18:55:50.093 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 638118689:X 08 Aug 2020 18:56:20.107 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381###############################################################6381的信息127.0.0.1:6381&gt; info replication# Replicationrole:slave #### 开始的时候是从机master_host:127.0.0.1master_port:6379master_link_status:downmaster_last_io_seconds_ago:-1master_sync_in_progress:0slave_repl_offset:16685master_link_down_since_seconds:22slave_priority:100slave_read_only:1connected_slaves:0master_replid:d5db416fa751225d5843b68849657eeb1cf409aamaster_replid2:0000000000000000000000000000000000000000master_repl_offset:16685second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:16685127.0.0.1:6381&gt; info replication# Replicationrole:master #### 后来变成了主机connected_slaves:1slave0:ip=127.0.0.1,port=6380,state=online,offset=19946,lag=0master_replid:2d3cd9ab51f3db7a1c6822d3a3b9b4024ab106dbmaster_replid2:d5db416fa751225d5843b68849657eeb1cf409aamaster_repl_offset:19946second_repl_offset:16686repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:19946##############################6380一直是从机 如果master节点断开了之后，这个时候就会从从机中随机选择一个服务器（里面有一个投票的算法） 哨兵日志： 如果主机回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则！ 哨兵模式 优点： 1、哨兵集群，一般基于主从复制的模式，所有的主从配置的优点全都有 2、主从可以切换，故障可以转移，系统的可用性会更好 3、哨兵模式就是主从模式的升级，手动到自动，更加健壮 缺点 1、Redis不好在线扩容，集群的容量一旦达到上限，在线扩容就十分麻烦 2、实现哨兵模式的配置其实很麻烦，里面有很多的选择 哨兵模式的全部配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379 port 26379 如果有哨兵集群，需要配置多个文件 # 哨兵sentinel的工作目录 dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。 # quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了 # sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; sentinel monitor mymaster 127.0.0.1 6379 2# 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都 要提供密码 # 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码 # sentinel auth-pass &lt;master-name&gt; &lt;password&gt; sentinel auth-pass mymaster MySUPER--secret-0123passw0rd# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒 # sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时多可以有多少个slave同时对新的master进行 同 步， 这个数字越小，完成failover所需的时间就越长， 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。 # sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; sentinel parallel-syncs mymaster 1# 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。 #2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的 master那里同步数据时。 #3.当想要取消一个正在进行的failover所需要的时间。 #4.当进行failover时，配置所有slaves指向新的master所需的大时间。不过，即使过了这个超 时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟 # sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt; sentinel failover-timeout mymaster 180000# SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮 件通知相关人员。 #对于脚本的运行结果有以下规则： #若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10 #若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。 #如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。 #一个脚本的大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执 行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等 等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常 运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果 sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执 行的，否则sentinel无法正常启动成功。#通知脚本 # sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本 # 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master 地址已经发生改变的信息。 # 以下参数将会在调用脚本时传给脚本:# &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt; # 目前&lt;state&gt;总是“failover”, # &lt;role&gt;是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的 slave)通信的# 这个脚本应该是通用的，能被多次调用，不是针对性的。# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt; sentinel client-reconfig-script mymaster /var/redis/reconfig.sh Redis缓存穿透和雪崩（面试高频，工作常用）缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于 是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是 都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。 概念 布隆过滤器布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则 丢弃，从而避免了对底层存储系统的查询压力； 缓存空对象当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数 据将会从缓存中获取，保护了后端数据源； 但是这种方法会存在两个问题：1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多 的空值的键；2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于 需要保持一致性的业务会有影响。 缓存穿透 概述 这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中 对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一 个屏障上凿开了一个洞。当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访 问数据库来查询新数据，并且回写缓存，会导使数据库瞬间压力过大。 解决方案 设置热点数据永不过期从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。 加互斥锁分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布 式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考 验很大。 缓存雪崩 概念 缓存雪崩，是指在某一个时间段，缓存集中过期失效。 产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商 品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都 过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波 峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。 其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然 形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就 是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知 的，很有可能瞬间就把数据库压垮。 解决方案 redis高可用这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续 工作，其实就是搭建的集群。 限流降级这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对 某个key只允许一个线程查询数据和写缓存，其他线程等待。 数据预热数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数 据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让 缓存失效的时间点尽量均匀。","tags":["数据库"]},{"title":"mysql学习","path":"/2022/01/01/mysql学习/","content":"MySQL1、初始MySQLjavaEE： 企业级开发 web 前端（页面渲染，展示 数据） 后台（连接点： 连接数据库 jdbc mybatis 连接前端（控制视图的跳转，给前端传递数据）） 数据库（存取数据） 1.1为什么学习数据库1.岗位需求 2.现在的世界，大数据时代—mysql集群，得数据者得天下，没有隐私 3.被迫需求：存数据 去IOE 不用国外的 4.&#x3D;&#x3D;数据库是所有软件体系中最核心的存在&#x3D;&#x3D;DBA（数据库管理员） 1.2什么是数据库数据库（DataBase） 概念： 数据仓库， 存储数据 &#x3D;&#x3D;软件&#x3D;&#x3D;， 安装在操作系统之上的 sql 可以存储大量的数据 作用： 存数据，管理数据 1.3数据库分类关系型数据库： Excle（SQL） Mysql、oracle、 sql server、DB2、SQLLite 通过表和表之间，行和列之间的关系进行数据的存储，学院信息表 考勤表 非关系型数据库： json （key ： value）（NoSQL 不仅仅是sql） redis、mongdb 非关系型数据库, 对象存储，通过对象的自身的属性来决定 &#x3D;&#x3D;DBMS（数据库管理系统）&#x3D;&#x3D; 数据库管理软件，科学有效的管理我们的数据，维护和获取数据； MySQL，本质是一个数据库管理系统！ 1.4MySQL简介&#x3D;&#x3D;MySQL是一个**关系型数据库管理系统****&#x3D;&#x3D;，**由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为&#x3D;&#x3D;社区版&#x3D;&#x3D;和&#x3D;&#x3D;商业版&#x3D;&#x3D;，由于其&#x3D;&#x3D;体积小、速度快、总体拥有成本低&#x3D;&#x3D;，尤其是开放源码这一特点，一般&#x3D;&#x3D;中小型网站的开发都选择 MySQL 作为网站数据库&#x3D;&#x3D;。也可以用于大型网站 前世：由瑞典MySQL AB 公司开发 今生：属于 Oracle 旗下产品 MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一，开源的数据库软件 5.7 版本稳定 8.0也可以 官网：https://www.mysql.com/ 官网下载地址：https://dev.mysql.com/downloads/mysql/ 安装建议 ： 尽量不要使用.exe文件 尽可能使用安装包安装 1.5安装MySQL1.解压安装包 2.配置环境变量 新加path就行 3.新建mysql配置文件ini， 把文件的扩展名打开 my.ini 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=D:\\\\mysql\\mysql-8.0.18-winx64# 切记此处一定要用双斜杠\\\\，单斜杠这里会出错。# 设置mysql数据库的数据的存放目录datadir=D:\\\\mysql\\mysql-8.0.18-winx64\\\\Data# 此处同上# 允许最大连接数max_connections=200# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 4.管理员模式，打开所有的东西 5.进入bin目录下 123456# 安装mysql服务mysqld -install# 初始化数据问价mysqld --initialize-insecure --user=mysql# 启动mysql 服务net start mysql # 会显示mysql启动成功 6.进入mysql修改密码update user set password=password(&quot;123456&quot;) where user=&quot;root&quot;; flush privileges;注释跳过密码 7.重启服务，然后进行登录mysql -uroot -p123456sql后面一定要加上分号 8.sc delete mysql清空服务 1.6无脑安装sqlyog一些简单的操作 创建数据库 1.7连接数据库 命令行连接 1234567891011121314151617181920mysql -uroot -p123456 --连接数据库update mysql.user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and Host = &#x27;localhost&#x27;; -- 修改用户的密码flush privileges;` -- 刷新权限-- 所有的语句都用分号结尾-------------------------show databases; -- 查询所有的数据库mysql&gt; use `school`; -- 切换数据库Database changedshow tables; --查看数据库中所以的表describe student; -- 显示表中所有的字段的信息-------------------------create database mytest; -- 创建一个数据库exit; -- 退出连接# 是sqlyog 的注释 -- 是sql的注释 /**/ 是多行注释-- 单行注释 数据库xxx语言增删改查 cv程序员 api程序员 crud业务程序员 DDL： &#x3D;&#x3D;数据库定义语言&#x3D;&#x3D; DML： &#x3D;&#x3D;数据库操作语言&#x3D;&#x3D; DQL： &#x3D;&#x3D;数据库查询语言&#x3D;&#x3D;（核心一般是查询语言） DCL：&#x3D;&#x3D;数据库控制语言&#x3D;&#x3D; 2.操作数据库mysql的关键字不区分大小写 操作数据库&gt;操作数据库中的表&gt;操作数据库表中的数据 2.1操作数据库（了解，操作一遍就可以了）1.创建数据库 1CREATE DATABASE IF NOT EXISTS mytest; 2.删除数据库 1DROP DATABASE IF EXISTS mytest; 3.使用数据库 1USE school; &#x3D;&#x3D;注意： 如果是使用关键词来表示数据库，那么需要加一个&#96;来进行转移义&#x3D;&#x3D; 4.查看数据库 1SHOW DATABASES; -- 展示所有的数据库 &#x3D;&#x3D;对比sqlyog的可视化操作&#x3D;&#x3D; &#x3D;&#x3D;学习思路： 不会的操作对比sqlyog操作&#x3D;&#x3D; 2.2数据库的数据列类型 数值 tinyint 十分小的类型 1个字节 smallint 比较小的类型 2个字节 mediumint 中等大小的数据 3个字节 &#x3D;&#x3D;int&#x3D;&#x3D; 标准的整数 4个字节&#x3D;&#x3D;后面的括号里面的数字表示的是最大的显示的宽度&#x3D;&#x3D; bigint 较大的数据 8个字节 float 单精度浮点数 4个字节 &#x3D;&#x3D;double&#x3D;&#x3D; 双精度浮点数 8个字节 decimal 字符串的浮点数 （金融计算的时候一般使用这个类型） 字符串 char 字符串固定大小 0-255 &#x3D;&#x3D;varchar&#x3D;&#x3D; 字符串可变长度 0-65535（String） tinytext 微型文本 2^8-1 text 文本串 2^16-1(大文本) 时间和日期 date YYYY-MM-DD 日期 time HH:mm:ss 时间格式 &#x3D;&#x3D;datetime&#x3D;&#x3D; YYYY-MM-DD HH:mm:ss 最常用的时间格式 &#x3D;&#x3D;timestamp&#x3D;&#x3D; 时间戳 1970-1-1到现在的毫秒数 year 年份表示 null 没有值，未知，不要使用null进行运算，结果为null 2.3数据库的字段属性（重点） Unsigned 无符号证书整数 声明了该列不能为负数 Zerofill？ 0填充的 不足的位数，用0来进行填充 自增 通常理解为自增，自动在上一条记录的基础上加一 通常用来设置唯一的主键，必须是证书类型，可以自定义设置起始值 非空 Null notnull 假设设置为not null，如果不给他赋值，就会报错 null如果不填充，就是null 设置默认值 如果不指定该列的值，它会是默认的值 123456/*每一个表都必须存在以下五个字段,表示每个记录存在的意义*/id 主键`version` 乐观锁is_delete 伪删除gmt_create 创建时间gmt_update 修改时间 2.4创建数据库表123456789101112131415/*使用英文的括号后面要加，字符串使用单引号*/CREATE TABLE IF NOT EXISTS `student`(`id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,`name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,`pwd` VARCHAR(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;,`sex` VARCHAR(2) NOT NULL DEFAULT &#x27;女&#x27; COMMENT &#x27;性别&#x27;,`birthday` DATETIME DEFAULT NULL COMMENT &#x27;出生日期&#x27;,`address` VARCHAR(100) DEFAULT NULL COMMENT &#x27;家庭住址&#x27;,`email` VARCHAR(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,PRIMARY KEY(`id`))ENGINE=INNODB DEFAULT CHARSET=utf8 格式 123456CREATE TABLE [IF NOT EXISTS] `表名`(`字段名` 列类型 [属性] [索引][注释],`字段名` 列类型 [属性] [索引][注释],`字段名` 列类型 [属性] [索引][注释], ....)[表类型][字符集设置][注释] 123456-- 查看创建数据库school的语句SHOW CREATE DATABASE school;-- 查看创建表student的语句SHOW CREATE TABLE student;-- 查看表的基本结构DESC student; 2.5数据表的类型12345-- 关于数据库的引擎/*INNODB 默认使用MYISAM 早些年使用*/ MYISAM INNODB 事务支持 不支持 支持 数据行锁定 不支持 支持 外键约束 不支持 支持 全文索引 支持 不支持 较小 较大约为前者的两倍 常规的使用操作： MYISAM 节约空间，速度较快 INNODB 安全性高，支持事务的处理，多表多用户操作 在物理空间存在的位置 &#x3D;&#x3D;所有的数据库文件都存在data目录下&#x3D;&#x3D;一个文件夹就对应一个数据库 本质还是文件存储 MySQL引擎在物理文件上的区别： INNODB在数据库表中只有一个*.frm文件，以及上级目录下的ibdata文件 MYISAM对应文件 *.frm — 表结构的定义文件 *.MYD 数据文件（Data） *.MYI 索引文件 设置数据库字符集的编码 1234CHARSET=utf8-- 不设置的话是mysql的默认的字符集编码（不支持中文） 最好在创建表的时候去设置-- 1.创建表的时候就修改-- 2.在my.ini添加字符集 2.6修改和删除表 修改 12345678910111213141516-- 修改表--ALTER TABLE 旧的表名 RENAME `新的表名`;ALTER TABLE `teacher` RENAME `teacher1`;--ALTER TABLE `表名` ADD 字段 数据类型;ALTER TABLE `teacher1` ADD age INT(3);-- 修改表的字段 （重命名修改约束）-- 修改表的约束-- ALTER TABLE `表名` MODIFY 字段名字 类型;ALTER TABLE `teacher1` MODIFY age VARCHAR(11);-- 重命名表的字段的名字-- ALTER TABLE `表名` CHANGE 旧的字段名 新的字段名 新的字段名的类型;ALTER TABLE `teacher1` CHANGE age age1 INT(2);-- 删除表的字段ALTER TABLE `teacher1` DROP age1; 删除 &#x3D;&#x3D;注意： 所有的删除尽量加上是否存在，以免报错&#x3D;&#x3D; 123-- 删除表（如果表存在）--DROP TABLE IF EXISTS `表名`;DROP TABLE IF EXISTS `teacher1`; 注意点： &#x3D;&#x3D;&#96;&#96;的引用，所有的字段名使用这个符号&#x3D;&#x3D; &#x3D;&#x3D;注释是 – 或者是&#x2F;**&#x2F;&#x3D;&#x3D; &#x3D;&#x3D;sql关键字的大小写是不敏感的，建议写小写&#x3D;&#x3D; &#x3D;&#x3D;所有的符号全部用英文的&#x3D;&#x3D; 3.MySQL的数据管理3.1外键（了解即可） 方式一： 在创建表的时候给表添加约束 1234567891011121314151617181920212223-- 创建年级表CREATE TABLE `grade`(`gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;年级id&#x27;,`gradename` VARCHAR(50) NOT NULL COMMENT &#x27;年级名称&#x27;,PRIMARY KEY(`gradeid`))ENGINE=INNODB CHARSET=utf8-- 创建学生表-- 学生表的gradeid 要引用年级表的gradeid-- 1.定义外键-- 2.给这个外键添加约束CREATE TABLE IF NOT EXISTS `student`(`id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,`name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,`pwd` VARCHAR(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;,`sex` VARCHAR(2) NOT NULL DEFAULT &#x27;女&#x27; COMMENT &#x27;性别&#x27;,`birthday` DATETIME DEFAULT NULL COMMENT &#x27;出生日期&#x27;,`gradeid` INT(10) NOT NULL COMMENT &#x27;学生的年级&#x27;,`address` VARCHAR(100) DEFAULT NULL COMMENT &#x27;家庭住址&#x27;,`email` VARCHAR(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,PRIMARY KEY(`id`),KEY `FK_gradeid` (gradeid) ,CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade`(`gradeid`))ENGINE=INNODB DEFAULT CHARSET=utf8 &#x3D;&#x3D;删除表的时候，要删除引用的表（从表），之后再删除被引用的表（主表）&#x3D;&#x3D; 方式二： 创建表成功后添加外键约束 1234567891011121314151617181920212223242526-- 创建年级表CREATE TABLE `grade`(`gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;年级id&#x27;,`gradename` VARCHAR(50) NOT NULL COMMENT &#x27;年级名称&#x27;,PRIMARY KEY(`gradeid`))ENGINE=INNODB CHARSET=utf8-- 创建学生表-- 学生表的gradeid 要引用年级表的gradeid-- 1.定义外键-- 2.给这个外键添加约束CREATE TABLE IF NOT EXISTS `student`(`id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,`name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,`pwd` VARCHAR(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;,`sex` VARCHAR(2) NOT NULL DEFAULT &#x27;女&#x27; COMMENT &#x27;性别&#x27;,`birthday` DATETIME DEFAULT NULL COMMENT &#x27;出生日期&#x27;,`gradeid` INT(10) NOT NULL COMMENT &#x27;学生的年级&#x27;,`address` VARCHAR(100) DEFAULT NULL COMMENT &#x27;家庭住址&#x27;,`email` VARCHAR(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,PRIMARY KEY(`id`))ENGINE=INNODB DEFAULT CHARSET=utf8-- 创建表的时候没有外键的关系-- ALTER TABLE `表名` -- ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`作为外键的列`) REFERENCES `引用的表`(`引用的表的字段`);ALTER TABLE `student` ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade`(`gradeid`); &#x3D;&#x3D;注意： 以上的操作都物理外键，不建议使用（避免数据库过多造成困扰，这里了解即可）&#x3D;&#x3D; &#x3D;&#x3D;最佳实践： 数据库就是单存的表，只用来存储行和列，我们要使用外键，使用程序去解决&#x3D;&#x3D; &#x3D;&#x3D;在企业中有要求，不得使用外键，一切外键概念必须在应用层解决（在删除和更新的时候比较方便）&#x3D;&#x3D; 3.2DML语言（全部记住）数据库的意义: 数据存储和数据管理 DML 数据操作语言： insert update delete 3.3添加（insert）1234567891011121314-- 插入语句（添加） 如果不写表的字段，就会一一匹配-- INSERT INTO `表名`(`字段名`) VALUES(&#x27;值&#x27;);INSERT INTO `grade`(`gradename`) VALUES(&#x27;大二&#x27;);-- 一般写插入语句，一定要数据和字段一一对应INSERT INTO `grade`(`gradename`) VALUES(&#x27;大二&#x27;);-- 插入多个字段-- INSERT INTO `grade`(`gradename`) VALUES(&#x27;大三&#x27;),(&#x27;大四&#x27;);INSERT INTO `grade`(`gradename`) VALUES(&#x27;大三&#x27;),(&#x27;大四&#x27;);INSERT INTO `student`(`name`,`pwd`,`sex`) VALUES(&#x27;李四&#x27;,&#x27;aaaaaa&#x27;,&#x27;男&#x27;),(&#x27;王五&#x27;,&#x27;aaaaaa&#x27;,&#x27;男&#x27;),(&#x27;孙子&#x27;,&#x27;aaaaaa&#x27;,&#x27;男&#x27;); &#x3D;&#x3D;注意事项&#x3D;&#x3D; 1.字段和字段之间使用英文逗号隔开 2.字段可以省略，但是里面的值要一一对应 3.可以同时插入多条数据，values后面的值，需要使用逗号隔开 3.4修改（update）1234567-- 修改数据 修改谁 也就是条件-- 修改学院的名字-- 指定条件的修改UPDATE `student` SET `name`=&#x27;陈留红&#x27; WHERE id = 1;-- 不指定条件的修改UPDATE `student` SET `name`=&#x27;陈留红&#x27;;-- 修改多个属性的时候，一样需要使用逗号隔开 条件： where 子语句 运算符 id &#x3D; 某个值或者是其他的判断条件 操作符 含义 范围 结果 &#x3D; 等于 5&#x3D;6 false &lt;&gt;或者是！&#x3D; 不等于 5&lt;&gt;6 true &gt; &lt; &gt;&#x3D; &lt;&#x3D; between…and… 在某个范围内 [2,5] and 我和你 &amp;&amp; 5&gt;1 and 1&gt;2 false or 我或你 || 5&gt;1 or 1&gt;2 true 123-- 通过多个条件修改数据,没有上限SELECT * FROM student;UPDATE `student` SET `name`=&#x27;孙子&#x27; WHERE `name`=&#x27;陈留红&#x27; AND id=1; 注意事项： 列名不能随便写，尽量带上&#96;，条件是筛选的条件，如果没有指定，则会修改所有的列，value，是一个具体的值，也可以是一个变量，多个设置的属性使用英文隔开&#x3D;&#x3D;trim 把多余的符号干掉&#x3D;&#x3D; 123-- 通过多个条件修改数据,没有上限 设置变量值 ， 一般只有时间会用 SELECT * FROM student;UPDATE `student` SET `birthday`=CURRENT_TIME WHERE `name`=&#x27;孙子&#x27;; 3.5删除（delete）1234-- 删除全部的数据DELETE FROM `student`;-- 删除数据DELETE FROM `student` WHERE id=1; TRUNCATE 作用： 完全清空一个数据库表，表的结构和索引约束不会变 12-- 清空student表TRUNCATE `student`; DELETE和TRUNCATE的区别 相同点： 都能够删除数据，都不会删除表结构 不同点： TRUNCATE 重新设置 自增列 计数器会归零 TRUNCATE 不会影响事务 123456789101112131415-- 清空student表TRUNCATE `student`;-- 测试 DELETE 和TRUNCATE 的区别CREATE TABLE `test`(`id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,`name` VARCHAR(30) NOT NULL,PRIMARY KEY(`id`))ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `test`(`name`) VALUES(&#x27;zs&#x27;),(&#x27;ls&#x27;),(&#x27;ww&#x27;);DELETE FROM `test`; -- 不会影响自增TRUNCATE TABLE `test`; 了解即可： delete删除的问题，重启数据库，现象： INNODB 自增列会从1开始（存储在内存当中的，断电及失） MYISAM 继续从上一个自增量开始（存在文件之中，不会丢失） 4.DQL查询数据（最重点） select 语法 12345678910SELECT [ALL | DISTINCT]&#123;* | table.* | [table.field1[as alias1][,table.field2[as alias2]][,...]]&#125;FROM table_name [as table_alias]\t[left | right | inner join table_name] --联合查询\t[WHERE ...] -- 指定结果需满足条件\t[GROUP BY ...] -- 指定结果按照那几个字段来分组\t[HAVING ...] -- 过滤分组的条件满足的次要条件\t[ORDER BY ... ] -- 指定查询记录按一个或者是多个条件排序\t[LIMIT &#123;[offset,]row_count | row_countOFFSET offset&#125;];\t-- 指定查询的记录从那条开始至那条 4.1DQL（Data Query Language : 数据查询语言） 所有的查询操作都用select 简单的查询，复杂的查询都能做 &#x3D;&#x3D;数据库的核心语言，最终要的语句&#x3D;&#x3D; 使用频率最高的语句 测试数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/*SQLyog Ultimate v12.08 (64 bit)MySQL - 5.7.19 : Database - school**********************************************************************//*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=&#x27;&#x27;*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;CREATE DATABASE /*!32312 IF NOT EXISTS*/`school` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `school`;/*Table structure for table `grade` */DROP TABLE IF EXISTS `grade`;CREATE TABLE `grade` ( `GradeID` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;年级编号&#x27;, `GradeName` varchar(50) NOT NULL COMMENT &#x27;年级名称&#x27;, PRIMARY KEY (`GradeID`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;/*Data for the table `grade` */insert into `grade`(`GradeID`,`GradeName`) values (1,&#x27;大一&#x27;),(2,&#x27;大二&#x27;),(3,&#x27;大三&#x27;),(4,&#x27;大四&#x27;),(5,&#x27;预科班&#x27;);/*Table structure for table `result` */DROP TABLE IF EXISTS `result`;CREATE TABLE `result` ( `StudentNo` int(4) NOT NULL COMMENT &#x27;学号&#x27;, `SubjectNo` int(4) NOT NULL COMMENT &#x27;课程编号&#x27;, `ExamDate` datetime NOT NULL COMMENT &#x27;考试日期&#x27;, `StudentResult` int(4) NOT NULL COMMENT &#x27;考试成绩&#x27;, KEY `SubjectNo` (`SubjectNo`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;/*Data for the table `result` */insert into `result`(`StudentNo`,`SubjectNo`,`ExamDate`,`StudentResult`) values (1000,1,&#x27;2013-11-11 16:00:00&#x27;,94),(1000,2,&#x27;2012-11-10 10:00:00&#x27;,75),(1000,3,&#x27;2011-12-19 10:00:00&#x27;,76),(1000,4,&#x27;2010-11-18 11:00:00&#x27;,93),(1000,5,&#x27;2013-11-11 14:00:00&#x27;,97),(1000,6,&#x27;2012-09-13 15:00:00&#x27;,87),(1000,7,&#x27;2011-10-16 16:00:00&#x27;,79),(1000,8,&#x27;2010-11-11 16:00:00&#x27;,74),(1000,9,&#x27;2013-11-21 10:00:00&#x27;,69),(1000,10,&#x27;2012-11-11 12:00:00&#x27;,78),(1000,11,&#x27;2011-11-11 14:00:00&#x27;,66),(1000,12,&#x27;2010-11-11 15:00:00&#x27;,82),(1000,13,&#x27;2013-11-11 14:00:00&#x27;,94),(1000,14,&#x27;2012-11-11 15:00:00&#x27;,98),(1000,15,&#x27;2011-12-11 10:00:00&#x27;,70),(1000,16,&#x27;2010-09-11 10:00:00&#x27;,74),(1001,1,&#x27;2013-11-11 16:00:00&#x27;,76),(1001,2,&#x27;2012-11-10 10:00:00&#x27;,93),(1001,3,&#x27;2011-12-19 10:00:00&#x27;,65),(1001,4,&#x27;2010-11-18 11:00:00&#x27;,71),(1001,5,&#x27;2013-11-11 14:00:00&#x27;,98),(1001,6,&#x27;2012-09-13 15:00:00&#x27;,74),(1001,7,&#x27;2011-10-16 16:00:00&#x27;,85),(1001,8,&#x27;2010-11-11 16:00:00&#x27;,69),(1001,9,&#x27;2013-11-21 10:00:00&#x27;,63),(1001,10,&#x27;2012-11-11 12:00:00&#x27;,70),(1001,11,&#x27;2011-11-11 14:00:00&#x27;,62),(1001,12,&#x27;2010-11-11 15:00:00&#x27;,90),(1001,13,&#x27;2013-11-11 14:00:00&#x27;,97),(1001,14,&#x27;2012-11-11 15:00:00&#x27;,89),(1001,15,&#x27;2011-12-11 10:00:00&#x27;,72),(1001,16,&#x27;2010-09-11 10:00:00&#x27;,90),(1002,1,&#x27;2013-11-11 16:00:00&#x27;,61),(1002,2,&#x27;2012-11-10 10:00:00&#x27;,80),(1002,3,&#x27;2011-12-19 10:00:00&#x27;,89),(1002,4,&#x27;2010-11-18 11:00:00&#x27;,88),(1002,5,&#x27;2013-11-11 14:00:00&#x27;,82),(1002,6,&#x27;2012-09-13 15:00:00&#x27;,91),(1002,7,&#x27;2011-10-16 16:00:00&#x27;,63),(1002,8,&#x27;2010-11-11 16:00:00&#x27;,84),(1002,9,&#x27;2013-11-21 10:00:00&#x27;,60),(1002,10,&#x27;2012-11-11 12:00:00&#x27;,71),(1002,11,&#x27;2011-11-11 14:00:00&#x27;,93),(1002,12,&#x27;2010-11-11 15:00:00&#x27;,96),(1002,13,&#x27;2013-11-11 14:00:00&#x27;,83),(1002,14,&#x27;2012-11-11 15:00:00&#x27;,69),(1002,15,&#x27;2011-12-11 10:00:00&#x27;,89),(1002,16,&#x27;2010-09-11 10:00:00&#x27;,83),(1003,1,&#x27;2013-11-11 16:00:00&#x27;,91),(1003,2,&#x27;2012-11-10 10:00:00&#x27;,75),(1003,3,&#x27;2011-12-19 10:00:00&#x27;,65),(1003,4,&#x27;2010-11-18 11:00:00&#x27;,63),(1003,5,&#x27;2013-11-11 14:00:00&#x27;,90),(1003,6,&#x27;2012-09-13 15:00:00&#x27;,96),(1003,7,&#x27;2011-10-16 16:00:00&#x27;,97),(1003,8,&#x27;2010-11-11 16:00:00&#x27;,77),(1003,9,&#x27;2013-11-21 10:00:00&#x27;,62),(1003,10,&#x27;2012-11-11 12:00:00&#x27;,81),(1003,11,&#x27;2011-11-11 14:00:00&#x27;,76),(1003,12,&#x27;2010-11-11 15:00:00&#x27;,61),(1003,13,&#x27;2013-11-11 14:00:00&#x27;,93),(1003,14,&#x27;2012-11-11 15:00:00&#x27;,79),(1003,15,&#x27;2011-12-11 10:00:00&#x27;,78),(1003,16,&#x27;2010-09-11 10:00:00&#x27;,96),(1004,1,&#x27;2013-11-11 16:00:00&#x27;,84),(1004,2,&#x27;2012-11-10 10:00:00&#x27;,79),(1004,3,&#x27;2011-12-19 10:00:00&#x27;,76),(1004,4,&#x27;2010-11-18 11:00:00&#x27;,78),(1004,5,&#x27;2013-11-11 14:00:00&#x27;,81),(1004,6,&#x27;2012-09-13 15:00:00&#x27;,90),(1004,7,&#x27;2011-10-16 16:00:00&#x27;,63),(1004,8,&#x27;2010-11-11 16:00:00&#x27;,89),(1004,9,&#x27;2013-11-21 10:00:00&#x27;,67),(1004,10,&#x27;2012-11-11 12:00:00&#x27;,100),(1004,11,&#x27;2011-11-11 14:00:00&#x27;,94),(1004,12,&#x27;2010-11-11 15:00:00&#x27;,65),(1004,13,&#x27;2013-11-11 14:00:00&#x27;,86),(1004,14,&#x27;2012-11-11 15:00:00&#x27;,77),(1004,15,&#x27;2011-12-11 10:00:00&#x27;,82),(1004,16,&#x27;2010-09-11 10:00:00&#x27;,87),(1005,1,&#x27;2013-11-11 16:00:00&#x27;,82),(1005,2,&#x27;2012-11-10 10:00:00&#x27;,92),(1005,3,&#x27;2011-12-19 10:00:00&#x27;,80),(1005,4,&#x27;2010-11-18 11:00:00&#x27;,92),(1005,5,&#x27;2013-11-11 14:00:00&#x27;,97),(1005,6,&#x27;2012-09-13 15:00:00&#x27;,72),(1005,7,&#x27;2011-10-16 16:00:00&#x27;,84),(1005,8,&#x27;2010-11-11 16:00:00&#x27;,79),(1005,9,&#x27;2013-11-21 10:00:00&#x27;,76),(1005,10,&#x27;2012-11-11 12:00:00&#x27;,87),(1005,11,&#x27;2011-11-11 14:00:00&#x27;,65),(1005,12,&#x27;2010-11-11 15:00:00&#x27;,67),(1005,13,&#x27;2013-11-11 14:00:00&#x27;,63),(1005,14,&#x27;2012-11-11 15:00:00&#x27;,64),(1005,15,&#x27;2011-12-11 10:00:00&#x27;,99),(1005,16,&#x27;2010-09-11 10:00:00&#x27;,97),(1006,1,&#x27;2013-11-11 16:00:00&#x27;,82),(1006,2,&#x27;2012-11-10 10:00:00&#x27;,73),(1006,3,&#x27;2011-12-19 10:00:00&#x27;,79),(1006,4,&#x27;2010-11-18 11:00:00&#x27;,63),(1006,5,&#x27;2013-11-11 14:00:00&#x27;,97),(1006,6,&#x27;2012-09-13 15:00:00&#x27;,83),(1006,7,&#x27;2011-10-16 16:00:00&#x27;,78),(1006,8,&#x27;2010-11-11 16:00:00&#x27;,88),(1006,9,&#x27;2013-11-21 10:00:00&#x27;,89),(1006,10,&#x27;2012-11-11 12:00:00&#x27;,82),(1006,11,&#x27;2011-11-11 14:00:00&#x27;,70),(1006,12,&#x27;2010-11-11 15:00:00&#x27;,69),(1006,13,&#x27;2013-11-11 14:00:00&#x27;,64),(1006,14,&#x27;2012-11-11 15:00:00&#x27;,80),(1006,15,&#x27;2011-12-11 10:00:00&#x27;,90),(1006,16,&#x27;2010-09-11 10:00:00&#x27;,85),(1007,1,&#x27;2013-11-11 16:00:00&#x27;,87),(1007,2,&#x27;2012-11-10 10:00:00&#x27;,63),(1007,3,&#x27;2011-12-19 10:00:00&#x27;,70),(1007,4,&#x27;2010-11-18 11:00:00&#x27;,74),(1007,5,&#x27;2013-11-11 14:00:00&#x27;,79),(1007,6,&#x27;2012-09-13 15:00:00&#x27;,83),(1007,7,&#x27;2011-10-16 16:00:00&#x27;,86),(1007,8,&#x27;2010-11-11 16:00:00&#x27;,76),(1007,9,&#x27;2013-11-21 10:00:00&#x27;,65),(1007,10,&#x27;2012-11-11 12:00:00&#x27;,87),(1007,11,&#x27;2011-11-11 14:00:00&#x27;,69),(1007,12,&#x27;2010-11-11 15:00:00&#x27;,69),(1007,13,&#x27;2013-11-11 14:00:00&#x27;,90),(1007,14,&#x27;2012-11-11 15:00:00&#x27;,84),(1007,15,&#x27;2011-12-11 10:00:00&#x27;,95),(1007,16,&#x27;2010-09-11 10:00:00&#x27;,92),(1008,1,&#x27;2013-11-11 16:00:00&#x27;,96),(1008,2,&#x27;2012-11-10 10:00:00&#x27;,62),(1008,3,&#x27;2011-12-19 10:00:00&#x27;,97),(1008,4,&#x27;2010-11-18 11:00:00&#x27;,84),(1008,5,&#x27;2013-11-11 14:00:00&#x27;,86),(1008,6,&#x27;2012-09-13 15:00:00&#x27;,72),(1008,7,&#x27;2011-10-16 16:00:00&#x27;,67),(1008,8,&#x27;2010-11-11 16:00:00&#x27;,83),(1008,9,&#x27;2013-11-21 10:00:00&#x27;,86),(1008,10,&#x27;2012-11-11 12:00:00&#x27;,60),(1008,11,&#x27;2011-11-11 14:00:00&#x27;,61),(1008,12,&#x27;2010-11-11 15:00:00&#x27;,68),(1008,13,&#x27;2013-11-11 14:00:00&#x27;,99),(1008,14,&#x27;2012-11-11 15:00:00&#x27;,77),(1008,15,&#x27;2011-12-11 10:00:00&#x27;,73),(1008,16,&#x27;2010-09-11 10:00:00&#x27;,78),(1009,1,&#x27;2013-11-11 16:00:00&#x27;,67),(1009,2,&#x27;2012-11-10 10:00:00&#x27;,70),(1009,3,&#x27;2011-12-19 10:00:00&#x27;,75),(1009,4,&#x27;2010-11-18 11:00:00&#x27;,92),(1009,5,&#x27;2013-11-11 14:00:00&#x27;,76),(1009,6,&#x27;2012-09-13 15:00:00&#x27;,90),(1009,7,&#x27;2011-10-16 16:00:00&#x27;,62),(1009,8,&#x27;2010-11-11 16:00:00&#x27;,68),(1009,9,&#x27;2013-11-21 10:00:00&#x27;,70),(1009,10,&#x27;2012-11-11 12:00:00&#x27;,83),(1009,11,&#x27;2011-11-11 14:00:00&#x27;,88),(1009,12,&#x27;2010-11-11 15:00:00&#x27;,65),(1009,13,&#x27;2013-11-11 14:00:00&#x27;,91),(1009,14,&#x27;2012-11-11 15:00:00&#x27;,99),(1009,15,&#x27;2011-12-11 10:00:00&#x27;,65),(1009,16,&#x27;2010-09-11 10:00:00&#x27;,83),(1010,1,&#x27;2013-11-11 16:00:00&#x27;,83),(1010,2,&#x27;2012-11-10 10:00:00&#x27;,87),(1010,3,&#x27;2011-12-19 10:00:00&#x27;,89),(1010,4,&#x27;2010-11-18 11:00:00&#x27;,99),(1010,5,&#x27;2013-11-11 14:00:00&#x27;,91),(1010,6,&#x27;2012-09-13 15:00:00&#x27;,96),(1010,7,&#x27;2011-10-16 16:00:00&#x27;,72),(1010,8,&#x27;2010-11-11 16:00:00&#x27;,72),(1010,9,&#x27;2013-11-21 10:00:00&#x27;,98),(1010,10,&#x27;2012-11-11 12:00:00&#x27;,73),(1010,11,&#x27;2011-11-11 14:00:00&#x27;,68),(1010,12,&#x27;2010-11-11 15:00:00&#x27;,62),(1010,13,&#x27;2013-11-11 14:00:00&#x27;,67),(1010,14,&#x27;2012-11-11 15:00:00&#x27;,69),(1010,15,&#x27;2011-12-11 10:00:00&#x27;,71),(1010,16,&#x27;2010-09-11 10:00:00&#x27;,66),(1011,1,&#x27;2013-11-11 16:00:00&#x27;,62),(1011,2,&#x27;2012-11-10 10:00:00&#x27;,72),(1011,3,&#x27;2011-12-19 10:00:00&#x27;,96),(1011,4,&#x27;2010-11-18 11:00:00&#x27;,64),(1011,5,&#x27;2013-11-11 14:00:00&#x27;,89),(1011,6,&#x27;2012-09-13 15:00:00&#x27;,91),(1011,7,&#x27;2011-10-16 16:00:00&#x27;,95),(1011,8,&#x27;2010-11-11 16:00:00&#x27;,96),(1011,9,&#x27;2013-11-21 10:00:00&#x27;,89),(1011,10,&#x27;2012-11-11 12:00:00&#x27;,73),(1011,11,&#x27;2011-11-11 14:00:00&#x27;,82),(1011,12,&#x27;2010-11-11 15:00:00&#x27;,98),(1011,13,&#x27;2013-11-11 14:00:00&#x27;,66),(1011,14,&#x27;2012-11-11 15:00:00&#x27;,69),(1011,15,&#x27;2011-12-11 10:00:00&#x27;,91),(1011,16,&#x27;2010-09-11 10:00:00&#x27;,69),(1012,1,&#x27;2013-11-11 16:00:00&#x27;,86),(1012,2,&#x27;2012-11-10 10:00:00&#x27;,66),(1012,3,&#x27;2011-12-19 10:00:00&#x27;,97),(1012,4,&#x27;2010-11-18 11:00:00&#x27;,69),(1012,5,&#x27;2013-11-11 14:00:00&#x27;,70),(1012,6,&#x27;2012-09-13 15:00:00&#x27;,74),(1012,7,&#x27;2011-10-16 16:00:00&#x27;,91),(1012,8,&#x27;2010-11-11 16:00:00&#x27;,97),(1012,9,&#x27;2013-11-21 10:00:00&#x27;,84),(1012,10,&#x27;2012-11-11 12:00:00&#x27;,82),(1012,11,&#x27;2011-11-11 14:00:00&#x27;,90),(1012,12,&#x27;2010-11-11 15:00:00&#x27;,91),(1012,13,&#x27;2013-11-11 14:00:00&#x27;,91),(1012,14,&#x27;2012-11-11 15:00:00&#x27;,97),(1012,15,&#x27;2011-12-11 10:00:00&#x27;,85),(1012,16,&#x27;2010-09-11 10:00:00&#x27;,90),(1013,1,&#x27;2013-11-11 16:00:00&#x27;,73),(1013,2,&#x27;2012-11-10 10:00:00&#x27;,69),(1013,3,&#x27;2011-12-19 10:00:00&#x27;,91),(1013,4,&#x27;2010-11-18 11:00:00&#x27;,72),(1013,5,&#x27;2013-11-11 14:00:00&#x27;,76),(1013,6,&#x27;2012-09-13 15:00:00&#x27;,87),(1013,7,&#x27;2011-10-16 16:00:00&#x27;,61),(1013,8,&#x27;2010-11-11 16:00:00&#x27;,77),(1013,9,&#x27;2013-11-21 10:00:00&#x27;,83),(1013,10,&#x27;2012-11-11 12:00:00&#x27;,99),(1013,11,&#x27;2011-11-11 14:00:00&#x27;,91),(1013,12,&#x27;2010-11-11 15:00:00&#x27;,84),(1013,13,&#x27;2013-11-11 14:00:00&#x27;,98),(1013,14,&#x27;2012-11-11 15:00:00&#x27;,74),(1013,15,&#x27;2011-12-11 10:00:00&#x27;,92),(1013,16,&#x27;2010-09-11 10:00:00&#x27;,90),(1014,1,&#x27;2013-11-11 16:00:00&#x27;,64),(1014,2,&#x27;2012-11-10 10:00:00&#x27;,81),(1014,3,&#x27;2011-12-19 10:00:00&#x27;,79),(1014,4,&#x27;2010-11-18 11:00:00&#x27;,74),(1014,5,&#x27;2013-11-11 14:00:00&#x27;,65),(1014,6,&#x27;2012-09-13 15:00:00&#x27;,88),(1014,7,&#x27;2011-10-16 16:00:00&#x27;,86),(1014,8,&#x27;2010-11-11 16:00:00&#x27;,77),(1014,9,&#x27;2013-11-21 10:00:00&#x27;,86),(1014,10,&#x27;2012-11-11 12:00:00&#x27;,85),(1014,11,&#x27;2011-11-11 14:00:00&#x27;,86),(1014,12,&#x27;2010-11-11 15:00:00&#x27;,75),(1014,13,&#x27;2013-11-11 14:00:00&#x27;,89),(1014,14,&#x27;2012-11-11 15:00:00&#x27;,79),(1014,15,&#x27;2011-12-11 10:00:00&#x27;,73),(1014,16,&#x27;2010-09-11 10:00:00&#x27;,68),(1015,1,&#x27;2013-11-11 16:00:00&#x27;,99),(1015,2,&#x27;2012-11-10 10:00:00&#x27;,60),(1015,3,&#x27;2011-12-19 10:00:00&#x27;,60),(1015,4,&#x27;2010-11-18 11:00:00&#x27;,75),(1015,5,&#x27;2013-11-11 14:00:00&#x27;,78),(1015,6,&#x27;2012-09-13 15:00:00&#x27;,78),(1015,7,&#x27;2011-10-16 16:00:00&#x27;,84),(1015,8,&#x27;2010-11-11 16:00:00&#x27;,95),(1015,9,&#x27;2013-11-21 10:00:00&#x27;,93),(1015,10,&#x27;2012-11-11 12:00:00&#x27;,79),(1015,11,&#x27;2011-11-11 14:00:00&#x27;,74),(1015,12,&#x27;2010-11-11 15:00:00&#x27;,65),(1015,13,&#x27;2013-11-11 14:00:00&#x27;,63),(1015,14,&#x27;2012-11-11 15:00:00&#x27;,74),(1015,15,&#x27;2011-12-11 10:00:00&#x27;,67),(1015,16,&#x27;2010-09-11 10:00:00&#x27;,65),(1016,1,&#x27;2013-11-11 16:00:00&#x27;,97),(1016,2,&#x27;2012-11-10 10:00:00&#x27;,90),(1016,3,&#x27;2011-12-19 10:00:00&#x27;,77),(1016,4,&#x27;2010-11-18 11:00:00&#x27;,75),(1016,5,&#x27;2013-11-11 14:00:00&#x27;,75),(1016,6,&#x27;2012-09-13 15:00:00&#x27;,97),(1016,7,&#x27;2011-10-16 16:00:00&#x27;,96),(1016,8,&#x27;2010-11-11 16:00:00&#x27;,92),(1016,9,&#x27;2013-11-21 10:00:00&#x27;,62),(1016,10,&#x27;2012-11-11 12:00:00&#x27;,83),(1016,11,&#x27;2011-11-11 14:00:00&#x27;,98),(1016,12,&#x27;2010-11-11 15:00:00&#x27;,94),(1016,13,&#x27;2013-11-11 14:00:00&#x27;,62),(1016,14,&#x27;2012-11-11 15:00:00&#x27;,97),(1016,15,&#x27;2011-12-11 10:00:00&#x27;,76),(1016,16,&#x27;2010-09-11 10:00:00&#x27;,82),(1017,1,&#x27;2013-11-11 16:00:00&#x27;,100),(1017,2,&#x27;2012-11-10 10:00:00&#x27;,88),(1017,3,&#x27;2011-12-19 10:00:00&#x27;,86),(1017,4,&#x27;2010-11-18 11:00:00&#x27;,73),(1017,5,&#x27;2013-11-11 14:00:00&#x27;,96),(1017,6,&#x27;2012-09-13 15:00:00&#x27;,64),(1017,7,&#x27;2011-10-16 16:00:00&#x27;,81),(1017,8,&#x27;2010-11-11 16:00:00&#x27;,66),(1017,9,&#x27;2013-11-21 10:00:00&#x27;,76),(1017,10,&#x27;2012-11-11 12:00:00&#x27;,95),(1017,11,&#x27;2011-11-11 14:00:00&#x27;,73),(1017,12,&#x27;2010-11-11 15:00:00&#x27;,82),(1017,13,&#x27;2013-11-11 14:00:00&#x27;,85),(1017,14,&#x27;2012-11-11 15:00:00&#x27;,68),(1017,15,&#x27;2011-12-11 10:00:00&#x27;,99),(1017,16,&#x27;2010-09-11 10:00:00&#x27;,76);/*Table structure for table `student` */DROP TABLE IF EXISTS `student`;CREATE TABLE `student` ( `StudentNo` int(4) NOT NULL COMMENT &#x27;学号&#x27;, `LoginPwd` varchar(20) DEFAULT NULL, `StudentName` varchar(20) DEFAULT NULL COMMENT &#x27;学生姓名&#x27;, `Sex` tinyint(1) DEFAULT NULL COMMENT &#x27;性别，取值0或1&#x27;, `GradeId` int(11) DEFAULT NULL COMMENT &#x27;年级编号&#x27;, `Phone` varchar(50) NOT NULL COMMENT &#x27;联系电话，允许为空，即可选输入&#x27;, `Address` varchar(255) NOT NULL COMMENT &#x27;地址，允许为空，即可选输入&#x27;, `BornDate` datetime DEFAULT NULL COMMENT &#x27;出生时间&#x27;, `Email` varchar(50) NOT NULL COMMENT &#x27;邮箱账号，允许为空，即可选输入&#x27;, `IdentityCard` varchar(18) DEFAULT NULL COMMENT &#x27;身份证号&#x27;, PRIMARY KEY (`StudentNo`), UNIQUE KEY `IdentityCard` (`IdentityCard`), KEY `Email` (`Email`)) ENGINE=MyISAM DEFAULT CHARSET=utf8;/*Data for the table `student` */insert into `student`(`StudentNo`,`LoginPwd`,`StudentName`,`Sex`,`GradeId`,`Phone`,`Address`,`BornDate`,`Email`,`IdentityCard`) values (1000,&#x27;111111&#x27;,&#x27;周丹&#x27;,1,1,&#x27;13500000001&#x27;,&#x27;北京海淀区中关村大街1号&#x27;,&#x27;1986-12-11 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198612111234&#x27;),(1001,&#x27;123456&#x27;,&#x27;周颖&#x27;,1,2,&#x27;13500000002&#x27;,&#x27;河南洛阳&#x27;,&#x27;1981-12-31 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198112311234&#x27;),(1002,&#x27;111111&#x27;,&#x27;杨文瑞&#x27;,1,1,&#x27;13500000003&#x27;,&#x27;天津市和平区&#x27;,&#x27;1986-11-30 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198611301234&#x27;),(1003,&#x27;123456&#x27;,&#x27;韩萌&#x27;,1,3,&#x27;13500000004&#x27;,&#x27;上海卢湾区&#x27;,&#x27;1986-12-31 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198612314234&#x27;),(1004,&#x27;123456&#x27;,&#x27;刘丽侠&#x27;,1,4,&#x27;13500000005&#x27;,&#x27;北京市通州&#x27;,&#x27;1989-12-31 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198612311244&#x27;),(1005,&#x27;123456&#x27;,&#x27;姜嘉航&#x27;,2,1,&#x27;13500000006&#x27;,&#x27;广西桂林市灵川&#x27;,&#x27;1986-12-31 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198612311214&#x27;),(1006,&#x27;123456&#x27;,&#x27;郑嘉祥&#x27;,2,4,&#x27;13500000007&#x27;,&#x27;地址不详&#x27;,&#x27;1986-12-31 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198612311134&#x27;),(1007,&#x27;111111&#x27;,&#x27;刘洋&#x27;,1,1,&#x27;13500000008&#x27;,&#x27;北京东城区&#x27;,&#x27;1986-12-31 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198612311133&#x27;),(1008,&#x27;111111&#x27;,&#x27;刘洋洋&#x27;,1,1,&#x27;13500000009&#x27;,&#x27;河南洛阳&#x27;,&#x27;1986-12-31 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198612311221&#x27;),(1009,&#x27;123456&#x27;,&#x27;刘毅&#x27;,1,2,&#x27;13500000011&#x27;,&#x27;安徽&#x27;,&#x27;1986-12-31 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198612311231&#x27;),(1010,&#x27;111111&#x27;,&#x27;赵杰&#x27;,1,1,&#x27;13500000012&#x27;,&#x27;河南洛阳&#x27;,&#x27;1986-12-31 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198612311044&#x27;),(1011,&#x27;111111&#x27;,&#x27;赵成&#x27;,1,1,&#x27;13500000013&#x27;,&#x27;北京海淀区中关村大街*号&#x27;,&#x27;1984-12-31 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198412311234&#x27;),(1012,&#x27;123456&#x27;,&#x27;刘恒&#x27;,2,3,&#x27;13500000014&#x27;,&#x27;广西南宁中央大街&#x27;,&#x27;1986-12-31 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198612311334&#x27;),(1013,&#x27;123456&#x27;,&#x27;张伟奇&#x27;,2,1,&#x27;13500000015&#x27;,&#x27;上海卢湾区&#x27;,&#x27;1986-12-31 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198612311534&#x27;),(1014,&#x27;123456&#x27;,&#x27;牛恩来&#x27;,2,4,&#x27;13500000016&#x27;,&#x27;北京海淀区中关村大街*号&#x27;,&#x27;1986-12-31 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198612311264&#x27;),(1015,&#x27;123456&#x27;,&#x27;马辉&#x27;,1,4,&#x27;13500000017&#x27;,&#x27;广西桂林市灵川&#x27;,&#x27;1976-12-31 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323197612311234&#x27;),(1016,&#x27;111111&#x27;,&#x27;陈勉&#x27;,1,1,&#x27;13500000018&#x27;,&#x27;上海卢湾区&#x27;,&#x27;1986-12-31 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198612311251&#x27;),(1017,&#x27;123456&#x27;,&#x27;赵宇航&#x27;,2,3,&#x27;13500000019&#x27;,&#x27;北京长安街1号&#x27;,&#x27;1981-09-10 00:00:00&#x27;,&#x27;test1@qq.com&#x27;,&#x27;450323198109108311&#x27;);/*Table structure for table `subject` */DROP TABLE IF EXISTS `subject`;CREATE TABLE `subject` ( `SubjectNo` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;课程编号&#x27;, `SubjectName` varchar(50) DEFAULT NULL COMMENT &#x27;课程名称&#x27;, `ClassHour` int(4) DEFAULT NULL COMMENT &#x27;学时&#x27;, `GradeID` int(4) DEFAULT NULL COMMENT &#x27;年级编号&#x27;, PRIMARY KEY (`SubjectNo`)) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8;/*Data for the table `subject` */insert into `subject`(`SubjectNo`,`SubjectName`,`ClassHour`,`GradeID`) values (1,&#x27;高等数学-1&#x27;,110,1),(2,&#x27;高等数学-2&#x27;,110,2),(3,&#x27;高等数学-3&#x27;,100,3),(4,&#x27;高等数学-4&#x27;,130,4),(5,&#x27;C语言-1&#x27;,110,1),(6,&#x27;C语言-2&#x27;,110,2),(7,&#x27;C语言-3&#x27;,100,3),(8,&#x27;C语言-4&#x27;,130,4),(9,&#x27;JAVA第一学年&#x27;,110,1),(10,&#x27;JAVA第二学年&#x27;,110,2),(11,&#x27;JAVA第三学年&#x27;,100,3),(12,&#x27;JAVA第四学年&#x27;,130,4),(13,&#x27;数据库结构-1&#x27;,110,1),(14,&#x27;数据库结构-2&#x27;,110,2),(15,&#x27;数据库结构-3&#x27;,100,3),(16,&#x27;数据库结构-4&#x27;,130,4),(17,&#x27;C#基础&#x27;,130,1);/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; 4.2 指定查询字段12345678910111213-- 查询指定字段-- 查询全部的学生SELECT * FROM `student`;-- 查询全部的成绩SELECT * FROM `result`;-- 查询指定字段SELECT `StudentNo`,`StudentName` FROM `student`;-- 别名 ， 给结果起一个名字 AS 可以给字段起别名，也可以给表起别名SELECT `StudentNo` AS &#x27;学号&#x27;,`StudentName` AS &#x27;学员姓名&#x27; FROM `student` AS s;-- 函数 Concat（a,b）SELECT CONCAT(&#x27;姓名：&#x27;,`studentname`) AS 新名字 FROM student; 语法：select 字段 ... from 表 &#x3D;&#x3D;注意： 有的时候，列的名字不是见名知意，可以起别名来进行&#x3D;&#x3D; 12345678-- 去重复 distinct-- 查询有哪些同学参加了考试SELECT * FROM `result`; -- 查询全部的成绩-- 查询哪些同学参加了考试SELECT `studentno` FROM result;-- 发现重复数据，我们可以去重SELECT DISTINCT `studentno` FROM `result`; 数据库的列： 12345678-- 查看系统的版本（函数）SELECT VERSION();SELECT 100*3-1 AS 计算结果 -- 用来计算（计算表达式）SELECT @@auto_increment_increment; -- 查询自增的步长（变量）-- 学院考试成绩加一分查看SELECT `StudentNo`,`StudentResult`+1 AS &#x27;提分后&#x27; FROM `result`; &#x3D;&#x3D;数据库中的表达式： 文本的值，列，Null，函数，计算表达式，系统变量&#x3D;&#x3D; select 表达式 from 表 4.3where条件子句作用： 检索数据中符合条件的值 逻辑运算符 搜索的条件由一个或者是多个表达式组成! 结果为布尔值 运算符 语法 描述 and &amp;&amp; a and b a&amp;&amp;b 逻辑与，两个都为真，结果为真 or || a or b a||b 逻辑或，两个都为假，结果为假 Not ! not a !a 逻辑非，真为假，假为真 &#x3D;&#x3D;尽量使用英文符号&#x3D;&#x3D; 1234567891011121314-- =========where=============SELECT `studentno`,`studentresult` FROM `result`;-- 查询成绩在95 到 100 分之间的学生SELECT `studentno`,`studentresult` FROM `result`WHERE `studentresult`&gt;95 AND `studentresult`&lt;100;-- 模糊查询（区间范围）SELECT `studentno`,`studentresult` FROM `result`WHERE `studentresult` BETWEEN 95 AND 100;-- 除了1000号学生之外的信息SELECT `studentno`,`studentresult` FROM `result`WHERE `studentno` != 1000; -- not `studentno`=1000 模糊查询： 本质是比较运算符 运算符 语法 描述 IS NULL a is null 如果操作符为null，则结果为真 IS NOT NULL a is not null 如果操作符为null，则结果为假 BETWEEN A BETWEEN B AND C 若a在b和c之间，则结果为真 Like a like b 如果a 能匹配到b，则结果为真 in a in (a1,a2,a3,…) 如果a在a1和。。。中的一个，那么就为真 小红like红 1234567891011121314151617181920212223242526272829303132333435363738394041-- =============模糊查询=================-- 查询名字姓刘的同学-- like结合%（代表0到任意个字符） ——（一个字符）SELECT `studentno`,`studentname` FROM `student`WHERE `studentname` LIKE &#x27;刘%&#x27;;-- 查询名字姓刘的同学,名字后面只有一个字的SELECT `studentno`,`studentname` FROM `student`WHERE `studentname` LIKE &#x27;刘_&#x27;;-- 查询名字姓刘的同学,名字后面只有两个字的SELECT `studentno`,`studentname` FROM `student`WHERE `studentname` LIKE &#x27;刘__&#x27;;-- 查询名字中间有嘉字的同学_%嘉%_SELECT `studentno`,`studentname` FROM `student`WHERE `studentname` LIKE &#x27;_%嘉%_&#x27;;-- ================in==============-- 查询1001,1002,1003的学生SELECT `studentno`,`studentname` FROM `student`WHERE `studentno` IN (1001,1002,1003);-- 查询在安徽的学生 in 是具体的一个或者是多个值SELECT `studentno`,`studentname` FROM `student`WHERE `address` IN (&#x27;安徽&#x27;,&#x27;河南&#x27;,&#x27;洛阳&#x27;);-- ==========null 和 not null================-- 插叙地址为null &#x27;&#x27;的同学SELECT `studentno`,`studentname` FROM `student`WHERE `address`=&#x27;&#x27; OR `address` IS NULL;-- 查询有出生日期的同学SELECT `studentno`,`studentname` FROM `student`WHERE `BornDate` IS NOT NULL;-- 查询没有出生日期的同学SELECT `studentno`,`studentname` FROM `student`WHERE `BornDate` IS NULL; &#x3D;&#x3D;注意： 在是不是null 的时候要用is，不是等于&#x3D;&#x3D; 4.4联表查询 JOIN对比 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364-- ============联表查询Join=================-- 查询参加考试的同学（学号，姓名，科目编号，分数）/*分析需求： 分析需求的字段来自那些表确定使用哪种连接查询确定一个交叉点（这两个表中那个数据是相同的）判断的条件： 学生表中的`studentno` == 成绩表中的 `studentno`*/-- join（连接的表） on（判断的条件） 连接查询-- where 等值查询-- inner join as 可以省略SELECT s.`studentno`,`studentname`,`subjectno`,`studentresult` FROM student AS `s`INNER JOIN result AS `r`WHERE r.`StudentNo`=s.`StudentNo`;-- right joinSELECT `s`.`studentno`,`s`.`studentname`,`r`.`subjectno`,`r`.`studentresult` FROM student AS `s`RIGHT JOIN result AS `r`-- WHERE r.`StudentNo`=s.`StudentNo`;ON `r`.`StudentNo`=`s`.`StudentNo`;-- left joinSELECT `s`.`studentno`,`s`.`studentname`,`r`.`subjectno`,`r`.`studentresult` FROM student AS `s`LEFT JOIN result AS `r`-- WHERE r.`StudentNo`=s.`StudentNo`;ON `r`.`StudentNo`=`s`.`StudentNo`;-- 查询缺考的同学SELECT `s`.`studentno`,`s`.`studentname`,`r`.`subjectno`,`r`.`studentresult` FROM student AS `s`LEFT JOIN result AS `r`-- WHERE r.`StudentNo`=s.`StudentNo`;ON `r`.`StudentNo`=`s`.`StudentNo`WHERE `r`.`studentresult` IS NULL;-- 查询了参加了考试的同学的信息（学号，姓名，科目名称，分数）/*分析需求： 分析需求的字段来自那些表 student result subject确定使用哪种连接查询确定一个交叉点（这两个表中那个数据是相同的）判断的条件： 学生表中的`studentno` == 成绩表中的 `studentno`*/SELECT `s`.`studentno` AS &#x27;学号&#x27;,`studentname` AS &#x27;姓名&#x27;,`subjectname` AS &#x27;科目名称&#x27;,`studentresult` AS &#x27;成绩&#x27;FROM `student` AS `s` RIGHT JOIN `result` AS `r`ON `s`.`studentno` = `r`.`studentno`INNER JOIN `subject` AS `sub`ON `sub`.`subjectno` = `r`.`subjectno`;-- 我要查那些数据 select ....-- 从那几个表中查询 from 表 xxxx join 连接的表 on 交叉的条件-- 假设存在多张表查询，慢慢来，先查询两张表，然后再慢慢查询-- from a left join b-- from a right join b 操作 描述 inner join 如果表中至少有一个匹配，就返回行 left join 即使右表中没有匹配，也会从左表中返回所有的值 right join 会从右表中返回所有的值，即使左表中没有匹配 自连接 &#x3D;&#x3D;自己的表和自己的表连接， 核心： 一张表拆为两张一样的表即可&#x3D;&#x3D; 父类： categoryid categoryname 2 信息技术 3 软件开发 5 美术设计 子类 pid categoryid categoryname 3 4 数据库 2 8 办公信息 3 6 web开发 5 7 美术设计 操作： 查询父类对用子类关系 父类 子类 信息技术 办公信息 软件开发 数据库 软件开发 web开发 美术设计 ps技术 1234567891011121314151617181920212223-- =============自连接====================CREATE TABLE `category`(`categoryid` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;主题id&#x27;,`pid` INT(10) NOT NULL COMMENT &#x27;父id&#x27;,`categoryname` VARCHAR(50) NOT NULL COMMENT &#x27;主题名字&#x27;,PRIMARY KEY(`categoryid`))ENGINE=INNODB AUTO_INCREMENT=9 CHARSET=utf8INSERT INTO `category` (`categoryid`,`pid`,`categoryname`)VALUES(&#x27;2&#x27;,&#x27;1&#x27;,&#x27;信息技术&#x27;),(&#x27;3&#x27;,&#x27;1&#x27;,&#x27;软件开发&#x27;),(&#x27;4&#x27;,&#x27;3&#x27;,&#x27;数据库&#x27;),(&#x27;5&#x27;,&#x27;1&#x27;,&#x27;美术设计&#x27;),(&#x27;6&#x27;,&#x27;3&#x27;,&#x27;web开发&#x27;),(&#x27;7&#x27;,&#x27;5&#x27;,&#x27;ps技术&#x27;),(&#x27;8&#x27;,&#x27;2&#x27;,&#x27;办公信息&#x27;);-- 查询父子信息 把一张表拆成两张一样的表SELECT `a`.`categoryname` AS &#x27;父栏目&#x27;,`b`.`categoryname` AS &#x27;子栏目&#x27;FROM `category` AS `a` , `category` AS `b`WHERE `a`.`categoryid` = `b`.`pid`; 4.5分页和排序 排序 1234567891011-- =================分页和排序 order by===================-- 排序 ： 升序ASC 和降序 DESC-- order by 通过那个字段进行排序，怎么拍 -- 查询了参加了数据库结构-1考试的同学的信息（学号，姓名，科目名称，分数） 根据成绩排序SELECT `s`.`studentno`,`studentname`,`subjectname`,`studentresult`FROM `student` AS `s` INNER JOIN `result` AS `r`ON `s`.`studentno` = `r`.`studentno`INNER JOIN `subject` AS `sub`ON `r`.`subjectno` = `sub`.`subjectno`WHERE `sub`.`subjectname` = &#x27;数据库结构-1&#x27;ORDER BY `studentresult` ASC; 分页 12345678910111213141516171819202122232425-- 100万-- 分页-- 环境： 数据库压力 给人的体验更好 瀑布流（图片）-- 分页， 每页只显示五条数据-- 网页： 当前页 总的页数 页面大小-- limit 当前页 页面的大小-- LIMIT 1,5; -- 2到6调数据-- limit 0,5;-- 1到5调数据SELECT `s`.`studentno`,`studentname`,`subjectname`,`studentresult`FROM `student` AS `s` INNER JOIN `result` AS `r`ON `s`.`studentno` = `r`.`studentno`INNER JOIN `subject` AS `sub`ON `r`.`subjectno` = `sub`.`subjectno`WHERE `sub`.`subjectname` = &#x27;数据库结构-1&#x27;ORDER BY `studentresult` ASCLIMIT 1,5; -- 1到5调数据-- 第一页 limit 0,5 (i-1)*5-- 第二页 limit 5,5 (i-1)*5-- 第三页 limit 10,5-- 第二页 limit 0,5 (n-1)*pagesize,pagesize-- pagesize 页面的大小 (n-1)*pagesize起始值 n代表当前页-- 总数 [n代表当前页] -- 总页数=总数/页面的大小 语法：limit(查询起始下标 ， pagesize) 小练习： 1234567891011-- 查询java第一学年 课程成绩排名前十的学生 并且分数大于80的学生的信息-- （学号，姓名，课程名称，分数）SELECT `s`.`studentno`,`studentname`,`subjectname`,`studentresult`FROM `student` AS `s` INNER JOIN `result` AS `r`ON `s`.`studentno` = `r`.`studentno`INNER JOIN `subject` AS `sub`ON `sub`.`subjectno` = `r`.`subjectno`WHERE `subjectname` = &#x27;JAVA第一学年&#x27; AND `studentresult` &gt; 80ORDER BY `studentresult` DESCLIMIT 0,10; 4.6子查询where（值是固定的 ， 这个值是计算出来的） 本质：在where语句中嵌套一个子查询语句 where （select * from ..） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970-- =============where============-- 查询数据库结构-1的所有考试结果（学号 ， 科目编号 ， 成绩） ，降序排列-- 方式一SELECT `studentno`,`sub`.`subjectno`,`studentresult`FROM `result` AS r INNER JOIN `subject` AS `sub`ON `sub`.`subjectno` = `r`.`subjectno`WHERE `sub`.`subjectname` = &#x27;数据库结构-1&#x27;ORDER BY `studentresult` DESC;-- 方式二： （使用子查询）(由里及外)SELECT `studentno`,`subjectno`,`studentresult`FROM `result`WHERE `subjectno` = (SELECT `subjectno` FROM `subject`WHERE `subjectname` = &#x27;数据库结构-1&#x27;)ORDER BY `studentresult` DESC;-- 分数不小于80分的学生的学号和姓名SELECT DISTINCT `s`.`studentno`,`studentname`FROM `student` AS `s` INNER JOIN`result` AS `r`ON `s`.`studentno` = `r`.`studentno`WHERE `studentresult` &gt; 80;-- 在这个基础上增加一个高等数学-2 查询高等数学-2的编号SELECT DISTINCT `s`.`studentno`,`studentname`FROM `student` AS `s` INNER JOIN`result` AS `r`ON `s`.`studentno` = `r`.`studentno`WHERE `studentresult` &gt; 80 AND `subjectno` = (SELECT `subjectno` FROM `subject` WHERE `subjectname` = &#x27;高等数学-2&#x27;); -- 查询课程为高等数学-2 且分数不小于80分的同学的学号和姓名SELECT `s`.`studentno`,`studentname`FROM `student` AS `s` INNER JOIN `result` AS `r`ON `s`.`studentno` = `r`.`studentno`INNER JOIN `subject` AS `sub`ON `sub`.`subjectno` = `r`.`subjectno`WHERE `studentresult` &gt; 80 AND `sub`.`subjectname` = &#x27;高等数学-2&#x27;;-- 嵌套再改造(过程还是由里及外) SELECT `studentno`,`studentname` FROM `student`WHERE `studentno` IN (SELECT `studentno` FROM `result`WHERE `studentresult`&gt;80 AND `subjectno` = (SELECT `subjectno` FROM `subject` WHERE `subjectname` = &#x27;高等数学-2&#x27;) ); -- 查询c语言-1 前五名同学的成绩信息（学号 姓名 分数）-- 使用子查询SELECT `s`.`studentno`,`studentname`,`studentresult`FROM `student` AS `s` INNER JOIN `result` AS `r`WHERE`s`.`studentno` = `r`.`studentno` AND `subjectno` = (SELECT `subjectno`FROM `subject`WHERE `subjectname` = &#x27;c语言-1&#x27;)ORDER BY `studentresult` DESCLIMIT 0,5; &#x3D;&#x3D;注意where子查询是比较快的，因为它不负责连接&#x3D;&#x3D; 4.7分组和过滤12345678-- 查询不同课程的平均分 最高分 最低分 平均分大于80分-- 核心： 分组进行查询SELECT `subjectname` , AVG(`studentresult`) AS &#x27;平均分&#x27;,MAX(`studentresult`) AS &#x27;最高分&#x27;,MIN(`studentresult`) AS &#x27;最低分&#x27;FROM `result` AS `r` INNER JOIN `subject` AS `sub`ON `r`.`SubjectNo` = `sub`.`SubjectNo`GROUP BY `r`.`SubjectNo`HAVING 平均分 &gt;= 80; -- 通过什么字段进行分组 4.8select小结淘宝每个人登录的时候的首页都是不同的 5.MySQL函数官网 ：https://dev.mysql.com/doc/refman/5.7/en/sql-function-reference.html 5.1常用函数（并不常用）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950-- ===========常用函数==================-- 数学函数SELECT ABS(-8); -- 绝对值SELECT CEILING(9.4); -- 向上取整SELECT FLOOR(9.4); -- 向下取整SELECT RAND(); -- 0到1之间的随机数SELECT SIGN(-8); -- 判断一个数的符号 负数返回负一 正数返回1 0 返回0-- 字符串函数SELECT CHAR_LENGTH(&#x27;即使再小的帆也能远航&#x27;); -- 字符长长度SELECT CONCAT(&#x27;我&#x27;,&#x27;爱&#x27;,&#x27;你们&#x27;); -- 拼接字符串-- 查询，替换 从某个位置开始替换某个长度SELECT INSERT(&#x27;我爱编程helloworld&#x27;,1,2,&#x27;超级热爱&#x27;); -- 转大写或者是小写字母SELECT LOWER(&#x27;Kuangshen&#x27;);SELECT UPPER(&#x27;Kuangshen&#x27;);-- 查看是第几个字符SELECT INSTR(&#x27;kuangshen&#x27;,&#x27;h&#x27;); -- 替换指定的字符串SELECT REPLACE(&#x27;坚持就能成功&#x27;,&#x27;坚持&#x27;,&#x27;努力&#x27;); -- 截取指定的字符串（原字符串，截取的位置，截取的长度）SELECT SUBSTR(&#x27;狂神坚持就能成功&#x27;,4);-- 反转字符串 SELECT REVERSE(&#x27;狂神坚持就能成功&#x27;);-- 查询姓周的同学， 名字周改为邹SELECT REPLACE(`studentname`,&#x27;周&#x27;,&#x27;邹&#x27;) FROM `student`WHERE `studentname` LIKE &#x27;周%&#x27;;-- 时间和日期函数（记住）-- 获取当前日期SELECT CURRENT_DATE(); SELECT CURDATE();-- 获取当前的时间SELECT NOW();-- 获取本地时间SELECT LOCALTIME();-- 系统时间SELECT SYSDATE();SELECT YEAR(NOW());SELECT MONTH(NOW());SELECT DAY(NOW());SELECT HOUR(NOW());SELECT MINUTE(NOW());SELECT SECOND(NOW());-- 系统当前的用户SELECT SYSTEM_USER();SELECT USER();SELECT VERSION(); 5.2聚合函数 函数名称 描述 COUNT() 计数 SUM() 求和 AVG() 平均数 MAX() 最大值 MIN() 最小值 … … 1234567891011121314-- ==========聚合函数============-- count(指定列) 会忽略所有的null值-- count(*) 包括了所有的列，相当于行数，在统计结果的时候，不会忽略值为null-- count(1) 包括了忽略所有列，用1代表代码行，不会忽略列值为null-- 列为主键 count(列名) 比count（1）快-- 想查询一个表中有多少记录count（）SELECT COUNT(`studentname`) FROM `student`;SELECT COUNT(*) FROM `student`; -- 本质： 计算行数SELECT COUNT(1) FROM `student`;SELECT SUM(`studentresult`) AS &#x27;总和&#x27; FROM `result`;SELECT AVG(`studentresult`) AS &#x27;平均数&#x27; FROM `result`;SELECT MAX(`studentresult`) AS &#x27;最高分&#x27; FROM `result`;SELECT MIN(`studentresult`) AS &#x27;最低分&#x27; FROM `result`; 5.3数据库级别的MD5加密（扩展）什么是MD5： 主要是增强算法的复杂度和不可逆性 MD5不可逆，具体的值的MD5是一样的 MD5破解网站的原理，背后有一个字典，MD5加密后的值 加密的前值 12345678910111213141516171819202122-- ============测试MD5加密========CREATE TABLE `testmd5`(`id` INT(4) NOT NULL,`name` VARCHAR(20) NOT NULL,`pwd` VARCHAR(50) NOT NULL,PRIMARY KEY(`id`))ENGINE=INNODB DEFAULT CHARSET=utf8-- 明文密码INSERT INTO `testmd5` VALUES (1,&#x27;张三&#x27;,&#x27;123456&#x27;),(2,&#x27;李四&#x27;,&#x27;123456&#x27;),(3,&#x27;王五&#x27;,&#x27;123456&#x27;),(4,&#x27;陈留红&#x27;,&#x27;123456&#x27;),(5,&#x27;孙子&#x27;,&#x27;123456&#x27;);-- 加密UPDATE `testmd5` SET pwd=MD5(pwd) WHERE id=1;-- 加密全部的密码UPDATE `testmd5` SET pwd=MD5(pwd);-- 插入的时候加密INSERT INTO `testmd5` VALUES(6,&#x27;杜志明&#x27;,MD5(&#x27;123456&#x27;));-- 如何校验 ： 将用户传递进来的密码进行md5加密，然后比对加密的值SELECT * FROM `testmd5` WHERE `name`=&#x27;陈留红&#x27; AND pwd=MD5(&#x27;123456&#x27;); 6.事务6.1什么是事务&#x3D;&#x3D;要么都成功，要么都失败&#x3D;&#x3D; 一一一一一一一一一一一一一一一一 1.sql执行 a给b转账 a 1000 —-》 200 b 2.sql执行 b收到a的钱 a 800 —-》 b 400 一一一一一一一一一一一一一一一一 将一组sql放在一个批次中去执行 innodb，在最新版的myisam也是支持的 事务原则： ACID 原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性 （Durability） （脏读，幻读 …） &#x3D;&#x3D;原子性 Atomicity&#x3D;&#x3D; 要么都成功，要么都失败 &#x3D;&#x3D;一致性 Consistency&#x3D;&#x3D; 事务前后的数据完整性要保持一致 &#x3D;&#x3D;持久性 Durability&#x3D;&#x3D; 事务一旦提交则不可逆转，被持久化到数据库中 &#x3D;&#x3D;隔离性 Isolation&#x3D;&#x3D; 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他的操作数据干扰，事务之间要互相隔离 隔离所导致的一些问题： 脏读： 指一个是务读取了另一个事务未提交的数据 不可重复读： 在一个事务内读取表中的某一行数据，多次读的结果不同（这个不一定是错误，只是某些场合不对） 幻读： 是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致 事务 123456789101112131415161718192021-- =========事务========-- mysql是默认开启事务自动提交的SET autocommit = 0; -- 关闭-- 手动处理事务-- 事务开启-- 标志事务的开始，从这个之后的sql都在同一个事务内START TRANSACTION; -- 提交 持久化COMMIT;-- 回滚 回到原来的样子ROLLBACK;-- 事务结束SET autocommit = 1; -- 开启SAVEPOINT 保存点名; -- 保存点名 设置一个事务的保存点ROLLBACK TO SAVEPOINT 保存点名; -- 回滚到保存点位置RELEASE SAVEPOINT 保存点名; -- 删除保存点 事务流程图 模拟场景 12345678910111213141516171819202122232425-- 转账CREATE DATABASE shop CHARACTER SET utf8 COLLATE utf8_general_ci;USE shop;CREATE TABLE `account`(`id` INT(3) NOT NULL AUTO_INCREMENT,`name` VARCHAR(30) NOT NULL,`money` DECIMAL(9,2) NOT NULL,PRIMARY KEY(`id`))ENGINE=INNODB DEFAULT CHARSET=utf8SELECT * FROM `account`;INSERT INTO `account`(`name`,`money`) VALUES(&#x27;A&#x27;,2000.00),(&#x27;B&#x27;,10000.00); -- 模拟转账SET autocommit = 0; -- 关闭自动提交START TRANSACTION; -- 开启事务UPDATE `account` SET `money` = `money`-500 WHERE `name`=&#x27;A&#x27;; --A减500UPDATE `account` SET `money` = `money`+500 WHERE `name`=&#x27;B&#x27;; --B加500COMMIT; -- 提交事务ROLLBACK; -- 回滚SET autocommit=1; -- 恢复默认值 &#x3D;&#x3D;注意： 这里是手动点的，在java中使用的是try catch，在执行失败的时候自己会回滚&#x3D;&#x3D; 7.索引MySQL官方对索引的定义为：&#x3D;&#x3D;索引（Index） 是帮助MySQL高效获取数据的数据结构&#x3D;&#x3D;。 &#x3D;&#x3D;提取句子主干，就可以得到索引的本质；索引是数据结构&#x3D;&#x3D; 7.1索引的分类 在一个表中，主键索引只能有一个，唯一索引可以有多个 主键索引 &#x3D;&#x3D;PRIMARY KEY&#x3D;&#x3D; 唯一的标识，主键不可重复，只能有一个主键索引 唯一索引 &#x3D;&#x3D;UNIQUE KEY&#x3D;&#x3D; 避免重读的列出现，唯一索引可以重复， 多个列都可以标识唯一索引 常规索引 &#x3D;&#x3D;KEY&#x2F;index&#x3D;&#x3D; 默认的，index关键字或者是key关键字设置 全文索引 &#x3D;&#x3D;FUllText&#x3D;&#x3D; 在特定的数据库引擎下才有 myisam 快速定位数据 基础语法 1234567891011121314-- 索引的使用-- 在创建表的时候给字段增加索引-- 创建完毕后增加索引-- 显示所有的索引信息USE `school`;SHOW INDEX FROM `student`;-- 增加一个索引-- ALTER TABLE 数据库的表 ADD FULLTEXT INDEX `索引名`(`索引的列`);ALTER TABLE `school`.`student` ADD FULLTEXT INDEX `studentname`(`studentname`);-- EXPLAIN 分析sql执行的状况EXPLAIN SELECT * FROM `student`; -- 非全文索引EXPLAIN SELECT * FROM `student` WHERE MATCH(`studentname`) AGAINST(&#x27;刘&#x27;); 7.2测试索引123456789101112131415161718192021222324252627282930313233343536373839CREATE TABLE `app_user`(`id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#x27;用户的id&#x27;,`name` VARCHAR(20) DEFAULT &#x27;&#x27; COMMENT &#x27;用户的名字&#x27;,`email` VARCHAR(50) NOT NULL COMMENT &#x27;用户邮箱&#x27;,`phone` VARCHAR(20) DEFAULT &#x27;&#x27; COMMENT &#x27;手机号&#x27;,`gender` TINYINT(4) UNSIGNED DEFAULT &#x27;0&#x27; COMMENT &#x27;性别（0为男，1为女）&#x27;,`password` VARCHAR(100) NOT NULL COMMENT &#x27;密码&#x27;,`age` TINYINT(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;年龄&#x27;,`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,`update_time` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,PRIMARY KEY(`id`))ENGINE=INNODB DEFAULT CHARSET=utf8mb4 COMMENT &#x27;app用户表&#x27;;-- 插入100万条数据 49.011秒插入1000000调数据-- 必须写，当做标志DELIMITER $$ CREATE FUNCTION mock_data()RETURNS INT DETERMINISTICBEGIN\tDECLARE num INT DEFAULT 1000000;\tDECLARE i INT DEFAULT 0;\tWHILE i&lt;num DO INSERT INTO `app_user`(`name`,`email`,`phone`,`gender`,`password`,`age`) VALUES(CONCAT(&#x27;用户&#x27;,i),&#x27;1844736251@qq.com&#x27;,CONCAT(&#x27;18&#x27;,FLOOR(RAND()*((999999999-100000000)+100000000))),FLOOR(RAND()*2),UUID(),FLOOR(RAND()*100)); SET i = i+1;\tEND WHILE;\tRETURN i;END;SELECT mock_data();-- 耗时 0.607秒SELECT * FROM `app_user` WHERE `name` = &#x27;用户9999&#x27;;-- 耗时0秒SELECT * FROM `student`;EXPLAIN SELECT * FROM `app_user` WHERE `name` = &#x27;用户9999&#x27;;-- 创建索引相当与是使用了树 没加索引相当于是遍历，创建索引相当于是定位-- id_表名_字段名-- CREATE INDEX 索引名 ON `表名`(`字段名`);CREATE INDEX id_app_user_name ON `app_user`(`name`); &#x3D;&#x3D;注意： 索引在小数据量的时候用处不大，但是在大数据的时候，区别十分明显&#x3D;&#x3D; 7.3索引原则 索引不是越多越好 不要对经常变动的数据加索引 小数据量的表不需要加索引 索引一般加在常用来查询的字段上 索引的数据结构 Hash类型的索引，默认的是BTREE（INNODB的默认的底层的数据结构） 阅读： http://blog.codinglabs.org/articles/theory-of-mysql-index.html 8.权限管理和数据库备份8.1用户权限 SQL yog 可视化管理 SQL命令操作 用户表： mysql.user 本质： 对这张表进行增删改查 1234567891011121314151617181920212223242526272829-- 用户-- 创建用户 CREATE USER 用户名 IDENTIFIED BY &#x27;密码&#x27;;CREATE USER timous IDENTIFIED BY &#x27;123456&#x27;;-- 修改指定用户密码SET PASSWORD = PASSWORD(&#x27;123456&#x27;); -- 8版本的不行SET PASSWORD FOR timous = PASSWORD(&#x27;123456&#x27;);-- 重命名 RENAME USER 原来的名字 TO 新的名字;RENAME USER timous TO timous2;-- 授予全部的权限 用户授权 除了给别人授权，其他的都能干-- GRANT ALL PRIVILEGES ON 库.表 TO 用户;GRANT ALL PRIVILEGES ON *.* TO timous2;-- 查询权限 -- 查看指定用户的权限SHOW GRANTS FOR timous2;-- root 用户的权限 防止你删库跑路 SHOW GRANTS FOR root@localhost;-- 撤销权限-- REVOKE ALL PRIVILEGES ON 库.表 FROM 用户;REVOKE ALL PRIVILEGES ON *.* FROM timous2;-- 删除用户CREATE USER kuangshen;DROP USER kuangshen; 8.2数据库备份 保证重要的数据不丢失 数据转移 MySQL数据库备份的方式: 直接拷贝物理文件 使用sqlyog可视化工具中备份导出 命令行导出 mysqldump 命令行使用 是在cmd里面 123456789101112C:\\Users\\Administrator&gt;mysqldump -hlocalhost -uroot -p123456 school student &gt;D:/a.sqlmysqldump: [Warning] Using a password on the command line interface can be insecure.mysqldump -h主机 -u用户名 -p密码 数据库名 表名1 表2 表3 &gt;磁盘位置:/文件名mysqldump -h主机 -u用户名 -p密码 数据库名 &gt;磁盘位置:/文件名mysql -uroot -p123456 # 登录source d:/a.sql就可以了# 导入 登录的情况下直接source就可以了（导入数据库不需要切换）mysql -uroot -p密码 库名&lt; 备份文件 假设你要备份数据库，防止数据丢失，把数据库给朋友，sql文件给别人即可！ 9.规范数据库设计9.1为什么需要设计数据库&#x3D;&#x3D;当数据库比较复杂的时候，我们就需要设计数据库了&#x3D;&#x3D; 糟糕的数据库设计 数据冗余，浪费空间 数据库插入和删除都会麻烦，异常[屏蔽使用物理外键] 程序的性能差 良好的数据库设计 节省内存空间 保证数据库的完整性 方便我们开发系统 软件开发中，关于数据库的设计 需求分析： 分析业务和需要处理的数据库的需求 概要设计： 设计关系图 ER图 设计数据库的步骤（个人博客） 收集信息，分析需求 用户表（用户登录注销，用户的个人信息，写博客，创建分类） 分类表（文章分类，谁创建的) 文章表（文章的信息） 友链表（友链信息） 自定义表（系统信息，某个关键的字，或者一些主字段） key value 评论表 说说表（发表心情 id content create_time update_time） 标识实体（把需求落实到每个字段） 标识实体之间的关系 写博客 user—》blog 创建分类user—-》 category 关注user—-&gt;user 友链； link 评论： user—user—-blog 9.2三大范式为什么需要数据规范化： 信息重复 更新异常 插入异常 无法正常显示信息 删除异常 丢失有效的信息 三大范式 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF） &#x3D;&#x3D;第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。&#x3D;&#x3D; 原子性： 每一列不可再分 &#x3D;&#x3D;第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）&#x3D;&#x3D; 前提： 满足第一范式 每张表只描述一件事 &#x3D;&#x3D;第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）&#x3D;&#x3D; 前提： 满足第二范式的条件下消除依赖 规范数据库的设计 规范性和性能问题： 阿里的规范： 关联的表不能超过三张 考虑商业化的需求和目标（成本和用户的体验） 数据库的性能更加重要 在规范性能问题的时候，适当的去考虑一下规范性 故意给某些表增加一些冗余字段 订单： 商品id—查询商品 可以直接放商品的信息 故意增加一些计算列（每次增加的时候直接增加列加一，从大数据量降低为小数据量的查询： 添加索引） 10.jdbc10.1数据库驱动驱动： 声卡，显卡、数据库 我们的程序会通过数据库驱动，和数据库打交道 10.2JDBCsun公司为了假话开发人员（对数据库同一）的操作，提供了一个（java操作数据库的）规范，俗称JDBC这些规范的实现由具体的厂商去做 对开发人员来说，我们只需要掌握JDBC的接口的操作即可 java.sql javax.sql 还需要导入数据库驱动包mysql-connector-java-8.0.11.jar 10.3第一个JDBC程序 创建测试数据库 1234567891011121314151617181920CREATE DATABASE `jdbcstudy` CHARACTER SET utf8 COLLATE utf8_general_ci;USE `jdbcstudy`;CREATE TABLE `users`(`id` INT,`name`VARCHAR(40),`password` VARCHAR(40),`email` VARCHAR(60),`birthday` DATE,PRIMARY KEY(`id`))ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `users`(id,`name`,`password`,`email`,`birthday`)VALUES(1,&#x27;zhangsan&#x27;,&#x27;123456&#x27;,&#x27;zs@sina.com&#x27;,&#x27;1980-12-04&#x27;),(2,&#x27;lisi&#x27;,&#x27;123456&#x27;,&#x27;lisi@sina.com&#x27;,&#x27;1980-12-04&#x27;),(3,&#x27;wangwu&#x27;,&#x27;123456&#x27;,&#x27;wangwu@sina.com&#x27;,&#x27;1980-12-04&#x27;);SELECT * FROM `users`; 1.创建一个普通项目 2.导入数据库驱动 3.编写测试代码 12345678910111213141516171819202122232425262728293031323334353637package com.tmous.test01;import java.sql.*;//我的第一个jdbc程序public class JdbcFirstDemo &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //1.加载驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 固定写法，加载驱动 //2.用户信息和url String url = &quot;jdbc:mysql://127.0.0.1:3306/jdbcstudy?serverTimezone=UTC&amp;amp&amp;useSSL=false&quot;; String username = &quot;root&quot;; String password = &quot;123456&quot;; //3.连接成功 Connection connection = DriverManager.getConnection(url,username,password); //4.执行sql的对象 Statement statement = connection.createStatement(); //5.执行sql String sql = &quot;SELECT * FROM `users`;&quot;; ResultSet resultSet = statement.executeQuery(sql);//结果集中封装了对应的结果 while(resultSet.next())&#123; System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;)); System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;)); System.out.println(&quot;password=&quot;+resultSet.getObject(&quot;password&quot;)); System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;)); System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;)); &#125; //6、释放连接 resultSet.close(); statement.close(); connection.close(); &#125;&#125; 步骤总结： 加载驱动 连接数据库DriverManager 获得执行sql的对象Statement 获得返回的结果集 释放连接 DriverManager 1234567891011121314//1.加载驱动// 不推荐使用 DriverManager.registerDriver(new Driver()); 本身里面已经注册过来了Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 固定写法，加载驱动Connection connection = DriverManager.getConnection(url,username,password); //代表数据库// 可以提交或者是回滚等//数据库设置自动提交// 事务提交// 事务回滚 connection.commit(); connection.rollback(); connection.setAutoCommit(); URL 12345//2.用户信息和urlString url = &quot;jdbc:mysql://127.0.0.1:3306/jdbcstudy?serverTimezone=UTC&amp;amp&amp;useSSL=false&quot;;// mysql默认是3306 orcle默认是1521 orcle的表就是一个库 sqlserver 1433String username = &quot;root&quot;;String password = &quot;123456&quot;; Statement 执行sql的类 PreparedStatement 12345678String sql = &quot;SELECT * FROM `users`;&quot;; //编写sqlStatement statement = connection.createStatement();statement.executeQuery(); // 查询条件返回结果集statement.execute(); //执行任何操作statement.executeUpdate();// 更新、插入、删除，都是用这个，返回一个受影响的行数 statement.executeBatch();//执行多个sql Result 查询的结果集 ： 封装了所有的查询结果 获得指定的数据类型 12345678910111213141516171819202122ResultSet resultSet = statement.executeQuery(sql);//结果集中封装了对应的结果resultSet.getObject(); // 在不知道列类型的时候使用 知道的话直接使用resultSet.getString();resultSet. 遍历，指针//获取结果集 while(resultSet.next())&#123; System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;)); System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;)); System.out.println(&quot;password=&quot;+resultSet.getObject(&quot;password&quot;)); System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;)); System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;)); &#125; resultSet.beforeFirst(); //移动到最前面一行 resultSet.afterLast();//移动到最后面一行 resultSet.next();//移动到下一个 resultset.previous();//移动到前一行 resultset.absolute(row);//移动到指定行 释放资源 1234//6、释放连接resultSet.close();statement.close();connection.close(); 10.4Statement对象&#x3D;&#x3D;Jdbc中的statement对象用于向数据库发送sql语句，想完成数据库的增删改查，只需要通过这个对象向数据库发送增删改查语句即可。&#x3D;&#x3D; Statement对象的&#x3D;&#x3D;executeUpdate&#x3D;&#x3D;方法，用于向数据库发送&#x3D;&#x3D;增删改&#x3D;&#x3D;的sql语句，executeUpdate执行完后，将会返回一个整数（即增删改语句导致了数据库几行数据发生了变化） &#x3D;&#x3D;Statement.executeQuery&#x3D;&#x3D;方法返回代表&#x3D;&#x3D;查询&#x3D;&#x3D;结果的ResultSet对象 CRUD操作-create 使用executeUpdate（String sql）方法完成数据添加操作，示例操作： 123456Statement st = conn.createStatement();String sql = &quot;insert into user() values();&quot;;int num = st.executeUpdate(sql);if(num&gt;0)&#123; System.out.println(&quot;插入成功！！！&quot;);&#125; CRUD操作-delete 使用executeUpdate（String sql）方法完成数据删除操作，示例操作： 123456Statement st = conn.createStatement();String sql = &quot;delete from user where id=1;&quot;;int num = st.executeUpdate(sql);if(num&gt;0)&#123; System.out.println(&quot;删除成功！！！&quot;);&#125; CRUD操作-update 使用executeUpdate（String sql）方法完成数据删除操作，示例操作： 123456Statement st = conn.createStatement();String sql = &quot;update user set name=&#x27;&#x27; where name=&#x27;&#x27;;&quot;;int num = st.executeUpdate(sql);if(num&gt;0)&#123; System.out.println(&quot;更新成功！！！&quot;);&#125; CRUD操作-read 使用executeQuery（String sql）方法完成数据删除操作，示例操作： 123456Statement st = conn.createStatement();String sql = &quot;select * from user where id=1;&quot;;ResultSet resultset = st.executeQuery(sql);while(resultset.next())&#123; //根据获取列的数据类型，分别调用rs的响应方法映射到java中&#125; 代码实现 1.提取工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.tmous.utils;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JdbcUtils &#123; private static String driver = null; private static String url = null; private static String username = null; private static String password = null; static&#123; try &#123; InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); Properties properties = new Properties(); properties.load(in); driver = properties.getProperty(&quot;driver&quot;); url = properties.getProperty(&quot;url&quot;); username = properties.getProperty(&quot;username&quot;); password = properties.getProperty(&quot;password&quot;); //1.驱动只需要加载一次 Class.forName(driver); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //获取连接 public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url,username,password); &#125; //释放连接资源 public static void release(Connection connection , Statement statement , ResultSet resultSet)&#123; if(resultSet!=null)&#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(statement!=null)&#123; try &#123; statement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(connection!=null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;\t&#125;&#125;// db.propertiesdriver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/jdbcstudy?serverTimezone=UTC&amp;amp&amp;useSSL=falseusername=rootpassword=123456 2.编写增删改的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//增package com.tmous.test01;import com.tmous.utils.JdbcUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestInsert &#123; public static void main(String[] args) &#123; Connection connection = null; Statement statement = null; ResultSet resultSet = null; try &#123; connection = JdbcUtils.getConnection(); //获取数据库连接 statement = connection.createStatement(); String sql = &quot;INSERT INTO `users`(`id`,`name`,`password`,`email`,`birthday`)&quot; + &quot;VALUES (4,&#x27;chenliuhong&#x27;,&#x27;123456&#x27;,&#x27;chenliuhong@sina.com&#x27;,&#x27;1980-12-05&#x27;);&quot;; int i = statement.executeUpdate(sql); if(i&gt;0)&#123; System.out.println(&quot;插入成功！&quot;); &#125;else&#123; System.out.println(&quot;插入失败！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.release(connection , statement , resultSet); &#125; &#125;&#125;//删package com.tmous.test01;import com.tmous.utils.JdbcUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestDelete &#123; public static void main(String[] args) &#123; Connection connection = null; Statement statement = null; ResultSet resultSet = null; try &#123; connection = JdbcUtils.getConnection(); //获取数据库连接 statement = connection.createStatement(); String sql = &quot;DELETE FROM `users` WHERE `id` = 4;&quot;; int i = statement.executeUpdate(sql); if(i&gt;0)&#123; System.out.println(&quot;删出成功！&quot;); &#125;else&#123; System.out.println(&quot;删出失败！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.release(connection , statement , resultSet); &#125; &#125;&#125;//改package com.tmous.test01;import com.tmous.utils.JdbcUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestUpdate &#123; public static void main(String[] args) &#123; Connection connection = null; Statement statement = null; ResultSet resultSet = null; try &#123; connection = JdbcUtils.getConnection(); //获取数据库连接 statement = connection.createStatement(); String sql = &quot;UPDATE `users` SET `name`=&#x27;陈留红&#x27; WHERE `id` = 1;&quot;; int i = statement.executeUpdate(sql); if(i&gt;0)&#123; System.out.println(&quot;修改成功！&quot;); &#125;else&#123; System.out.println(&quot;修改失败！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.release(connection , statement , resultSet); &#125; &#125;&#125; 3.查询的代码 123456789101112131415161718192021222324252627282930313233343536package com.tmous.test01;import com.tmous.utils.JdbcUtils;import javax.swing.plaf.nimbus.State;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestSelect &#123; public static void main(String[] args) &#123; Connection connection = null; Statement statement = null; ResultSet rs = null; //获取连接 try &#123; connection = JdbcUtils.getConnection(); statement = connection.createStatement(); String sql = &quot;SELECT * FROM `users`; &quot;; rs = statement.executeQuery(sql); while(rs.next())&#123; System.out.println(&quot;id=&quot;+rs.getObject(&quot;id&quot;)); System.out.println(&quot;name=&quot;+rs.getObject(&quot;name&quot;)); System.out.println(&quot;password=&quot;+rs.getObject(&quot;password&quot;)); System.out.println(&quot;email=&quot;+rs.getObject(&quot;email&quot;)); System.out.println(&quot;birthday=&quot;+rs.getObject(&quot;birthday&quot;)); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.release(connection , statement , rs); &#125; &#125;&#125; sql注入的问题 sql存在漏洞，会被攻击，导致泄漏 &#x3D;&#x3D;SQL会被拼接&#x3D;&#x3D; 123456789101112131415161718192021222324252627282930313233343536373839package com.tmous.test01;import com.tmous.utils.JdbcUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class SqlProblem &#123; public static void main(String[] args) &#123; //login(&quot;陈留红&quot;,&quot;123456&quot;); // 正常登录 login(&quot;&#x27;or &#x27;1=1&quot; , &quot;123456&quot;);// 有技巧的输入 &#125; //登录业务 public static void login(String username , String password)&#123; Connection connection = null; Statement statement = null; ResultSet rs = null; //获取连接 try &#123; connection = JdbcUtils.getConnection(); statement = connection.createStatement(); String sql = &quot;SELECT * FROM `users` where name = &#x27;&quot;+username+&quot;&#x27;and password = &#x27;&quot;+password+&quot;&#x27;;&quot;; rs = statement.executeQuery(sql); while(rs.next())&#123; System.out.println(&quot;name=&quot;+rs.getObject(&quot;name&quot;)); System.out.println(&quot;password=&quot;+rs.getObject(&quot;password&quot;)); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.release(connection , statement , rs); &#125; &#125;&#125; 10.5PreparedStatementPreparedStatement可以防止sql注入，并且效率更好。 增删改代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// 增package com.tmous.test01;import com.tmous.utils.JdbcUtils;import java.sql.*;public class TestInserts &#123; public static void main(String[] args) &#123; Connection connection = null; PreparedStatement st = null; ResultSet rs = null; try &#123; connection = JdbcUtils.getConnection(); //区别 ： 使用问号占位符代替参数 String sql = &quot;INSERT INTO `users`(`id`,`name`,`password`,`email`,`birthday`) VALUES (?,?,?,?,?);&quot;; st = connection.prepareStatement(sql); //预编译的sql //手动给参数赋值 st.setInt(1,4); st.setString(2,&quot;老狗&quot;); st.setString(3,&quot;123456&quot;); st.setString(4,&quot;1844736@qq.com&quot;); st.setDate(5, new java.sql.Date(new java.util.Date().getTime())); int i = st.executeUpdate(); if(i&gt;0)&#123; System.out.println(&quot;插入成功！&quot;); &#125;else&#123; System.out.println(&quot;插入失败！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.release(connection , st , null); &#125; &#125;&#125;//删package com.tmous.test01;import com.tmous.utils.JdbcUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;//测试public class TestDeletes &#123; public static void main(String[] args) &#123; Connection connection = null; PreparedStatement st = null; ResultSet rs = null; try &#123; connection = JdbcUtils.getConnection(); //区别 ： 使用问号占位符代替参数 String sql = &quot;delete from `users` where id=?&quot;; st = connection.prepareStatement(sql); //预编译的sql //手动给参数赋值 st.setInt(1,4); int i = st.executeUpdate(); if(i&gt;0)&#123; System.out.println(&quot;删出成功！&quot;); &#125;else&#123; System.out.println(&quot;删出失败！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.release(connection , st , null); &#125; &#125;&#125;//改package com.tmous.test01;import com.tmous.utils.JdbcUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class TestUpdates &#123; public static void main(String[] args) &#123; Connection connection = null; PreparedStatement st = null; ResultSet rs = null; try &#123; connection = JdbcUtils.getConnection(); //区别 ： 使用问号占位符代替参数 String sql = &quot;update `users` set `name` = ? where id = ?&quot;; st = connection.prepareStatement(sql); //预编译的sql //手动给参数赋值 st.setString(1,&quot;小明&quot;); st.setInt(2,1); int i = st.executeUpdate(); if(i&gt;0)&#123; System.out.println(&quot;更新成功！&quot;); &#125;else&#123; System.out.println(&quot;更新失败！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.release(connection , st , null); &#125; &#125;&#125; 防止sql注入 12345678910111213141516171819202122232425262728293031323334353637383940package com.tmous.test01;import com.tmous.utils.JdbcUtils;import java.sql.*;public class SqlProblems &#123; public static void main(String[] args) &#123; //login(&quot;lisi&quot;,&quot;123456&quot;); // 正常登录 login(&quot;&#x27;or &#x27;1=1&quot; , &quot;123456&quot;);// 有技巧的输入 &#125; //登录业务 public static void login(String username , String password)&#123; Connection connection = null; PreparedStatement st = null; ResultSet rs = null; //获取连接 try &#123; connection = JdbcUtils.getConnection(); String sql = &quot;SELECT * FROM `users` where `name` = ? and `password` = ?;&quot;; st = connection.prepareStatement(sql); st.setString(1,username); st.setString(2,password); rs = st.executeQuery(); while(rs.next())&#123; System.out.println(&quot;name=&quot;+rs.getObject(&quot;name&quot;)); System.out.println(&quot;password=&quot;+rs.getObject(&quot;password&quot;)); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.release(connection , st , rs); &#125; &#125;&#125; PreparedStatement防止sql注入的本质，把传递进来的参数当做字符，假设其中存在转义字符，就直接忽略，&#96;会被直接转义。 10.7 使用IDEA连接数据库 选择数据库 更新数据 如果mysql连接失败，下面的可能能帮助： 10.8事务&#x3D;&#x3D;要么都成功要么都失败ACID&#x3D;&#x3D; 原子性： 要么全部完成，要么全部失败 一致性： 总数不变 隔离性： 多个进程互不干扰 持久性： 一旦提交不可逆，持久化到数据库了 隔离性的问题： 脏读： 一个事务读取了另一个没有提交的事务 不可重复读： 在同一个事务内重复读取表中的数据，表数据发生了改变 虚读（幻读） ： 在一个事务内，读取到了别人插入的数据，导致前后读出来的数据不一致 代码实现 1.开启事务conn.setAutoCommit(false); 2.一组业务执行完毕提交事务 3.可以在catch语句中显示的定义回滚语句，默认也是失败就会回滚的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package Transaction;import com.tmous.utils.JdbcUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class TestTransaction2 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement st = null; ResultSet rs = null; try &#123; conn = JdbcUtils.getConnection(); //关闭数据库的自动提交,自动会开启事务 conn.setAutoCommit(false);//开启事务 String sql1 = &quot;update `account` set `money` = `money` - 100 where `name` = &#x27;A&#x27;&quot;; st = conn.prepareStatement(sql1); st.executeUpdate(); int x = 1/0; // 报错 ，失败，自动回滚 String sql2 = &quot;update `account` set `money` = `money` + 100 where `name` = &#x27;B&#x27;&quot;; st = conn.prepareStatement(sql2); st.executeUpdate(); //业务完毕，提交业务 conn.commit(); System.out.println(&quot;操作成功！！！&quot;); &#125; catch (SQLException e) &#123; //如果失败，则默认回滚 try &#123; conn.rollback(); // 如果失败，回滚事务 &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; e.printStackTrace(); &#125;finally &#123; JdbcUtils.release(conn , st , rs); &#125; &#125;&#125; 10.9数据库连接池数据库连接—-执行完毕—–释放 连接—–释放是十分浪费系统资源的 &#x3D;&#x3D;池化技术：准备一些预先的资源，过来就连接预先准备好的&#x3D;&#x3D; 10 SQL 5个连接 直接拿到conn 不需要连接 用完释放 最小连接数： 5 10 100 按照需求 最大连接数： 10 业务最高承载上限超过的就排队等待 &#x3D;&#x3D;编写连接池需要 实现一个接口datasource&#x3D;&#x3D; 开源数据源实现 DBCP C3P0 Druid： 阿里巴巴的 使用了这些数据库连接池之后，我们在项目开发的时候就不需要写数据库连接的代码了。 DBCP 需要用到的jar包 commons-dbcp-1.4 commons-pool-1.6 dbcpconfig.properties 123456789101112131415161718192021222324252627282930313233#&lt;!-- 连接设置 --&gt;driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/jdbcstudy?serverTimezone=UTC&amp;amp&amp;useSSL=falseusername=rootpassword=123456#&lt;!--初始化连接 --&gt;initialSize=10#&lt;!--最大连接数量 --&gt;maxActive=50#&lt;!--最大空闲连接 --&gt;maxIdle=20#&lt;!--最小空闲连接--&gt;minIdle=5#&lt;!--超时等待时间以毫秒为单位--&gt;maxWait=60000#JDBC驱动建立时附带的连接属性的格式必须为 属性名=propertiesconnectionProperties=useUnicode=true;characterEncoding=UTF8# 指定由连接池所创建的连接的自动提交状态defaultAutoCommit=true#driver default 指定由连接池所创建的连接的只读状态# 如果没有设置该值 则setReadOnly 方法将不被调用defaultReadOnly=# driver default 指定由连接池所创建的连接的事务的级别defaultTransactionIsolation=READ_UNCOMMITTED DBCP帮助类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.tmous.utils;import org.apache.commons.dbcp.BasicDataSource;import org.apache.commons.dbcp.BasicDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JdbcUtils_DBCP &#123; private static DataSource dataSource = null; static&#123; try &#123; InputStream in = JdbcUtils_DBCP.class.getClassLoader().getResourceAsStream(&quot;dbcpconfig.properties&quot;); Properties properties = new Properties(); properties.load(in); //创建数据源 工厂模式 dataSource = BasicDataSourceFactory.createDataSource(properties); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //获取连接 public static Connection getConnection() throws SQLException &#123; //从数据源中获取连接 return dataSource.getConnection(); &#125; //释放连接资源 public static void release(Connection connection , Statement statement , ResultSet resultSet)&#123; if(resultSet!=null)&#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(statement!=null)&#123; try &#123; statement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(connection!=null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试DBCP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package TestPool;import com.tmous.utils.JdbcUtils;import com.tmous.utils.JdbcUtils_DBCP;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class TestDbcp &#123; public static void main(String[] args) &#123; Connection connection = null; PreparedStatement st = null; ResultSet rs = null; try &#123; connection = JdbcUtils_DBCP.getConnection(); //区别 ： 使用问号占位符代替参数 String sql = &quot;INSERT INTO `users`(`id`,`name`,`password`,`email`,`birthday`) VALUES (?,?,?,?,?);&quot;; st = connection.prepareStatement(sql); //预编译的sql //手动给参数赋值 st.setInt(1,4); st.setString(2,&quot;老狗&quot;); st.setString(3,&quot;123456&quot;); st.setString(4,&quot;1844736@qq.com&quot;); st.setDate(5, new java.sql.Date(new java.util.Date().getTime())); int i = st.executeUpdate(); if(i&gt;0)&#123; System.out.println(&quot;插入成功！&quot;); &#125;else&#123; System.out.println(&quot;插入失败！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils_DBCP.release(connection , st , null); &#125; &#125;&#125; c3p0 c3p0-0.9.5.5,mchange-commons-java-0.2.15导入依赖的jar就行 &#x3D;&#x3D;帮助类：&#x3D;&#x3D; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.tmous.utils;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.apache.commons.dbcp.BasicDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;public class JdbcUtils_C3P0 &#123; private static ComboPooledDataSource dataSource = null; static&#123; try &#123; dataSource = new ComboPooledDataSource(&quot;MySQL&quot;); // 配置文件写法 //代码版配置// dataSource = new ComboPooledDataSource();// dataSource.setDriverClass();// dataSource.setUser();// dataSource.setPassword();// dataSource.setJdbcUrl();// dataSource.setMaxPoolSize();// dataSource.setMinPoolSize(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //获取连接 public static Connection getConnection() throws SQLException &#123; //从数据源中获取连接 return dataSource.getConnection(); &#125; //释放连接资源 public static void release(Connection connection , Statement statement , ResultSet resultSet)&#123; if(resultSet!=null)&#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(statement!=null)&#123; try &#123; statement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(connection!=null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; c3po配置文件：c3p0-config.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/jdbcstudy?useSSL=false&amp;amp;serverTimezone=UTC&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;20&lt;/property&gt; &lt;/default-config&gt; &lt;named-config name=&quot;MySQL&quot;&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/jdbcstudy?useSSL=false&amp;amp;serverTimezone=UTC&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;20&lt;/property&gt; &lt;/named-config&gt;&lt;!-- 可以配置多套数据源 --&gt;&lt;/c3p0-config&gt; 测试类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package TestPool;import com.tmous.utils.JdbcUtils_C3P0;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class TestC3P0 &#123; public static void main(String[] args) &#123; Connection connection = null; PreparedStatement st = null; ResultSet rs = null; try &#123; connection = JdbcUtils_C3P0.getConnection(); //区别 ： 使用问号占位符代替参数 String sql = &quot;INSERT INTO `users`(`id`,`name`,`password`,`email`,`birthday`) VALUES (?,?,?,?,?);&quot;; st = connection.prepareStatement(sql); //预编译的sql //手动给参数赋值 st.setInt(1,5); st.setString(2,&quot;老狗&quot;); st.setString(3,&quot;123456&quot;); st.setString(4,&quot;1844736@qq.com&quot;); st.setDate(5, new java.sql.Date(new java.util.Date().getTime())); int i = st.executeUpdate(); if(i&gt;0)&#123; System.out.println(&quot;插入成功！&quot;); &#125;else&#123; System.out.println(&quot;插入失败！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils_C3P0.release(connection , st , null); &#125; &#125;&#125; 结论 无论是使用什么数据源，本质还是一样的，接口都是没变的（DataSource），方法就不会变，也就是测试类的代码基本都不会变 Druid: 阿里的数据源，比较高级的 —-业务级别的MySQL学习 有兴趣的人 —–运维级别My","tags":["数据库"]},{"title":"java基础知识","path":"/2021/12/31/java基础知识/","content":"Java的基础知识变量、数据类型、运算符二进制计算机中广泛使用的数制，由0和1进行表示，数字计算机只能识别和处理二进制计算。也对应着高电平和低电平等等。在线进制转换工具：https://tool.lu/hexconvert/ ， 下面是一些常见的二进制的数和十进制数的转换。 0 0 1 1 2 10 3 11 4 100 5 101 6 110 7 111 8 1000 9 1001 10 1010 11 1011 12 1100 13 1101 14 1110 注释&#x2F;&#x2F;是给人看的，不是给机器看的，在以后的编程中是非常有用的。 下面是带有注释的代码 //后面对应的就是注释，不影响程序的运行 123456public class HelloWorld &#123; public static void main(String[] args) &#123; //这是我写的第一个注释 System.out.println(&quot;我是Timous&quot;); &#125;&#125; 下面是对应的运行成功的结果。 标识符在命名标识符的时候一般使用驼峰命名的方式。 标识符需要遵守一定的规则： 标识符必须以字母、下划线、美元符号开头 标识符其他部分可以使字母、下划线、美元符、和数组的任意组合 Java标识符大小写敏感，而且长度无限制 标识符不可以是Java的关键字 Java不采用语言使用的ASCII字符集，而是采用Unicode这样的标准国际字符集。因此，这里的字母的含义不仅仅是英文还包括汉字等等。但是不建议大家使用汉字来定义标识符。 Java的关键字、保留字 abstart assert boolean break byte case catch char class const continue default do double else extends final finally float for goto if implements impotrt instanceos int interface long native new null package private protected public return short static strictfp super switch synchronized this throw throws transient try void volatile while 变量（variable）变量的本质是可操作的存储空间，空间位置是确定的，但是里面放置什么值是不确定的。可以通过变量名来访问对应的存储空间，从而操作对应存储空间的值。空间是有大有小的，所以之后还要学习对应的数据类型。在声明变量的时候最好是能够使变量具有一定的可读性。局部变量在使用之前要进行声明。常量只能初始化一次。 int 4个字节 long 8个字节 double 8个字节 变量的分类和作用域从整体上可将变量划分为局部变量、成员变量（也称为实例变量）和静态变量。 类型 声明位置 从属于 生命周期（作用域） 局部变量 方法或语句块内部 方法&#x2F;语句块 从声明的位置开始，知道方法或语句块执行完毕，局部变量消失 成员变量（局部变量） 类内部，方法外部 对象 对象创建，成员变量也跟着创建，对象消失，成员变量也跟着消失 静态变量（类变量） 类内部，static修饰 类 类被加载，静态变量就有效，类被卸载，静态变量就跟着消失 基本数据类型Java是一种强类型的语言，每个变量必须声明其数据类型，Java的数据类型可以分为量大类：基本数据类型、引用数据类型 Java中定义了3类8种数据类型 数值型 - byte short int long float double 字符型 - char 布尔型 - boolean 控制语句顺序结构、选择判断、循环结构 选择判断 生成随机1到6的数字 123456public static void main(String[] args) &#123; double d = Math.random(); //Math.random()生成一个[0 , 1)的是随机数 System.out.println(d); int a = 1+(int)(Math.random()*6); //随机生成一个0到6的随机数 System.out.println(a);&#125; 递归自己调用自己，一个递归技术的方法会直接或者是间接调用自己 12345678910111213141516public class HelloWorld &#123; public static void a()&#123; System.out.println(&quot;test.a&quot;); a(); &#125; public static void b()&#123; System.out.println(&quot;test.b&quot;); &#125; public static void main(String[] args) &#123; a(); &#125;&#125; 定义递归的时候要有结束的条件，不然会出现StackOverflowError 递归要有开始和结束才能够实现。不然会出现错误，栈溢出等状况。 面向对象 类对应的就是表格的结构，对象对应的就是表格的内容，实际上所有的数据都可以用表格来表示。数据库也是一张张的表格，“表格就是对象”。","tags":["java"]},{"title":"各大排序算法的代码","path":"/2021/12/28/各大排序算法的代码/","content":"排序算法代码下面是所有的排序算法的代码的详情，后续还会进行改进 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//排序//冒泡排序//插入排序 数组是稳定的 将一个待排序的记录，//按其关键字大小插入到前面已将排好序的子序列中//直到全部记录插入完成 // 数组打印 数组 数组中元素的个数 void print(int array[] , int n)&#123;\tprintf(&quot;数组的元素为&quot;); for(int i = 0 ; i &lt; n ; i++)&#123; printf(&quot;%d &quot; , array[i]); &#125; printf(&quot; &quot;); &#125; //打印数组的第i到j位元素 void print(int array[] , int m , int n)&#123;\tprintf(&quot;数组的元素为&quot;); for(int i = m ; i &lt;= n ; i++)&#123; printf(&quot;%d &quot; , array[i]); &#125; printf(&quot; &quot;); &#125; void print(int e)&#123; printf(&quot;%d &quot; , e); &#125;void InsertSort(int array[] , int n)&#123;\tint i,j,temp;\tfor(i = 1; i &lt; n; i++)&#123; if(array[i]&lt;array[i-1])&#123;//如果当前的元素小于全面的元素则需要将其往前移动 temp = array[i]; //存储需要移动的元素和前面元素进行比较 for(j = i-1;j&gt;=0 &amp;&amp; array[j]&gt;temp;j--)&#123;//判断元素的大小并出入在合适的位置 array[j+1] = array[j];//把大于temp的元素往后移动 &#125; array[j+1] = temp; &#125; print(array , n);\t&#125; &#125; //带有哨兵的 void InsertSort1(int array[] , int n)&#123;\tint i,j;\tfor(i = 2; i &lt;= n; i++)&#123; if(array[i]&lt;array[i-1])&#123;//如果当前的元素小于全面的元素则需要将其往前移动 array[0] = array[i]; //存储需要移动的元素和前面元素进行比较 for(j = i-1;j&gt;=0 &amp;&amp; array[j]&gt;array[0];j--)&#123;//判断元素的大小并出入在合适的位置 array[j+1] = array[j];//把大于temp的元素往后移动 &#125; array[j+1] = array[0]; &#125; print(array , n);\t&#125; &#125; //优化 折半插入排序//后续要使用到low ， 所以需要传递对应的值 int findOperstion(int array[] , int &amp;low , int high , int e)&#123;\tint mid = (low+high)/2;\tif(low &gt; high)&#123; print(low); return low;\t&#125;\tif(e &gt; array[mid])&#123; low = mid + 1; &#125;else&#123; high = mid - 1;\t&#125;\tfindOperstion(array, low ,high ,e);&#125;void InsertSort2(int array[] , int n)&#123;\tint i,j;\tfor(i = 1; i &lt; n; i++)&#123; int low = 0; int high = i - 1; int e = array[i]; int op = findOperstion(array , low , high , e); //移动 low 到 i - 1的所有的元素 for(int m = i-1 ; m &gt;= low ;m--)&#123; array[m + 1] = array[m]; &#125; print(e); array[low] = e; print(array , n);\t&#125; &#125; //希尔排序 表中元素部分有序 进而达到全局有序 //拆分为子表 d 相距为d 的看作一个子表 ， 对子表的元素进行排序//参数: 数组 数组的长度 void ShellSort(int array1[] , int n)&#123;\t//其中的array[0]为哨兵 int d , i , j; // d 为步长 i j 为循环的变量\tfor(d=n/2 ; d&gt;=1 ; d = d/2)&#123; printf(&quot;d的值为：%d &quot; , d); for(i = d+1 ; i&lt;n ; i++)&#123; if(array1[i]&lt;array1[i-d])&#123; printf(&quot;========================%d&quot; , i); array1[0] = array1[i]; for(j = i-d ; j&gt;0 &amp;&amp; array1[0] &lt; array1[j] ; j-=d)&#123; array1[j+d] = array1[j]; printf(&quot;元素%d位置移动从%d到%d &quot; ,array1[j], j , j+d); &#125; //循环结束即为对应的位置 array1[j+d] = array1[0]; &#125; &#125; print(array1 , n);\t&#125; &#125; //冒泡排序 基于交换的排序 //根据序列中的两个关键元素的比较结果来对换这两个记录的在序列中的位置 //交换a b的位置 void swap(int &amp;a , int &amp;b)&#123;\tint temp = a;\ta = b;\tb = temp; &#125; void BubbleSort(int array[] , int n)&#123;\tprint(array, 9);\tfor(int i = n - 1; i &gt; 0; i--)&#123; bool flag = false; for(int j = 0 ; j &lt; i ; j++)&#123; if(array[j]&gt;array[j+1])&#123; swap(array[j] , array[j+1]); flag = true; &#125; &#125; if(flag == false)&#123; print(array , n); return; &#125; print(array , n); &#125;&#125;//快速排序 一个中间元素确定其位置 小于 low high 大于 int partition(int array[] , int low , int high)&#123;\tint pivot = array[low];\twhile(low &lt; high)&#123; while(low &lt; high &amp;&amp; array[high] &gt;= pivot) --high; array[low] = array[high]; while(low &lt; high &amp;&amp; array[low] &lt;= pivot) ++low; array[high] = array[low];\t&#125;\tarray[low] = pivot;\treturn low;&#125; void quickSort(int array[] , int low , int high)&#123;\tif(low &lt; high)&#123; int pivotpos = partition(array , low , high);//进行划分 print(array , 8); quickSort(array , low , pivotpos - 1); print(array , 8); quickSort(array , pivotpos + 1 , high); print(array , 8); &#125;&#125;//简单选择排序 每一趟处理会在待排序元素加入有序子序列void selectSort(int array[] , int n)&#123;\tfor(int i = 0 ; i &lt; n - 1 ; i++)&#123; int min = i; for(int j = i+1; j&lt;n ; j++)&#123; if(array[j] &lt; array[min])&#123; min = j; &#125; &#125; if(min != i)&#123; swap(array[i] , array[min]); &#125; print(array , 8);\t&#125;&#125; //堆排序 大根堆和小根堆L(i) &gt;= L(2i) L(i) &gt;= L(2i+1)大根堆 ， 反之为小根堆 heap//原始数组选择为堆 建立为大根堆 所有非终端节点进行检查 不满足进行调整 i&lt;= n/2 小元素不断进行下坠void heapAdjust(int array[] , int k , int len)&#123;\tarray[0] = array[k];\tfor(int i = 2*k; i&lt;=len ; i*=2)&#123; if(i&lt;len &amp;&amp; array[i] &lt; array[i+1]) i++; if(array[0] &gt; array[i]) break; else&#123; array[k] = array[i]; k = i; &#125;\t&#125;\tarray[k] = array[0];&#125;void buildMaxHeap(int array[] , int len)&#123;\tfor(int i = len/2 ; i &gt; 0 ; i--)&#123; heapAdjust(array , i , len);\t&#125;&#125; void heapSort(int array[] , int len)&#123;\tbuildMaxHeap(array , len);\tprint(array , 9);\tfor(int i = len ; i &gt; 1; i--)&#123; swap(array[i] , array[1]); heapAdjust(array , 1 , i-1);\t&#125;\tprint(array , 9);&#125;//归并排序 把两个或者是多个有序的序列合并成为一个 二路归并就是两个来进行归并 也可以有多路归并void merge(int array[] ,int low , int mid , int high)&#123;\tprintf(&quot;归并排序============================== &quot;);\t//申请一个暂时存储数组元素的数组 int *array1 = (int *)malloc(8 * sizeof(int));\tint i ,j, k;\tfor(k = low ; k &lt;= high ; k++)&#123; array1[k] = array[k];\t&#125;\tfor(i = low , j = mid+1, k = i;i&lt;=mid &amp;&amp; j&lt;=high;k++)&#123; if(array1[i] &lt; array1[j])&#123; array[k] = array1[i]; i++; &#125;else&#123; array[k] = array1[j]; j++; &#125;\t&#125;//for循环结束 while(i &lt;= mid)&#123; array[k] = array1[i]; i++; k++;\t&#125;\twhile(j &lt;= high)&#123; array[k] = array1[j]; k++; j++;\t&#125; print(array , 9); &#125; //归并排序的具体算法 void mergeSort(int array[] , int low , int high)&#123;\tif(low &lt; high)&#123; int mid = (low + high)/2; mergeSort(array , low , mid);//对于左半部分进行排序 mergeSort(array , mid + 1 , high);//右半部分进行排序 printf(&quot;low=%d , mid = %d , high = %d &quot; , low , mid , high); merge(array , low , mid , high);//进行合并 &#125;&#125; // 基数排序 根据 个 十 百 位进行排序 //败者树 回合胜利制 int main()&#123;\t/*int array[8];\tarray[0] = 49;\tarray[1] = 38;\tarray[2] = 65;\tarray[3] = 97;\tarray[4] = 76;\tarray[5] = 13;\tarray[6] = 27;\tarray[7] = 49;\t*/\t//selectSort(array , 8);\t//quickSort(array , 0 , 7);\t//InsertSort2(array , 8);\tint array1[9];\tarray1[0] = 0; array1[1] = 49;\tarray1[2] = 38;\tarray1[3] = 65;\tarray1[4] = 97;\tarray1[5] = 76;\tarray1[6] = 13;\tarray1[7] = 27;\tarray1[8] = 49;\tprint(array1 , 9); //heapSort(array1 , 8);\tmergeSort(array1 , 0 , 8);\t//print(array1 , 9);\t//ShellSort(array1 , 9);\t//BubbleSort(array1 , 9);\t//\tint low = 0;\t//int high = 3;\t//int e = 76;\t//findOperstion(array, low ,high ,e);\t//InsertSort(array , 8);\t//带有哨兵的插入排序 //InsertSort1(array , 7);\t&#125;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//排序//冒泡排序//插入排序 数组是稳定的 将一个待排序的记录，//按其关键字大小插入到前面已将排好序的子序列中//直到全部记录插入完成 // 数组打印 数组 数组中元素的个数 void print(int array[] , int n)&#123;\tprintf(&quot;数组的元素为&quot;); for(int i = 0 ; i &lt; n ; i++)&#123; printf(&quot;%d &quot; , array[i]); &#125; printf(&quot; &quot;); &#125; //打印数组的第i到j位元素 void print(int array[] , int m , int n)&#123;\tprintf(&quot;数组的元素为&quot;); for(int i = m ; i &lt;= n ; i++)&#123; printf(&quot;%d &quot; , array[i]); &#125; printf(&quot; &quot;); &#125; void print(int e)&#123; printf(&quot;%d &quot; , e); &#125;void InsertSort(int array[] , int n)&#123;\tint i,j,temp;\tfor(i = 1; i &lt; n; i++)&#123; if(array[i]&lt;array[i-1])&#123;//如果当前的元素小于全面的元素则需要将其往前移动 temp = array[i]; //存储需要移动的元素和前面元素进行比较 for(j = i-1;j&gt;=0 &amp;&amp; array[j]&gt;temp;j--)&#123;//判断元素的大小并出入在合适的位置 array[j+1] = array[j];//把大于temp的元素往后移动 &#125; array[j+1] = temp; &#125; print(array , n);\t&#125; &#125; //带有哨兵的 void InsertSort1(int array[] , int n)&#123;\tint i,j;\tfor(i = 2; i &lt;= n; i++)&#123; if(array[i]&lt;array[i-1])&#123;//如果当前的元素小于全面的元素则需要将其往前移动 array[0] = array[i]; //存储需要移动的元素和前面元素进行比较 for(j = i-1;j&gt;=0 &amp;&amp; array[j]&gt;array[0];j--)&#123;//判断元素的大小并出入在合适的位置 array[j+1] = array[j];//把大于temp的元素往后移动 &#125; array[j+1] = array[0]; &#125; print(array , n);\t&#125; &#125; //优化 折半插入排序//后续要使用到low ， 所以需要传递对应的值 int findOperstion(int array[] , int &amp;low , int high , int e)&#123;\tint mid = (low+high)/2;\tif(low &gt; high)&#123; print(low); return low;\t&#125;\tif(e &gt; array[mid])&#123; low = mid + 1; &#125;else&#123; high = mid - 1;\t&#125;\tfindOperstion(array, low ,high ,e);&#125;void InsertSort2(int array[] , int n)&#123;\tint i,j;\tfor(i = 1; i &lt; n; i++)&#123; int low = 0; int high = i - 1; int e = array[i]; int op = findOperstion(array , low , high , e); //移动 low 到 i - 1的所有的元素 for(int m = i-1 ; m &gt;= low ;m--)&#123; array[m + 1] = array[m]; &#125; print(e); array[low] = e; print(array , n);\t&#125; &#125; //希尔排序 表中元素部分有序 进而达到全局有序 //拆分为子表 d 相距为d 的看作一个子表 ， 对子表的元素进行排序//参数: 数组 数组的长度 void ShellSort(int array1[] , int n)&#123;\t//其中的array[0]为哨兵 int d , i , j; // d 为步长 i j 为循环的变量\tfor(d=n/2 ; d&gt;=1 ; d = d/2)&#123; printf(&quot;d的值为：%d &quot; , d); for(i = d+1 ; i&lt;n ; i++)&#123; if(array1[i]&lt;array1[i-d])&#123; printf(&quot;========================%d&quot; , i); array1[0] = array1[i]; for(j = i-d ; j&gt;0 &amp;&amp; array1[0] &lt; array1[j] ; j-=d)&#123; array1[j+d] = array1[j]; printf(&quot;元素%d位置移动从%d到%d &quot; ,array1[j], j , j+d); &#125; //循环结束即为对应的位置 array1[j+d] = array1[0]; &#125; &#125; print(array1 , n);\t&#125; &#125; //冒泡排序 基于交换的排序 //根据序列中的两个关键元素的比较结果来对换这两个记录的在序列中的位置 //交换a b的位置 void swap(int &amp;a , int &amp;b)&#123;\tint temp = a;\ta = b;\tb = temp; &#125; void BubbleSort(int array[] , int n)&#123;\tprint(array, 9);\tfor(int i = n - 1; i &gt; 0; i--)&#123; bool flag = false; for(int j = 0 ; j &lt; i ; j++)&#123; if(array[j]&gt;array[j+1])&#123; swap(array[j] , array[j+1]); flag = true; &#125; &#125; if(flag == false)&#123; print(array , n); return; &#125; print(array , n); &#125;&#125;//快速排序 一个中间元素确定其位置 小于 low high 大于 int partition(int array[] , int low , int high)&#123;\tint pivot = array[low];\twhile(low &lt; high)&#123; while(low &lt; high &amp;&amp; array[high] &gt;= pivot) --high; array[low] = array[high]; while(low &lt; high &amp;&amp; array[low] &lt;= pivot) ++low; array[high] = array[low];\t&#125;\tarray[low] = pivot;\treturn low;&#125; void quickSort(int array[] , int low , int high)&#123;\tif(low &lt; high)&#123; int pivotpos = partition(array , low , high);//进行划分 print(array , 8); quickSort(array , low , pivotpos - 1); print(array , 8); quickSort(array , pivotpos + 1 , high); print(array , 8); &#125;&#125;//简单选择排序 每一趟处理会在待排序元素加入有序子序列void selectSort(int array[] , int n)&#123;\tfor(int i = 0 ; i &lt; n - 1 ; i++)&#123; int min = i; for(int j = i+1; j&lt;n ; j++)&#123; if(array[j] &lt; array[min])&#123; min = j; &#125; &#125; if(min != i)&#123; swap(array[i] , array[min]); &#125; print(array , 8);\t&#125;&#125; //堆排序 大根堆和小根堆L(i) &gt;= L(2i) L(i) &gt;= L(2i+1)大根堆 ， 反之为小根堆 heap//原始数组选择为堆 建立为大根堆 所有非终端节点进行检查 不满足进行调整 i&lt;= n/2 小元素不断进行下坠void heapAdjust(int array[] , int k , int len)&#123;\tarray[0] = array[k];\tfor(int i = 2*k; i&lt;=len ; i*=2)&#123; if(i&lt;len &amp;&amp; array[i] &lt; array[i+1]) i++; if(array[0] &gt; array[i]) break; else&#123; array[k] = array[i]; k = i; &#125;\t&#125;\tarray[k] = array[0];&#125;void buildMaxHeap(int array[] , int len)&#123;\tfor(int i = len/2 ; i &gt; 0 ; i--)&#123; heapAdjust(array , i , len);\t&#125;&#125; void heapSort(int array[] , int len)&#123;\tbuildMaxHeap(array , len);\tprint(array , 9);\tfor(int i = len ; i &gt; 1; i--)&#123; swap(array[i] , array[1]); heapAdjust(array , 1 , i-1);\t&#125;\tprint(array , 9);&#125;//归并排序 把两个或者是多个有序的序列合并成为一个 二路归并就是两个来进行归并 也可以有多路归并void merge(int array[] ,int low , int mid , int high)&#123;\tprintf(&quot;归并排序============================== &quot;);\t//申请一个暂时存储数组元素的数组 int *array1 = (int *)malloc(8 * sizeof(int));\tint i ,j, k;\tfor(k = low ; k &lt;= high ; k++)&#123; array1[k] = array[k];\t&#125;\tfor(i = low , j = mid+1, k = i;i&lt;=mid &amp;&amp; j&lt;=high;k++)&#123; if(array1[i] &lt; array1[j])&#123; array[k] = array1[i]; i++; &#125;else&#123; array[k] = array1[j]; j++; &#125;\t&#125;//for循环结束 while(i &lt;= mid)&#123; array[k] = array1[i]; i++; k++;\t&#125;\twhile(j &lt;= high)&#123; array[k] = array1[j]; k++; j++;\t&#125; print(array , 9); &#125; //归并排序的具体算法 void mergeSort(int array[] , int low , int high)&#123;\tif(low &lt; high)&#123; int mid = (low + high)/2; mergeSort(array , low , mid);//对于左半部分进行排序 mergeSort(array , mid + 1 , high);//右半部分进行排序 printf(&quot;low=%d , mid = %d , high = %d &quot; , low , mid , high); merge(array , low , mid , high);//进行合并 &#125;&#125; // 基数排序 根据 个 十 百 位进行排序 //败者树 回合胜利制 int main()&#123;\t/*int array[8];\tarray[0] = 49;\tarray[1] = 38;\tarray[2] = 65;\tarray[3] = 97;\tarray[4] = 76;\tarray[5] = 13;\tarray[6] = 27;\tarray[7] = 49;\t*/\t//selectSort(array , 8);\t//quickSort(array , 0 , 7);\t//InsertSort2(array , 8);\tint array1[9];\tarray1[0] = 0; array1[1] = 49;\tarray1[2] = 38;\tarray1[3] = 65;\tarray1[4] = 97;\tarray1[5] = 76;\tarray1[6] = 13;\tarray1[7] = 27;\tarray1[8] = 49;\tprint(array1 , 9); //heapSort(array1 , 8);\tmergeSort(array1 , 0 , 8);\t//print(array1 , 9);\t//ShellSort(array1 , 9);\t//BubbleSort(array1 , 9);\t//\tint low = 0;\t//int high = 3;\t//int e = 76;\t//findOperstion(array, low ,high ,e);\t//InsertSort(array , 8);\t//带有哨兵的插入排序 //InsertSort1(array , 7);\t&#125;","tags":["算法"]},{"title":"hexo的写作问题","path":"/2021/12/27/hexo的写作问题/","content":"关于hexo的使用的基本的命令问题在经历了考研之后的第一天，开始重新进行代码的学习，不知道考不考的上，好多的编程知识也忘记了很多，今天开始进行一步一步的回忆，进行慢慢的学习，也只能慢慢学习，年后可能直接要找工作了，希望能够上岸，关于考研这个事情，能考就考，我身边一个快手的朋友，在快手干了半年之后，重新把工作辞了进行考研，这是贴身的经历。希望能够上岸。 创建hexo的博客在创建的时候是有选择的，可以进行三种方式的创建，post、page和draft，存储的路径如下面的图所示。 创建命令 12hexo new [layout] &lt;title&gt; ## layout就是上面的三种方式的布局，我们在进行的时候 ## 这里不知道为啥，我的直接全部都出现在了第一个也就是默认的里面了 下面的就是我创建好的本篇博客的题目 创建完成之后可以用任何你本地的软件打开，形成自己独特的风格，这里我比较喜欢的是typora，现在可能会进行收费了，但是之前是不进行收费的，我的还是之前的版本，你也可以下载以前的版本进行使用，打开这些md的文件进行自己的编写。从下面也可以看到以前写的博客题目，具体的如下图所示。 生成并上传对应的博客生成hexo对应的文件并上传到gitee上面可以通过具体的域名进行访问。 123hexo g ## 这个是对应的生成文件的代码 generate 生成 hexo d ## 这个是上传到gitee上的命令 delivery 传送 更新gitee并访问博客在经过上面的命令之后，每次需要进行手动的更新之后，才能够进行访问。如下图，进行强制的更新。 在更新之后就可以进行访问了。输入自己的对应gitee的域名就可以进行访问了，这个所有的都是不需要进行收费的。 发表一下我现在的感受就是，冷，由于家里没有暖气，今天就写到这了，没有办法，家在乡下。","tags":["hexo"]},{"title":"答辩记录","path":"/2021/06/07/答辩记录/","content":"基于SpringBoot的超市管理系统，但求今天能够，不求高分，六十足以。 今天的运气还是很好的，主要是答辩的时候张老师这个系主任不在，后面的几个都被问了好多的问题，突然感觉我还是比较幸运的。希望能够一直幸运！！！","tags":["心情小记"]},{"title":"阿里云服务器端口配置","path":"/2021/05/23/阿里云服务器端口配置/","content":"阿里云服务器端口控制台开放 查看已经开放的端口 123firewall-cmd --list-portsiptables -I INPUT -p tcp --dport 20003 -j ACCEPTfirewall-cmd --zone=public --add-port=20003/tcp --permanent 防火墙配置 1234firewall-cmd --reloadsystemctl start firewalld # 开启防火墙systemctl status firewalld # 查看防火墙的状态systemctl stop firewalld # 关闭防火墙 测试上传测试上传22222 测试上传github","tags":["服务器"]},{"title":"服务器安装node","path":"/2021/05/23/服务器安装node/","content":"安装依赖包epel 1yum install -y epel-release 安装nodejs 1yum install -y nodejs 测试是否安装成功： 1234[root@iZm5e7hnl9pp144h2hvqmzZ environment]# node -vv6.17.1[root@iZm5e7hnl9pp144h2hvqmzZ environment]# npm -v3.10.10","tags":["服务器"]},{"title":"axios的params和data的区别","path":"/2021/05/13/axios的params和data的区别/","content":"params和data的区别就是你后端接受参数是的状态，是requestbody还是实体类的方式，如果是实体类，那么就是params参数的形式，不然的话就是data的格式 下面的是参数params 下面的是参数data","tags":["小技巧"]},{"title":"支付宝支付对接","path":"/2021/04/23/支付宝支付对接课程/","content":"支付宝支付对接支付整体流程支付核心所需的参数 APPID 商家私钥 支付宝公钥 支付回调地址 网关地址 加密签名算法RSA2 支付宝开放平台官网：https://open.alipay.com/platform/home.htm 文档： 支付应用场景使用第三方支付宝支付，解决了商家，消费者之间的交易瓶颈，提升商家的服务效率和营收，也可以让消费者在消费产品的时候更加快捷和便捷，使用场景如下：","tags":["微信支付","支付宝支付"]},{"title":"四大函数式接口","path":"/2021/04/17/四大函数式接口/","content":"四大函数式接口新时代的程序员 ， 必须要会的操作 lambda表达式 ， 链式编程 ， 函数式接口 ， Stream流式计算 函数式接口是什么东西？只有一个方法的接口 123456789@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125;//会有很多的FunctionalInterface//简化编程模型 ， 在新版本的框架 ， 底层大量应用//消费者类的函数式接口public void forEach(Consumer&lt;? super E&gt; action) 代码测试：Function函数式接口 12345678910111213141516171819202122232425import java.util.function.Consumer;import java.util.function.Function;/** * Function * 有一个输入参数 ， 有一个输出 */public class Test01 &#123; public static void main(String[] args) &#123;// // 输出输入的值// Function function = new Function&lt;String , String&gt;() &#123;// @Override// public String apply(String str) &#123;// return str;// &#125;// &#125;;//// System.out.println(function.apply(&quot;123&quot;)); Function function = (str) -&gt; &#123; return &quot;123&quot;; &#125;; System.out.println(function.apply(&quot;123&quot;)); &#125;&#125; Predict断定性接口 123456789101112131415161718import java.util.function.Predicate;public class Test02 &#123; public static void main(String[] args) &#123;// Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;()&#123;// //判断字符串是够为空// @Override// public boolean test(String str) &#123;// return str.isEmpty();// &#125;// &#125;; Predicate&lt;String&gt; predicate = (str)-&gt;&#123; return str.isEmpty(); &#125;; System.out.println(predicate.test(&quot;123&quot;)); &#125;&#125; Consumer 消费型接口 123456789101112131415161718192021import java.util.function.Consumer;/** * Consumer 消费型接口 只有输入 ， 没有返回值 */public class Test03 &#123; public static void main(String[] args) &#123;// Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;()&#123;// @Override// public void accept(String str) &#123;// System.out.println(str);// &#125;// &#125;; Consumer&lt;String&gt; consumer = (str)-&gt;&#123; System.out.println(str); &#125;; consumer.accept(&quot;123212&quot;); &#125;&#125; 可以打印字符串 supplier供给型接口 12345678910111213141516import java.util.function.Supplier;public class Test04 &#123; public static void main(String[] args) &#123;// Supplier supplier = new Supplier&lt;Integer&gt;()&#123;// @Override// public Integer get() &#123;// return 1024;// &#125;// &#125;; Supplier supplier = ()-&gt;&#123; return 1024; &#125;; System.out.println(supplier.get()); &#125;&#125;","tags":["多线程"]},{"title":"线程池","path":"/2021/04/16/线程池/","content":"线程池池化技术程序的运行，本质： 占用系统资源！！优化资源的使用，每次在创建线程和销毁的时候都会耗费大量资源–》 池化技术 线程池、连接池、存储池、对象池、jdbc 最大的，最小的 会不停的进行开和关 池化技术： 实现准备好一些资源 ， 有人使用的话就去拿 ， 用完之后再放进池里面 默认是： 2 max 根据电脑去设置 cpu和io密集型的 线程池的好处： 降低资源的消耗 提高响应的速度 方便进行管理 线程池可以复用，可以控制最大的并发数 ， 可以控制我们的线程 线程池三大方法、七大参数、四种拒绝策略 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，避免资源耗尽的风险，说明： Executors返回的线程池对象的弊端如下： FixedThreadPool和SingleThreadPool允许请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM CacheThreadPool和ScheduleThreadPool允许创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，导致OOM 三大方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Executors * 使用了线程池之后， 要使用线程池创建 */public class Test01 &#123; public static void main(String[] args) &#123;// ExecutorService executorService = Executors.newSingleThreadExecutor();//创建单个线程 ExecutorService executorService = Executors.newFixedThreadPool(5);//创建一个固定数量的线程池// ExecutorService executorService = Executors.newCachedThreadPool();//遇强则强 ， 遇弱则弱 try &#123; for (int i = 1; i &lt;= 100; i++) &#123; executorService.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;ok&quot;); &#125;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; executorService.shutdown(); &#125; &#125;&#125;//newSingleThreadExecutorpublic static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;//newFixedThreadPoolpublic static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;//newCachedThreadPoolpublic static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;//本质：ThreadPoolExecutorpublic ThreadPoolExecutor(int corePoolSize, //核心线程池带下 int maximumPoolSize,//最大的线程池大小 long keepAliveTime,//超时没有人调用就会释放 TimeUnit unit,//超时的单位 BlockingQueue&lt;Runnable&gt; workQueue,// 阻塞队列 ThreadFactory threadFactory, // 线程工厂 创建线程的 一般不用动 RejectedExecutionHandler handler // 拒绝策略 ) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 七大参数和四种拒绝策略1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.concurrent.Executors;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Test2 &#123; public static void main(String[] args) &#123; /** * 自定义线程池 */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 5, 3, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(3), Executors.defaultThreadFactory(),// new ThreadPoolExecutor.CallerRunsPolicy()//那来的去哪里// new ThreadPoolExecutor.AbortPolicy() // 银行满了 ， 还有人进来 如果队列满了 ， 还有人进来 ， 就抛出异常// new ThreadPoolExecutor.DiscardOldestPolicy() // 队列满了 ， 不会抛出异常 ， 丢掉任务 new ThreadPoolExecutor.DiscardOldestPolicy() // 和第一个尝试竞争 ， 如果成功就会执行 ， 不成功就会丢掉 ， 不会抛出异常 ); /** * 测试 */ try &#123; // 最大 ： Deque + max //超过 java.util.concurrent.RejectedExecutionException 会跑出异常 for (int i = 1; i &lt;= 9; i++) &#123; threadPoolExecutor.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;ok&quot;); &#125;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; threadPoolExecutor.shutdown(); &#125; &#125;&#125; 小结和拓展：最大线程池如何去定义： cpu密集型 4 核 4条线程同时执行 几核的cpu就定义为几 可以保证cpu的效率最高Runtime.getRuntime().availableProcessors() IO密集型 程序 15个大型任务 ， IO十分占用系统资源 ， 至少留15个线程 判断程序中十分消耗IO的线程有多少个 ， 大于这个数就行 ， 一般设置为两倍 ， 不会造成系统的阻塞","tags":["多线程"]},{"title":"阻塞队列","path":"/2021/04/15/阻塞队列/","content":"阻塞队列 BlockingQueue: 阻塞队列 ， 不是新的东西 什么情况下，我们会使用阻塞队列？？？ 多线程 线程池并发处理 学会使用对垒： 添加 移除 四组常用的API 抛出异常 不会抛出异常 阻塞等待 超时等待 方式 抛出异常 有返回值不抛出异常 阻塞等待 超时等待 添加 add offer put offer带参数 移除 remove poll take poll带参数 检测队首元素 element peek 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.TimeUnit;public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; test3(); &#125; /** * 抛出异常 */ public static void test()&#123; //队列的大小 ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(arrayBlockingQueue.add(&quot;a&quot;)); System.out.println(arrayBlockingQueue.add(&quot;b&quot;)); System.out.println(arrayBlockingQueue.add(&quot;c&quot;)); System.out.println(&quot;-------------------------&quot;); System.out.println(arrayBlockingQueue.element());// System.out.println(arrayBlockingQueue.add(&quot;d&quot;)); System.out.println(arrayBlockingQueue.remove()); System.out.println(arrayBlockingQueue.remove()); System.out.println(arrayBlockingQueue.remove()); System.out.println(arrayBlockingQueue.remove()); &#125; /** * 有返回值 但是不抛出异常 */ public static void test1() &#123; //队列的大小 ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(arrayBlockingQueue.offer(&quot;a&quot;)); System.out.println(arrayBlockingQueue.offer(&quot;b&quot;)); System.out.println(arrayBlockingQueue.offer(&quot;c&quot;));// System.out.println(arrayBlockingQueue.offer(&quot;d&quot;)); System.out.println(arrayBlockingQueue.peek()); //返回队首的元素 System.out.println(arrayBlockingQueue.poll()); System.out.println(arrayBlockingQueue.poll()); System.out.println(arrayBlockingQueue.poll()); System.out.println(arrayBlockingQueue.poll()); // null 不抛出异常 &#125; /** * 等待阻塞 * 一直 * 等待超时 */ public static void test2() throws InterruptedException &#123; //队列的大小 ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3); // 一直阻塞 arrayBlockingQueue.put(&quot;a&quot;); arrayBlockingQueue.put(&quot;b&quot;); arrayBlockingQueue.put(&quot;c&quot;);// arrayBlockingQueue.put(&quot;d&quot;);//队列没有位置了会一直等待 一直阻塞 下面会一直等待 System.out.println(arrayBlockingQueue.take()); System.out.println(arrayBlockingQueue.take()); System.out.println(arrayBlockingQueue.take()); &#125; /** * 超时退出 */ public static void test3() throws InterruptedException &#123; //队列的大小 ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(arrayBlockingQueue.offer(&quot;a&quot;)); System.out.println(arrayBlockingQueue.offer(&quot;b&quot;)); System.out.println(arrayBlockingQueue.offer(&quot;c&quot;)); System.out.println(arrayBlockingQueue.offer(&quot;d&quot; , 2 , TimeUnit.SECONDS));//超过2秒直接返回没有加入false System.out.println(arrayBlockingQueue.poll(2, TimeUnit.SECONDS)); System.out.println(arrayBlockingQueue.poll(2, TimeUnit.SECONDS)); System.out.println(arrayBlockingQueue.poll(2, TimeUnit.SECONDS)); System.out.println(arrayBlockingQueue.poll(2, TimeUnit.SECONDS));//超时直接返回null &#125;&#125; SynchronousQueue&lt;E&gt; 进去一个元素 必须取出来然后再在里面放置元素 123456789101112131415161718192021222324252627282930313233343536import java.util.concurrent.SynchronousQueue;/** * 同步队列的测试 */public class SynchronousQueueTest &#123; public static void main(String[] args) &#123; /** * 和其他的是不一样的 ， 我们这个是不存储元素的 只要put 一个元素 ， 必须从里面先取出来一个元素，否则 不能再加入元素 */ SynchronousQueue synchronousQueue = new SynchronousQueue&lt;String&gt;(); //同步队列 //放入值 new Thread(()-&gt;&#123; try &#123; System.out.println(Thread.currentThread().getName()+&quot;put 1&quot;); synchronousQueue.put(&quot;1&quot;); System.out.println(Thread.currentThread().getName()+&quot;put 1&quot;); synchronousQueue.put(&quot;2&quot;); System.out.println(Thread.currentThread().getName()+&quot;put 1&quot;); synchronousQueue.put(&quot;3&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; , &quot;t1&quot;).start(); //取出值 new Thread(()-&gt;&#123; try &#123; System.out.println(Thread.currentThread().getName()+&quot;====&quot;+synchronousQueue.take()); System.out.println(Thread.currentThread().getName()+&quot;====&quot;+synchronousQueue.take()); System.out.println(Thread.currentThread().getName()+&quot;====&quot;+synchronousQueue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; , &quot;t2&quot;).start(); &#125;&#125;","tags":["多线程","阻塞队列"]},{"title":"读写锁","path":"/2021/04/15/读写锁/","content":"读写锁ReadWriteLock 读：可以被多个线程同时读 写： 只能有一个线程去写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * 独占锁 写锁 一次只能被一个线程使用 * 共享锁 读锁 一次可以被多个线程进行读写的 * ReadWriteLock * 读 - 写 不能共存 * 读 - 读 可以共存 * 写 - 写 不能共存 */public class ReadWriteLockTest &#123; public static void main(String[] args) &#123; MyCache myCache = new MyCache(); //写入 for (int i = 1; i &lt;= 5; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; myCache.put(temp+&quot;&quot; , temp+&quot;&quot;); &#125; , String.valueOf(i)).start(); &#125; //读取 for (int i = 1; i &lt;= 5; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; myCache.get(temp+&quot;&quot;); &#125; , String.valueOf(i)).start(); &#125; &#125;&#125;class MyCache1&#123; private volatile Map&lt;String , Object&gt; map = new HashMap&lt;&gt;(); //存 public void put(String key, Object value)&#123; System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key); map.put(key , value); System.out.println(Thread.currentThread().getName() + &quot;写入ok&quot;); &#125; //取 public void get(String key)&#123; System.out.println(Thread.currentThread().getName() + &quot;读出&quot; + key); map.get(key); System.out.println(Thread.currentThread().getName() + &quot;读出ok&quot;); &#125;&#125;/** * 加锁 */class MyCache&#123; private volatile Map&lt;String , Object&gt; map = new HashMap&lt;&gt;(); //读写锁 相当于是更加细粒度的操作 private ReadWriteLock readWriteLock= new ReentrantReadWriteLock(); //存 public void put(String key, Object value)&#123; try &#123; readWriteLock.writeLock().lock(); System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key); map.put(key , value); System.out.println(Thread.currentThread().getName() + &quot;写入ok&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; readWriteLock.writeLock().unlock(); &#125; &#125; //取 public void get(String key)&#123; try &#123; readWriteLock.readLock().lock(); System.out.println(Thread.currentThread().getName() + &quot;读出&quot; + key); map.get(key); System.out.println(Thread.currentThread().getName() + &quot;读出ok&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; readWriteLock.readLock().unlock(); &#125; &#125;&#125;","tags":["多线程","锁"]},{"title":"多线程之常用的辅助类","path":"/2021/04/14/多线程之常用的辅助类/","content":"多线程之常用的辅助类 CountDownLatch允许一个或多个线程等待直到其他线程中执行的一组操作完成的同步辅助 123456789101112131415161718192021import java.util.concurrent.CountDownLatch;//技术器public class CountDownLatchTest &#123; public static void main(String[] args) throws InterruptedException &#123; //总数是6 倒计时 //必须要执行任务的时候用这个 CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i &lt;= 6; i++) &#123; new Thread(()-&gt;&#123; countDownLatch.countDown(); // -1 System.out.println(Thread.currentThread().getName()+&quot;走了！！！&quot;); &#125;).start(); &#125; countDownLatch.await(); //等待计数器归0 然后向下执行 System.out.println(&quot;关门！！！！&quot;); &#125;&#125; 也就是说，上面的是等待一个计数器直到为0的时候才会进行的执行下面的操作。 原理 countDownLatch.countDown();也就是说这个执行的是-1的操作 countDownLatch.await(); 等待计数器归0的操作，然后向下执行，就像学校里的人一样，必须等待最后一个走了之后才会进行关门。 每次线程调用countDown的时候计数器会减一，假设计数器变为0，await的操作才会进行下面的操作也就是向下执行 CyclicBarrier 加法计数器允许一组线程等待彼此到达共同的障碍点的同步辅助。循环阻塞在设计固定大小的线程的程序中很有用，这些线程必须偶尔等待彼此。屏障成为循环，因为它在等待的线程被释放之后重新使用。 12345678910111213141516171819202122232425262728package com.timous.add;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierTest &#123; /** * 集齐7个龙珠 然后完成任务 */ public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123; System.out.println(&quot;成功&quot;); &#125;); for (int i = 1; i &lt;= 7; i++) &#123; //lambda能不能操作到变量 i 不能 通过 final 来进行获取 final int temp = i; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + &quot;收集了&quot; +temp+&quot;颗龙珠&quot;); //这个时候回报错 try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;,&quot;A&quot;).start(); &#125; &#125;&#125; SemaPhore 抢车位： 6 辆车 3个车位 1234567891011121314151617181920212223242526272829import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;public class SemaPhoreTest &#123; public static void main(String[] args) &#123; //线程数量 停车位 Semaphore semaphore = new Semaphore(3); for (int i = 1; i &lt;= 6; i++) &#123; /** * acquire() 得到 * release() 释放 */ new Thread(()-&gt;&#123; try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName()+&quot;得到了车位&quot;); TimeUnit.SECONDS.sleep(2); System.out.println(Thread.currentThread().getName()+&quot;离开了车位&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; semaphore.release(); &#125; &#125; , String.valueOf(i)).start(); &#125; &#125;&#125; semaphore.acquire();得到，已经满足，等待被释放 -1 semaphore.release();释放，会将当前信号量+1 ， 然后唤醒等待的操作 作用： 多个共享资源互斥的使用，控制最大的线程数","tags":["多线程"]},{"title":"线程之Callable接口","path":"/2021/04/14/线程之Callable接口/","content":"Callable 特点： 可以有返回值 可以抛出异常 方法不同 run是普通的Runnable 这个是call 关系 代码实现12345678910111213141516171819202122232425262728293031323334353637package com.timous.Callable;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //这种方式不要用了// new Thread(new MyThread()).start();// new Thread().start(); //怎么启动callable MyThread myThread = new MyThread(); //适配类 FutureTask futureTask = new FutureTask(myThread); //会打印几个call 结果会被缓存 也就是直接 去打印一次 第二次就在缓存里面了 new Thread(futureTask , &quot;A&quot;).start(); new Thread(futureTask , &quot;B&quot;).start(); Integer o = (Integer) futureTask.get(); //返回callable的结果 //get方法可能会产生阻塞 把它放大最后 或者使用异步通信 System.out.println(o); &#125;&#125;//class MyThread implements Runnable&#123;////// @Override// public void run() &#123;//// &#125;//&#125;class MyThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(&quot;call()&quot;); return 1024; &#125;&#125; 通过这样的方式就可以进行Callable的使用了 细节 可能有缓存 结果可能需要等待，阻塞","tags":["多线程"]},{"title":"锁之集合类的安全性","path":"/2021/04/14/锁之集合类的安全性/","content":"锁之集合类的安全性List集合不安全 12345678910111213141516171819202122232425262728293031323334353637package com.timous.unsafe;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.UUID;import java.util.concurrent.CopyOnWriteArrayList;/** * java.util.ConcurrentModificationException 并发修改异常 * 并发下arraylist是不安全的 解决方案 Vector 默认就是安全的 synchronized 解决 * 1. List&lt;String&gt; list = new Vector&lt;&gt;(); 就不会报错了 不要回答这个 @since JDK1.0 * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); * 3. List&lt;String&gt; list = new CopyOnWriteArrayList(); * CopyOnWriteArrayList 比 Vector 好在哪里 Vector 是synchronized 的 所以效率会比较低 */public class ListTest &#123; public static void main(String[] args) &#123;/* List&lt;String&gt; lists = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;); lists.forEach(System.out::println);*/ //collections // CopyOnWrite 写入时复制 COW 计算机程序设计领域的一种优化策略 //多个线程调用的时候 ， list是唯一的 读取的是一个固定的 ， 写入的时候可能会出现覆盖的操作 //写入的时候避免覆盖造成数据问题 写入的时候 复制出来 写完之后吧它set回去 //读写分离 mycat 这些都是读些分离的出来 List&lt;String&gt; list = new CopyOnWriteArrayList(); for (int i = 1; i &lt;= 10; i++) &#123;// list.add(UUID.randomUUID().toString().substring(0,5));// System.out.println(list); new Thread(()-&gt;&#123; list.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(list); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 从结果的时候可以看出来，在使用的时候回出现java.util.ConcurrentModificationException ，也就是并发修改异常，并发下的集合是不安全的，arraylist是不安全的，我们可以使用 Vector来进行集合类，它是线程安全的，它是采用synchronized进行的线程安全的修改的。还有我们也可以使用 List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());来进行arraylist集合的线程安全的进行线程安全的转化。也就是collection。synchronizedList的转化。还可以使用List&lt;String&gt; list = new CopyOnWriteArrayList();进行ArrayList的线程安全的转化。Vector是synchronized的进行锁的，所以效率是比较低的。CopyOnWriteArrayList采用的是ReentrantLock锁进行的，所以效率是比较高的。 Set不安全 12345678910111213141516171819202122232425262728package com.timous.unsafe;import java.util.Collections;import java.util.HashSet;import java.util.Set;import java.util.UUID;import java.util.concurrent.CopyOnWriteArraySet;/** * 同理可证 java.util.ConcurrentModificationException 并发修改异常 * Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); * Set&lt;String&gt; set = new CopyOnWriteArraySet(); */public class SetTest &#123; public static void main(String[] args) &#123; //Set&lt;String&gt; set = new HashSet&lt;&gt;();// Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); Set&lt;String&gt; set = new CopyOnWriteArraySet(); for (int i = 1; i &lt;= 30; i++) &#123; new Thread(()-&gt;&#123; set.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(set); &#125; , String.valueOf(i)).start(); &#125; &#125;&#125; hashset的底层是啥HashMap ， 就是用了hashmap的key 1234//set的本质是 map 的 key是无法重复的 PRESENT 是一个固定的数值public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; Map不安全 12345678910111213141516171819202122232425262728293031323334package com.timous.unsafe;import java.util.Collections;import java.util.HashMap;import java.util.Map;import java.util.UUID;import java.util.concurrent.ConcurrentHashMap;/** * static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 * 16 默认的容量 是通过位运算来进行的 *static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; * 最大的容量 也是通过位运算来进行的 *static final float DEFAULT_LOAD_FACTOR = 0.75f; * 加载因子 ， 默认是0.75 * * java.util.ConcurrentModificationException 依然会出现并发安修改异常 企业的开发一般都是有并发问题的 * 1. Map&lt;String, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;()); * 2. Map&lt;String, Object&gt; map = new ConcurrentHashMap&lt;&gt;(); */public class MapTest &#123; public static void main(String[] args) &#123; //map是这样用的吗 默认等价于什么 //工作中不用这个 默认的是原始的参数 0.75 默认的加载因子 16// Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();// Map&lt;String, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;()); Map&lt;String, Object&gt; map = new ConcurrentHashMap&lt;&gt;(); //加载因子 初始化容量 for (int i = 1; i &lt;= 30; i++) &#123; new Thread(()-&gt;&#123; map.put(Thread.currentThread().getName() , UUID.randomUUID().toString().substring(0 ,5)); System.out.println(map); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 前面的set和list的都是一样的，map的是concurrenthashmap来保证线程安全的。","tags":["多线程","锁"]},{"title":"Nginx安装及配置详解","path":"/2021/04/13/Nginx安装及配置详解/","content":"Nginx安装及配置详解Nginx内容介绍1.基本概念 nginx是什么，做什么事情 反向代理 负载均衡 动静分离 2.nginx安装和常用命令和配置文件 在linux系统中安装nginx nginx常用命令 nginx配置文件 3.nginx的配置实例 反向代理 4.nginx的配置实例 负载均衡 5.nginx配置实例 动静分离 6.nginx配置高可用的集群 7.nginx原理 Nginx简介什么是nginx ， 占有内存少，并发能力强 Nginx作为web服务器Nginx可以作为静态页面的web服务器 ， 同时还支持CGI协议的动态语言 ， 比如 perl 、 php等。但是不支持java。java程序只能通过与tomcat配合完成 。Nginx专门为性能优化而开发 ， 性能是其重要考量 ， 实现上非常注重效率 ， 能经受高负载的考验，有报告表名支持高达50000个并发连接数。 https://lnmp.org/nginx.html 反向代理正向代理： Nginx不仅可以做反向代理 ， 实现负载均衡，还能用作正向代理来进行上网等功能。正向代理：如果把局域网外的internent想象成一个巨大的资源库 ， 则局域网中的客户端要访问internent，则需要通过代理服务器进行访问，这种代理服务成为正向代理。 反向代理：其实客户端对代理是无感知的，因为客户端不需要任何配置就能访问，我们只需要将请求发送到发现代理服务器，由反向代理服务器去选择目标服务器获取数据之后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器暴露的是代理服务器地址，隐藏的是真实服务器ip地址 负载均衡客户端发送多个请求到服务器，服务器处理请求 ， 有一些可能要与数据库进行交互 ， 服务器处理完毕之后，在将结果返回给客户端。 这种结构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较合适的，成本以比较低。但是伴随着信息数量的不断增长，访问量和数据的飞速增长，以及系统业务的复杂度的增加，这种架构会造成服务器响应给客户端的请求日益缓慢，&#x3D;&#x3D;并发量&#x3D;&#x3D;特别大的时候，还容易造成服务器直接崩溃。很明显，这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？ 我们首先想到的可能是升级服务器的配置，比如提高cpu执行效率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效问题，硬件的性能提升已经不能满足日益增长的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是及其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都不能够满足需求，该怎么办？ 上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器 的数量，然后将请求分发到各个服务器上，将原先的请求先集中到单个服务器上的情况改为将请求发送到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 ， 一般的项目都实现负载均衡 动静分离为了加快网站的解析速度，可以把静态页面和动页面由不同的服务器来进行解析，加快解析的速度，降低原来单个服务器的压力。 Nginx在linux系统的安装1.使用远程连接工具连接 2.安装相关的依赖 安装pcre 123456789# 解压文件tar -xvf pcre-8.00.tar.gz# 编译检查文件cd pcre-8.00./configure# 安装make &amp;&amp; make install# 查看安装pcre版本pcre-config --version 下载地址：https://ftp.pcre.org/pub/pcre/ 解压文件 安装openssl zlib等其他依赖 1yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 安装nginx 12345678910111213141516# 解压文件tar -xvf nginx-1.18.0.tar.gz# 编译检查文件cd nginx-1.18.0./configure# 安装make &amp;&amp; make install# 安装成功/usr/local/nginx/sbin/nginx里面由启动的脚本# 启动nginx./nginx # 查看nginx是否启动 ps -ef | grep nginx # 访问nginx # 在默认的8080端口的话可能会冲突 ， 导致访问不到 http://47.98.196.115:9090/ 如此一来，访问就成功了 ， 页面如下显示 ， 此处还要有防火墙的开放才能够正确进行访问 nginx操作常用的命令使用操作命令的条件 123456789101112131415161718192021222324# 进入下面的目录才能够进行命令cd /usr/local/nginx/sbin# 查看版本号[root@izbp1hd0mjbeiengcpnjctz sbin]# ./nginx -vnginx version: nginx/1.18.0# 启动nginx[root@izbp1hd0mjbeiengcpnjctz sbin]# ./nginx[root@izbp1hd0mjbeiengcpnjctz sbin]# ps -ef | grep nginxroot 13302 1 0 16:55 ? 00:00:00 nginx: master process ./nginxnobody 13303 13302 0 16:55 ? 00:00:00 nginx: worker processroot 13305 6888 0 16:55 pts/0 00:00:00 grep --color=auto nginx# 停止nginx 要先执行下面的命令，才能够进行停止[root@izbp1hd0mjbeiengcpnjctz sbin]# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf[root@izbp1hd0mjbeiengcpnjctz sbin]# nginx -s stop# 查看状态 [root@izbp1hd0mjbeiengcpnjctz sbin]# ps -ef | grep nginxroot 13299 6888 0 16:54 pts/0 00:00:00 grep --color=auto nginx# 重加载 修改配置文件之后重新加载生效./nginx -s reload nginx配置文件 nginx的配置文件有三部分组成1.全局块从配置文件开始到events块之间的内容，只要会设置一些影响nginx服务器整体运行的配置指令，主要包括配置运行Nginx服务器的用户（组） ， 允许生成的worker process数 ， 进程的PID存放路径 ， 日志存路径和类型以及配置文件的引入等 123456789#user nobody;# nginx处理并发的数量 ， 这个值越大，并发数能够越多worker_processes 1; #error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;pid logs/nginx.pid; 2.events块events块主要影响Nginx服务器与用户的网络连接 ， 比如 1234events &#123;# Nginx支持的最大连接数为1024 worker_connections 1024;&#125; 3.http块Nginx的配置最频繁的块 ， 代理、缓存、和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意： http块也可以包括http全局块盒server块等 1.http全局块 http全局块配置的指令包括文件引入，MIME-TYPE定义，日志定义、连接超时时间、单链接请求数上限等 2.server块 这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。 每个http块可以包含多个server块，而每个server块都相当于一个虚拟主机 而每个server块也分为全局server块，以及包含多个的location块 全局server块 最常见的配置是虚拟主机的监听配置和本虚拟主机的名称或IP配置 location 一个server块可以配置多个location块 这块的主要作用是基于Nginx服务器接收到的请求字符串（例如server_name&#x2F;uri_string),对虚拟主机名称（也可以是ip别名）之外的字符串（例如前面的&#x2F;uri_string）进行匹配，对特定的请求进行处理 ， 地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106http &#123; include mime.types; default_type application/octet-stream; #log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; # &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; # &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; # nginx监听的端口号 listen 9090; # nginx监听的主机名称 这里是本地的localhostr server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; # / 请求的路径 location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # 正则 表达式 有不同的实例 #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; Nginx配置实例 反向代理1.打开浏览器 www.123.com,页面显示tomcat主页面之中 2.具体实现 安装tomcat ， 默认端口为8080 对外开放访问的端口 查看已经开放的端口 3.window通过浏览器访问 4.配置反向代理 配置代理 5.重启nginx测试 经过测试，反向代理成功！！！ Nginx配置实例 ， 反向代理实例实现效果：1.使用nginx反向代理，根据访问路径跳转到不同端口中的服务中 ， nginx监听端口为9090 访问http:127.0.0.1:9090&#x2F;edu&#x2F; 直接跳转到127.0.0.1：8080 访问http:127.0.0.1:9090&#x2F;edu&#x2F; 直接跳转到127.0.0.1：80 2.准备2个tomcat服务器 ， 一个8080 ， 一个80 12345678910111213141516171819# 新配置的实例 # 使用nginx反向代理，根据访问路径跳转到不同端口中的服务中 ， nginx监听端口为9090 # # 访问http:127.0.0.1:9090/edu/ 直接跳转到127.0.0.1：8080 # # 访问http:127.0.0.1:9090/edu/ 直接跳转到127.0.0.1：80 # # 2.准备2个tomcat服务器 ， 一个8080 ， 一个80 server&#123; listen 9001; server_name 47.105.129.77; location ~ /edu/ &#123; proxy_pass http://127.0.0.1:8080; &#125; location ~ /vod/ &#123; proxy_pass http://127.0.0.1:8081; &#125; &#125; 创建测试文件： 测试： location指令说明该指令用于匹配URL &#x3D;用于不含正则表达式的uri前，要求请求字符串与uri严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求 ~用于表示含uri的正则表达式，并且区分大小写 ~*用于包含uri的正则表达式，并且不区分大小写 ^~用于不含正则表达式的uri前，要求Nginx服务器找到表示uri和请求字符串匹配度最高的location之后，立即使用此location处理请求，而不再使用location块中的uri和请求字符串作比较 Nginx配置实例-负载均衡增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 1234567891011121314151617181920212223242526272829# 通过浏览器http://47.105.129.77/edu/a.html 负载均衡效果 ， 平均分担到8080和8081中去# 准备2台tomcat服务器# 在2台tomcat里面webapps 创建edu文件夹 ， 同一叫a.html# 进行负载均衡的配置 # 负载均衡实例配置 # 通过浏览器http://47.105.129.77/edu/a.html 负载均衡效果 ， 平均分担到8080和8081中去 upstream myserver &#123; server 47.105.129.77:8080; server 47.105.129.77:8081; &#125; server &#123; listen 80; server_name 47.105.129.77; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; proxy_pass http://myserver; index index.html index.htm; &#125; 测试： 在相同的请求之下，分发到了不同的端口，也可以说是不同的服务器，之后可以通过多台服务器进行测试。 随着互联网信息的爆炸性增长，负载均衡已经不再是一个很陌生的话题，顾名思义，负载均衡是将负载分摊到不同的服务单元中。即保证服务的可用性，又保证响应足够块，给用户很好的体验，快速增长的访问量和数据流量催生了各式各样的负载均衡产品，很多专业的负载均衡硬件提供了很好的功能，但是价格不菲，这使得负载均衡软件大受欢迎。nginx就是其中的一个，在linux下有nginx、lvs、haproxy等等服务可以提供负载均衡服务，而且Nginx提供了几种分配方式（策略） 负载均衡策略 轮询（默认的策略 ， 不做任何配置就是轮询） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动删除 weight 权重 weight代表权重 ， 默认为1 ， 权重越高被分配的客户端越多。 指定轮询几率weight和访问率成正比，用于后端服务器性能不同的服务器上 12345# 配置upstream myserver &#123; server 47.105.129.77:8080 weight = 5; server 47.105.129.77:8081 weight = 10;&#125; ip_hash 123456# 配置upstream myserver &#123;\tip_hash server 47.105.129.77:8080; server 47.105.129.77:8081;&#125; 每个请求按访问ip的hash结果分配。这样每个访客固定访问一个后端服务器，可以解决session的问题 fair（第三方） 按后端服务器的响应时间分配,响应时间短的优先分配 123456# 配置upstream myserver &#123; server 47.105.129.77:8080; server 47.105.129.77:8081; fair&#125; Nginx配置实例-动静分离什么是动静分离？目的： 提高访问的效率 Nginx动静分离简单说就是把动态跟静态请求分开，不能理解成单纯的把动态页面和静态页面物理分离。严格意义上说应该是把动态请求和静态请求分开，可以理解成Nginx处理静态页面，tomcat处理动态页面。动静分离从目前角度来讲大致分为两种 一种是纯粹把静态文件独立成为单独的域名，放在独立的服务器上，也是目前主流推崇的方案；另一种方法就是把动态跟静态文件混合在一起发布，通过nginx来分开。 通过location指定不同的后缀名实现不同的请求转发，通过expires参数设置，可以使浏览器缓存过期时间，减少与服务器之间的请求和流量。具体expires的定义： 是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量，此种方法非常适合不经常变动的资源。（如果经常更新这个文件，不建议使用expires来缓存） ， ，这里设置3d ， 表示在这3d里面访问这个URL，发送的是一个请求，对比服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304，如果有修改，则直接从服务器重新下载，返回状态码200 2.准备工作 （1） 在linux准备一些静态资源，用于进行访问 3.具体配置 12345678910# 在nginx配置文件进行配置location /www/ &#123;root /environment/data/;index index.htm index.html;&#125;location /image/ &#123;root /environment/data/;autoindex on;&#125; 最终测试： 浏览器中输入http://47.105.129.77/image/git.png 进行访问就可以看到我们放置的静态资源的图片 同样，我们在浏览器中输入http://47.105.129.77/www/a.html同样可以访问到我们的html资源 访问这个地址http://47.105.129.77/image/出现，就是因为autoindex on，会显示文件夹里面有多少个内容，并且会显示出来 Nginx配置高可用的集群keepalived 通过脚本检测nginx服务器是不是还活着，如果没有就会使用从服务器 ， 还有一个虚拟的ip也就是说两个是使用一个ip地址的 高可用： 1.需要两台nginx服务器 2.keepalived 3.需要虚拟ip 配置高可用的准备工作 需要2台服务器 47.105.129.77 47.98.196.115 在服务器上安装nginx 2台服务器安装keepalived 1yum install keepalived -y 安装之后再etc生成keepalived.conf 高可用的配置（主从配置）修改keepalived配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556global_defs &#123; notification_email &#123; acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc &#125; notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.200.1 smtp_connect_timeout 30 router_id LVS_DEVEL # 访问到主机&#125;# 检测脚本配置vrrp script chk_http_port&#123;\tscript &quot;/usr/local/src/nginx_check.sh&quot;\tinterval 2 # 检测脚本执行的间隔\tweight 2&#125;vrrp_instance VI_1 &#123; state MASTER # 备份服务器将MASTER改为BACKUP interface eth0 # 网卡 virtual_router_id 51 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.200.16 // 虚拟地址 &#125;&#125;# 脚本文件#！/bin/bashA=`ps -C nginx -no-header | wc -l`if[$A -eq 0];then\t/usr/local/nginx/sbin/nginx\tsleep 2\tif[`ps -C nginx --no-header | wc -l` -eq 0];then killall keepalived\tfifi# 启动[root@iZm5e7hnl9pp144h2hvqmzZ sbin]# lsnginx[root@iZm5e7hnl9pp144h2hvqmzZ sbin]# ./nginx -s stop[root@iZm5e7hnl9pp144h2hvqmzZ sbin]# lsnginx[root@iZm5e7hnl9pp144h2hvqmzZ sbin]# ./nginx [root@iZm5e7hnl9pp144h2hvqmzZ sbin]# systemctl start keepalived.service[root@iZm5e7hnl9pp144h2hvqmzZ sbin]# ps -ef | grep keepalivedroot 45533 1 0 10:54 ? 00:00:00 /usr/sbin/keepalived -Droot 45534 45533 0 10:54 ? 00:00:00 /usr/sbin/keepalived -Droot 45543 45441 0 10:54 pts/2 00:00:00 grep --color=auto keepalived# 启动另外一个 把这两个启动起来nginx和keepalived 测试：虚拟ip地址 这里配置失败了，因为虚拟的地址不知道在两台服务器中如何和写，因为这里不是局域网，所以没有办法配置应该有的集群，一开始忘记这个条件了，后面也不做配置了。记一下笔记。基本是这样配置的。 Nginx原理 worker如何进行工作 .&#x2F;nginx -s reload热部署 , 如果worker有任务，就不进行争抢，其他的进行争抢 master——worker机制的好处：首先，对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其他进程还在工作，服务不会中断，master进程很快会启动新的worker进程。当然，worker进程的异常退出，肯定是程序有bug了，异常退出，会导致当前worker上的所有请求失败，不过不会影响到所有的请求，所以降低了风险 需要设置多少个workerNginx同redis类似采用了io多路复用机制，每个worker都是独立的进程，但是每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求，即使是上千万个请求也不在话下。每个worker的线程可以吧一个cpu的性能发挥到机制。所以worker数和服务器的cpu是相等是最为适宜的。设少了会浪费cpu，设多了会造成cpu的频繁切换上下文带来损耗 设置worker数量发送一个请求占用了worker的几个连接数 2 或者 4个 ， 发请求和接受请求 nginx中有一个master有四个worker，每个worker支持的最大连接数是1024，支持的最大并发数是多少？ 连接数 4*1024 并发： 2048 &#x2F; 1024 Nginx的详细的配置文件（内置https的）在配置的时候需要ssl安全证书（本着能白嫖绝不花钱的，这里就使用我们的免费的来进行学习） 下载之后的证书： 解压之后上传到服务器 上传之后 详细配置如下配置文件所示，但是在此之前在安装的时候要进行https模块的安装 如果出现the &quot;ssl&quot; parameter requires ngx_http_ssl_module这个错误，需要在编译的时候： 1234567891011./configure --with-http_ssl_module# 然后进行make ， 不是make &amp;&amp; make install 不然可能会进行报错make# 进行重新加载cd /usr/local/nginx/sbin./nginx -s reload# 查看nginx的进程的ps -ef | grep nginx 下面是详细的配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; # &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; # &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name timous.top;\t## 将http直接转化为https，成为加密的域名 这里的server_name就是上面所配置的域名\treturn 301 https://$server_name$request_uri; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; server &#123; listen 443 ssl; #配置HTTPS的默认访问端口为443。 #如果未在此处配置HTTPS的默认访问端口，可能会造成Nginx无法启动。 #如果您使用Nginx 1.15.0及以上版本，请使用listen 443 ssl代替listen 443和ssl on。 server_name timous.top; #需要将yourdomain.com替换成证书绑定的域名。 root html; index index.html index.htm; ssl_certificate /cert/5190359_timous.top.pem; #需要将cert-file-name.pem替换成已上传的证书文件的名称。 ssl_certificate_key /cert/5190359_timous.top.key; #需要将cert-file-name.key替换成已上传的证书密钥文件的名称。 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #表示使用的加密套件的类型。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #表示使用的TLS协议的类型。 ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://127.0.0.1:8080; &#125; location /jenkins &#123; proxy_pass http://127.0.0.1:8001/test/testjenkins; &#125; location ~ /edu/ &#123; proxy_pass http://127.0.0.1:8080; &#125;\t&#125;&#125;","tags":["运维","服务"]},{"title":"Jenkins","path":"/2021/04/12/Jenkins/","content":"Jenkins自动化部署基于Docker安装Jenkins使用docker安装jenkins1docker run -p 9000:8080 -p 5000:5000 -v jenkins_data:/var/jenkins_home jenkinsci/blueocean 访问Jenkins地址http://47.105.129.77:9000/ 输入秘钥之后： 之后出现 创建用户啥的 之后就安装好了 配置java等环境 查看jenkins镜像安装的java地址 echo $JAVA_HOME maven可以自动进行下载 安装maven插件 完成 可以进行maven的构建 开始进行自动部署 进行配置 添加git密码账户 立即构建 构建成功 构建之后的配置 12345678910111213141516171819202122232425262728#!/bin/bash# 服务名称SERVER_NAME=testjenkins# 源jar的路径JAR_NAME=testjenkins-0.0.1-SNAPSHOT# 源jar的路径 直接copy就可以JAR_PATH=/var/jenkins_home/workspace/testJenkins/target# 打包之后的路径JAR_WORK_PATH=/var/jenkins_home/workspace/testJenkins/targetecho &quot;查询进程id--》 $SERVER_NAME&quot;PID=`ps -ef | grep &quot;$SERVER_NAME&quot; | awk &#x27;&#123;print $2&#125;&#x27;`echo &quot;得到进程ID ： $PID&quot;echo &quot;进程结束&quot;for id in $PIDdo kill -9 $id\techo &quot;kill $id&quot;doneecho &quot;进程完成&quot;# 复制jar到执行目录echo &quot;复制jar包到执行目录： cp $JAR_PATH/$JAR_NAME.jar $JAR_WORK_PATH&quot;cp $JAR_PATH/$JAR_NAME.jar $JAR_WORK_PATHecho &quot;复制jar完成&quot;cd $JAR_WORK_PATH# 修改文件的权限chmod 755 $JAR_NAME.jarjava -jar $JAR_NAME.jar 如下图所示： 为了能够访问，我们需要重新构建 12345# 重启dockersystemctl stop docker # 删除镜像docker rm $(sudo docker ps -a -q)docker run -p 9000:8080 -p 5000:5000 -p 8001:8001 -v jenkins_data:/var/jenkins_home jenkinsci/blueocean 测试 修改完代码之后还是成功的进行了访问 问题 命令： 1BULILD_ID=dontKillMe nohup java -jar $JAR_NAME.jar &amp; 测试结果是成功的！！！！ 之后是在idea提交之后自动构建的效果，这里暂时不做研究。之后可能会进行研究。。 安装gitee插件： 安装之后重启 进行密码生成 进行gitee激活 注上面的配置会出现端口的问题，下面是解决的方案 123456789101112131415161718192021222324252627282930#!/bin/bash# 服务名称SERVER_NAME=testjenkins# 源jar的路径JAR_NAME=testjenkins-0.0.1-SNAPSHOT# 源jar的路径 直接copy就可以JAR_PATH=/var/jenkins_home/workspace/testJenkins/target# 打包之后的路径JAR_WORK_PATH=/var/jenkins_home/workspace/testJenkins/targetecho &quot;查询进程id--》 $SERVER_NAME&quot;PID=`ps -ef | grep &quot;$SERVER_NAME&quot; | awk &#x27;&#123;print $1&#125;&#x27;`echo &quot;得到进程ID ： $PID&quot;echo &quot;进程结束&quot;for id in $PIDdo kill -9 $id\techo &quot;kill $id&quot;doneecho &quot;进程完成&quot;# 复制jar到执行目录echo &quot;复制jar包到执行目录： cp $JAR_PATH/$JAR_NAME.jar $JAR_WORK_PATH&quot;cp $JAR_PATH/$JAR_NAME.jar $JAR_WORK_PATHecho &quot;复制jar完成&quot;cd $JAR_WORK_PATH# 修改文件的权限chmod 755 $JAR_NAME.jarBUILD_ID=dontKillMe nohup java -jar $JAR_NAME.jar &amp; # 前台的启动方式# java -jar $JAR_NAME.jar 构建成功！！每次提交代码都会尝试进行构建 至此，今天的东西就结束了！！！","tags":["运维","Jenkins"]},{"title":"ArrayList底层源码详解","path":"/2021/04/06/ArrayList底层源码详解/","content":"ArrayList底层源码详解ArrayList底层的数据结构List解耦的可调整大小的数组实现 数组的特点是一旦初始化，长度就不可以发生改变，这个时候又是一个可以调整的数组 数组特点： 增加元素 删除元素 修改元素 查找元素 数组结构介绍特点： 在增删的时候比较慢： 每次增加元素和删除元素，都需要修改数组的长度，拷贝以及移动元素的位置 查找和修改的时候比较快： 由于数组是存储在一块连续的地址空间，所以可以根据地址+索引的方式快速获取对应位置的元素 类图简介 ArrayList的继承关系Serializable标记性接口介绍类的序列化是由实现java.io.Serializable接口的类启动。不实现接口的类将不会使任何状态的序列或反序列化。可序列化的类的所有子类都是可序列化的。序列化接口没有方法或者是字段，仅用来标识可串行化的语义。 序列化： 将对象的数据写到文件中（写对象） 反序列化： 将文件中的对象的数据读出来（读对象） Serializable源码介绍这种接口在我们的java中还是很多的，就是标记性接口 12public interface serializable&#123;&#125; 案例： 通过序列化或者是反序列化集合 Exception in thread &quot;main&quot; java.io.NotSerializableException: com.domain.Student Cloneable标记性接口介绍 一个类实现了Cloneable接口知识Object.clone（）方法，该方法对于类的实例进行字段的复制是合法的，在不实现Cloneable接口的实例上面调用克隆方法会导致异常ClassNotSupportedException被抛出，简而言之就是克隆根据你已有的数据，创建一份完全一样的拷贝数据 Cloneable源码介绍： 12public interface Cloneable&#123;&#125; 克隆的前提条件： 克隆的对象所在的类必须实现Cloneable接口 必须重写clone方法 克隆的基本使用 已知A对象的姓名为陈留红，年龄23岁，技能为写代码（技能为一个skill），由于项目的特殊要求，需要将该对象复制到另外一个对象中，并且A和B两个对象互不影响 方式一： 创建两个对象模拟 1234567891011121314151617181920212223package com.domain;import java.util.ArrayList;public class ArrayList_clone &#123; public static void main(String[] args) &#123; //创建ArrayList集合 ArrayList&lt;String&gt; arrayList = new ArrayList(); arrayList.add(&quot;陈留红&quot;); arrayList.add(&quot;刘佳金&quot;); arrayList.add(&quot;米金龙&quot;); arrayList.add(&quot;叶剑&quot;); //调用方法进行克隆 Object clone = arrayList.clone(); System.out.println(clone == arrayList); //两个地址是不同的，对象里面的内容跟集合里面的内容是一样的 System.out.println(clone); System.out.println(arrayList); &#125;&#125; 案例：已知对象A的姓名为豹子头林冲，年龄30.由于项目的特殊要求，需要将该对象的数据复制到另一个对象B中去，并且A和B两个对象的数据不会相互影响 传统的方式： 123456789101112131415161718192021222324252627package com.domain;public class ArrayList_Clone_Case &#123; /** * 案例：已知对象A的姓名为豹子头林冲，年龄30.由于项目的特殊要求， * 需要将该对象的数据复制到另一个对象B中去， * 并且A和B两个对象的数据不会相互影响 */ public static void main(String[] args) &#123; //传统方式 //创建学生对象 Student student = new Student(&quot;豹子头林冲&quot;,30); //再创建一个新的对象 Student student1 = new Student(); student1.setUsername(student.getUsername()); student1.setAge(student.getAge()); System.out.println(student == student1); System.out.println(student); System.out.println(student1); System.out.println(&quot;此时不管修改那个的值，两者不会受到影响&quot;); student.setAge(20); System.out.println(student); System.out.println(student1); &#125;&#125; clone的方法： 浅拷贝： 123456789101112131415161718192021222324252627package com.domain;public class ArrayList_Clone_Case1 &#123; /** * 案例：已知对象A的姓名为豹子头林冲，年龄30.由于项目的特殊要求， * 需要将该对象的数据复制到另一个对象B中去， * 并且A和B两个对象的数据不会相互影响 * * 浅拷贝 */ public static void main(String[] args) throws CloneNotSupportedException &#123; //传统方式 //创建学生对象 Student student = new Student(&quot;豹子头林冲&quot;,30); //调用克隆的方法进行数据的拷贝 Object clone = student.clone(); System.out.println(clone == student); System.out.println(student); System.out.println(clone); System.out.println(&quot;修改数据&quot;); student.setAge(50); System.out.println(student); System.out.println(clone); &#125;&#125; 浅拷贝的局限性： 123456789101112131415161718192021222324252627282930313233package com.domain;public class ArrayList_Clone_Case2 &#123; /** * 案例：已知对象A的姓名为豹子头林冲，年龄30.由于项目的特殊要求， * 需要将该对象的数据复制到另一个对象B中去， * 并且A和B两个对象的数据不会相互影响 * * 浅拷贝 * * 浅拷贝的局限性 */ public static void main(String[] args) throws CloneNotSupportedException &#123; //传统方式 //创建技能对象 Skill skill = new Skill(&quot;倒拔垂杨柳&quot;); //创建学生对象 Student student = new Student(&quot;鲁智深&quot;,30 , skill); //调用克隆的方法进行数据的拷贝 Object clone = student.clone(); System.out.println(clone == student); System.out.println(student); System.out.println(clone); System.out.println(&quot;修改数据&quot;); student.setAge(50); skill.setSkillName(&quot;拳打镇关西&quot;); System.out.println(student); System.out.println(clone); &#125;&#125; 经验总结： 浅拷贝在的基本数据类型是可以完全拷贝的，但是关于引用类型的是拷贝的地址 深拷贝： 所有类型的数据都是不会受到影响的 skill类 123456789101112131415161718192021222324252627282930313233package com.domain;public class Skill implements Cloneable&#123; private String skillName; public String getSkillName() &#123; return skillName; &#125; public Skill(String skillName) &#123; this.skillName = skillName; &#125; public Skill() &#123; &#125; public void setSkillName(String skillName) &#123; this.skillName = skillName; &#125; @Override public String toString() &#123; return &quot;Skill&#123;&quot; + &quot;skillName=&#x27;&quot; + skillName + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; student类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.domain;import java.io.Serializable;public class Student implements Serializable , Cloneable&#123; //姓名 private String username; //年龄 private Integer age; private Skill skill; public Student() &#123; &#125; public Student(String username, Integer age) &#123; this.username = username; this.age = age; &#125; public Student(String username, Integer age, Skill skill) &#123; this.username = username; this.age = age; this.skill = skill; &#125; public Skill getSkill() &#123; return skill; &#125; public void setSkill(Skill skill) &#123; this.skill = skill; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; /** * 分析: 创建StringBuild对象 * 先追加一个当前类的类名，以及大括号、成员变量的名字以及=‘ * 再追加成员变量对应的值就是数据 * 再追加’， 后面在跟一个成员变量的名字以及= * 再追加成员变量的值和大括号 * * @return */ @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(&quot;Student[username=&#x27;&quot;); sb.append(this.username); sb.append(&quot;&#x27;, age=&quot;); sb.append(this.age); sb.append(&quot;&#x27;, skill=&quot;); sb.append(skill.getSkillName()); sb.append(&quot;]&quot;); return sb.toString(); &#125; //字符串拼接的时候回有很多的垃圾，我们可以优化 所以有字符串缓冲区等/* @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;*/ /** * 方法的权限修饰符需要修改 public * 方法的返回值是要克隆的对象，可以改为当前类的类名 * @return * @throws CloneNotSupportedException */ @Override public Object clone() throws CloneNotSupportedException &#123; //深拷贝不能简单的调用父类的方法 //先克隆出来一个学生对象 Student stu = (Student)super.clone(); //调用skill类中的克隆方法，克隆出来一个skill对象 Skill skill = (Skill) this.skill.clone(); //技能克隆出来的技能赋值 stu.setSkill(skill); return stu; //return super.clone(); &#125;&#125; 测试代码： 12345678910111213141516171819202122232425262728293031package com.domain;public class ArrayList_Clone_Case4 &#123; /** * 案例：已知对象A的姓名为豹子头林冲，年龄30.由于项目的特殊要求， * 需要将该对象的数据复制到另一个对象B中去， * 并且A和B两个对象的数据不会相互影响 * * 深拷贝 */ public static void main(String[] args) throws CloneNotSupportedException &#123; //传统方式 //创建技能对象 Skill skill = new Skill(&quot;倒拔垂杨柳&quot;); //创建学生对象 Student student = new Student(&quot;鲁智深&quot;,30 , skill); //调用克隆的方法进行数据的拷贝 Object clone = student.clone(); System.out.println(clone == student); System.out.println(student); System.out.println(clone); System.out.println(&quot;修改数据&quot;); student.setAge(50); skill.setSkillName(&quot;拳打镇关西&quot;); System.out.println(student); System.out.println(clone); &#125;&#125; RandomAccess标记接口介绍标记接口由List实现使用，以表明他们支持快速（通常为恒定时间）随机访问。此接口主要目的是允许通用算法更改其行为，以便应用于随机访问或顺序访问列表时提供良好的性能。用于操作随机访问列表的最佳算法（例如ArrayList）可以在应用于顺序访问列表时产生二次行为（如LinkedList）。鼓励通用列表算法在应用如果将其应用于顺序访问列表之前提供较差性能的算法时，检查给定列表是否为instanceof，并在必要的时候更改其行为以保证可接受的性能。人们认识到，随机访问和顺序访问之间的区别通常是模糊的。例如，一些List实现提供渐进的线性访问时间，如果它们在实践中获得巨大但是恒定的访问时间。这样一个List实现应该通常实现这个接口。根据经验，List实现应实现此接口，如果对于类的典型实例，此循环： 12for(int i = 0 , n=list.size() ; i++) list.get(i); //随机访问 比这个循环运行更快 12for( Iterator i = list.iterator() ; i.hasNext();) i.next(); //顺序访问 源码： 12public interface RandomAccess &#123;&#125; 案例演示1 12345678910111213141516171819202122232425262728293031323334353637package com.domain;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class Arraylist_RandomAccess &#123; public static void main(String[] args) &#123; //创建arraylist集合 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加十万条数据 for (int i = 0; i &lt; 100000; i++) &#123; list.add(i+&quot;a&quot;); &#125; //测试随机访问 long start = System.currentTimeMillis(); for (int i = 0; i &lt; list.size(); i++) &#123; // 取出集合的每一个元素 list.get(i); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;随机访问用时：&quot;+(end-start)); //测试顺序访问 long start1 = System.currentTimeMillis(); Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext())&#123; it.next(); &#125; long end1 = System.currentTimeMillis(); System.out.println(&quot;顺讯访问用时：&quot;+(end1-start1)); &#125;&#125; 通过测试我们知道，随机访问比顺序访问用的时间要短，由于ArrayList实现了RandomAccess这个接口，所以，他的随机访问的效率是比较高的 我们再看LinkedList 1234567891011121314151617181920212223242526272829303132333435package com.domain;import java.util.Iterator;import java.util.LinkedList;import java.util.List;public class Arraylist_RandomAccess_LinkedList &#123; public static void main(String[] args) &#123; //创建linkedlist集合 List&lt;String&gt; list = new LinkedList&lt;&gt;(); //添加十万条数据 for (int i = 0; i &lt; 100000; i++) &#123; list.add(i+&quot;a&quot;); &#125; //测试随机访问 long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; list.get(i); &#125; long endTime = System.currentTimeMillis(); System.out.println(&quot;随机访问时间：&quot;+(endTime-startTime)); //测试顺序访问. long startTime1 = System.currentTimeMillis(); Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext())&#123; it.next(); &#125; long endTime1 = System.currentTimeMillis(); System.out.println(&quot;顺序访问时间：&quot;+(endTime1-startTime1)); &#125;&#125; 从结果可以看出来，我们的顺序访问的时间比随机访问的时间短，这个时候我们的LinkedList是没有实现RandomAccess接口的 在企业中进行循环输出的时候判断查询返回的结果是否实现了RandomAccess这个接口，如果实现了这个接口，就推荐使用随机遍历的方式迭代结合，否则就推荐使用顺序的方式迭代集合 如何判断是够实现了RandomAccess这个接口，通过instanceof来判断是否实现这个接口 12345678/*这个是对海量数据的优化*/if(list instanceof RandomAccess)&#123; //推荐使用随机访问&#125;else&#123; //使用顺序访问&#125; AbstractList抽象类 此类提供的骨干实现的List接口以最小化来实现该接口由一个“随机访问”数据存储备份所需的工作（如阵列）。 对于顺序存取的数据（如链接列表）， AbstractSequentialList应优先使用此类。 要实现一个不可修改的列表，程序员只需要扩展这个类并提供get(int)和size()方法的实现。 要实现可修改的列表，程序员必须另外覆盖set(int, E)方法（否则会抛出一个UnsupportedOperationException ）。如果列表是可变大小，则程序员必须另外覆盖add(int, E)和remove(int)方法。 123public E set(int index, E element) &#123; throw new UnsupportedOperationException();&#125; 通过这些源码的解读，我们可以看到，要求他的子类必须实现这些方法，如果不实现就会报错，可以看出，我们必须实现这些方法。 ArrayList的源码分析构造方法 Constructor Constructor描述 ArrayList( ) 构造一个初始容量为10的空列表 ArrayList(int initialCapacity) 构造一个有指定容量的列表 ArrayList(Collection&lt;? extends E&gt; c) 构造一个包含指定集合的元素的列表，按照他们由集合的迭代器返回的顺序 案例演示空参构造1234567891011121314public class ArrayList&lt;E&gt;&#123; //默认的空容量的数组 里面啥都没有，也就是说长度是为0的 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; //集合真正存储数据的容器 transient Object[] elementData; //空参构造 public ArrayList() &#123; //赋值 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125;&#125; 有参的构造1234567891011121314151617181920//有参的构造public class ArrayList&lt;E&gt;&#123; //创建一个空的Object数组， 容量为0 private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //根据我们传递进来的值来进行判断 public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; //如果传过来的变量是大于0的话，就创建一个Object数组，容量为initialCapacity this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; //如果传递进来的参数为0 则 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; //如果不是0或者不大于0的话就会抛出异常 throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125; &#125;&#125; ArrayList(Collection&lt;? extends E&gt; c)这个构造123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//ArrayList(Collection&lt;? extends E&gt; c)public class ArrayList&lt;E&gt;&#123; private int size; private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; public ArrayList(Collection&lt;? extends E&gt; c) &#123; // 将构造方法中的参数转成数组 elementData = c.toArray(); //将数组的长度给size 看是不是等于0 if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) //再次进行判断 if (elementData.getClass() != Object[].class) //数组的创建和拷贝 elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. //如果是0 就把空数组的地址给集合存元素的数组 this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; //将集合转为数组的方法 public Object[] toArray() &#123; //调用数组工具类的方法 return Arrays.copyOf(elementData, size); &#125;&#125;class Arrays&#123; public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; //再次调用一个方法，返回一个数组 return (T[]) copyOf(original, newLength, original.getClass()); &#125; public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(&quot;unchecked&quot;) //三元运算符的运算 不管运算符的结果为啥 都会创建一个新的数组 新的数组的长度都和集合的size一样 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); //数组的拷贝 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); //返回新的数组 return copy; &#125;&#125; 添加方法 方法名 描述 public boolean add(E e) 将指定的元素追加到此列表的末尾。 public void add(int index, E element) 在此列表中的指定位置插入指定的元素。 public boolean addAll(Collection&lt;? extends E&gt; c) 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) 将指定集合中的所有元素插入到此列表中，从指定的位置开始。 public boolean add(E e)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//添加方法public class ArrayList&lt;E&gt;&#123; //默认的容量 private static final int DEFAULT_CAPACITY = 10; //默认容量为空的数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; private int size; private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit * 也就是说，创建数组的时候也会浪费一些空间，所以不是 2 的 31次方，需要减一个 8 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //1.0 先执行 public boolean add(E e) &#123; // 限制性size+1 ensureCapacityInternal(size + 1); // Increments modCount!! //0的时候是e ，size变成1 后面在遍历的时候比较容易遍历 elementData[size++] = e; //给元素赋值 return true; &#125; //执行ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); // elementData是空的 minCapcity = 1 这个是最小容量 private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; //1.0 传入一个 minCapacity = 1 private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; //判断elementData 是不是空的元素集 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //如果容量不超过10 就把10作为容量给返回 return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //如果minCapacity 超过10就返回minCapacity 这里返回的是DEFAULT_CAPACITY return minCapacity; &#125; //minCapacity 10 modCount 0 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; //modCount 1 // overflow-conscious code //判断minCapacity 容量和元素长度的大小 如果minCapacity 比较大 执行 grow(minCapacity); if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; //minCapacity 10 private void grow(int minCapacity) &#123; // overflow-conscious code //定义oldCapacity 为元素的长度，这里还是0 int oldCapacity = elementData.length; // &gt;&gt;右移 &lt;&lt; 左移 就相当于除以2的几次方 左移几位就相当于乘以2的几次方 //扩容的核心算法： 原容量的1.5倍 //newCapacity 新容量是就容量的1.5倍 ， 也就是0 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //判断新容量和 minCapacity 10 之间的关系 if (newCapacity - minCapacity &lt; 0) // newCapacity新的容量为 10 newCapacity = minCapacity; //判断是不是超过了最大的容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //如果是超过最大的容量， 就会采用更大的地址空间 newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: //调用copy数组复制 elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; //传递进来 minCapacity 超过了容量 if (minCapacity &lt; 0) // overflow //如果是直接小于 0 超过的比较多 他这个由于前面是 -8 所以添加的比较少的话不会是负数 不然的话就直接报错 throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? //后面的这段说明也就是仅仅限制在int的最大的数据类型 不会再进行扩容了 Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125;&#125; public void add(int index, E element)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//添加方法// 在指定的位置进行插入元素public void add(int index, E element)&#123; //默认的容量 private static final int DEFAULT_CAPACITY = 10; //默认容量为空的数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; private int size; private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; public void add(int index, E element) &#123; //校验索引 rangeCheckForAdd(index); //和之前的一样 ensureCapacityInternal(size + 1); // Increments modCount!! //开始拷贝元素 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 把添加的元素给我们的element elementData[index] = element; size++; &#125; //只有容量不够的时候才会调用核心扩容的方法 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; //判断所以是不是在集合范围之内 0 &lt; index &lt; size //如果不在这个范围之内会抛出一个数组越界异常 IndexOutOfBoundsException private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125;&#125; public boolean addAll(Collection&lt;? extends E&gt; c)123456789101112131415161718192021//添加方法// 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。public class ArrayList&lt;E&gt;&#123; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; //把 c 转化为数组 Object[] a = c.toArray(); //numNew 为数组的长度 int numNew = a.length; //依然调用我们的扩容的方法 ensureCapacityInternal(size + numNew); // Increments modCount //进行拷贝 System.arraycopy(a, 0, elementData, size, numNew); //重新计算size的值 ， 就是numNew的长度 size += numNew; //返回 值 return numNew != 0; &#125;&#125;//底层还是使用了System 的拷贝方法 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 public boolean addAll(int index, Collection&lt;? extends E&gt; c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ArrayList&lt;E&gt;&#123; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //校验索引是不是超过范围 rangeCheckForAdd(index); //将参数集合转换为数组 Object[] a = c.toArray(); //记录数据源的长度 int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount //numMoved 代表要移动元素的个数 数据目的（集合）的长度-调用addAll的第一个参数，就是那个索引 int numMoved = size - index; // 判断需要移动的个数是不是大于0 if (numMoved &gt; 0) //使用System中的方法arraycopy System.arraycopy(elementData, index, elementData, index + numNew, numMoved); //这个是拷贝数据源中的所有数据 System.arraycopy(a, 0, elementData, index, numNew); //更新size的值 size += numNew; //返回成功 return numNew != 0; &#125; //校验索引是不是超过范围的方法 private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; //总的来讲下面的这三个方法就是为了进行扩容 private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125;&#125; 修改方法public E set(int index, E element)123456789101112131415161718192021public class ArrayList&lt;E&gt;&#123; public E set(int index, E element) &#123; //检查索引 判断是不是越界 rangeCheck(index); //根据索引取出元素 E oldValue = elementData(index); //修改之后的元素存入到我们的elementData数组中 elementData[index] = element; //返回被替换的元素 return oldValue; &#125; private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; E elementData(int index) &#123; return (E) elementData[index]; &#125;&#125; 获取方法 public E get(int index)1234567891011121314151617public class ArrayList&lt;E&gt;&#123; public E get(int index) &#123; //判断索引是不是越界了 rangeCheck(index); //返回集合中索引对应的元素的值 return elementData(index); &#125; private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; E elementData(int index) &#123; return (E) elementData[index]; &#125;&#125; 转换方法toString（）将集合中的所有的元素转换为字符串，它是通过他的亲爷爷来进行调用的。 123456789101112131415161718192021222324252627public abstract class AbstractCollection&lt;E&gt;&#123; public String toString() &#123; //顺序遍历的迭代器 Iterator&lt;E&gt; it = iterator(); // 判断迭代器是不是有元素，如果没有 it.hasNext()是一个boolean类型的 if (! it.hasNext()) return &quot;[]&quot;; //创建一个StringBuilder（字符串的缓冲区） StringBuilder sb = new StringBuilder(); //追加了[ sb.append(&#x27;[&#x27;); // 无限循环 for (;;) &#123; //调用迭代器的方法取出元素且将光标向下移动 E e = it.next(); //三元判断 sb.append(e == this ? &quot;(this Collection)&quot; : e); if (! it.hasNext()) //没有元素 ，在最后面添加]，然后调用toString()把缓冲区的字符转换为字符串 return sb.append(&#x27;]&#x27;).toString(); //有元素就直接追加 sb.append(&#x27;,&#x27;).append(&#x27; &#x27;); &#125; &#125;&#125; 迭代器public interface Iterator 普通迭代器 源码同上（在讲toString方法的时候已经讲过基本操作，通过下面的两个案例分析源码） 案例一： 已知集合： List list &#x3D; new ArrayList&lt;&gt;();里面有三个元素：“hello”，“java”，“php”，使用迭代器遍历获取集合的每一个元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//迭代器public class ArrayList&lt;E&gt;&#123; //获取迭代器的方法 public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; //判断光标的值是不是size 也就是说是不是后面没有元素了 public boolean hasNext() &#123; return cursor != size; &#125; //一个实现了Iterator接口的内部类 不同迭代器的底层的源码是不一样的 private class Itr implements Iterator&lt;E&gt; &#123; //光标 默认值是 0 int cursor; // index of next element to return //记录 -1 int lastRet = -1; // index of last element returned; -1 if no such //将集合实际修改次数赋值给预期修改次数 int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; // @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; // 校验预期修改集合次数和实际修改集合次数是不是一致 checkForComodification(); //将光标赋值给 i int i = cursor; //判断光标的值是不是大于size 判断是不是没有元素了 if (i &gt;= size) throw new NoSuchElementException(); // 把集合存储数据的数组的地址赋值给该方法的局部变量 elementData Object[] elementData = ArrayList.this.elementData; //判断i是不是elementData的长度，如果条件满足，就会产生并发修改异常 if (i &gt;= elementData.length) throw new ConcurrentModificationException(); //光标向下移动 cursor = i + 1; //返回刚才存储的元素 return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; // final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;&#125; 案例二：List list &#x3D; new ArrayList&lt;&gt;();里面有三个元素：“hello”，“java”，“php”，使用迭代器遍历看看有没有php这个元素，如果有，就使用集合对象删除该元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148//迭代器22public class ArrayList&lt;E&gt;&#123; //查看add方法的目的就是为了查看记录集合修改次数的数据 public boolean add(E e) &#123; //这些之前都看过了 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; //真正删除元素的方法 private void fastRemove(int index) &#123; //集合的实际修改的次数会自增 //集合实际修改的次数为4 但是预期的修改次数为 3 modCount++; //计算集合要移动元素的个数 int numMoved = size - index - 1; if (numMoved &gt; 0) //移动元素的核心代码 System.arraycopy(elementData, index+1, elementData, index, numMoved); //让删除的元素位置为null，就是尽快让垃圾回收机制回收，避免占用内存 elementData[--size] = null; // clear to let GC do its work &#125; //集合删除元素的方法 public boolean remove(Object o) &#123; //判断要删除的元素是不是为null if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; //走else &#125; else &#123; //遍历集合 for (int index = 0; index &lt; size; index++) //要删除的元素和集合的每一个元素进行比较 如果是相等 if (o.equals(elementData[index])) &#123; //调用方法进行删除 fastRemove(index); return true; &#125; &#125; return false; &#125; public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such //将集合的实际修改次数赋值给预期修改次数 //获取迭代器的时候，expectedModCount也是3 int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; //判断集合的预期修改次数和实际的修改次数是不是一样 ， 如果一样的话就不会抛出异常 //删除之后，以为实际修改的次数和我们的预期修改次数是不一样的 if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;&#125;结论： 1. 集合每次调用add方法的时候，实际修改变量的次数都会自增12. 在获取迭代器的时候集合只会执行一次，将实际修改集合的次数赋值给预期的修改次数3. 集合在删除元素的时候也会针对实际修改次数的变量进行自增的操作，当我们再次调用next的时候就会产生并发的修改异常 案例三：已知集合List list &#x3D; new ArrayList&lt;&gt;();里面有三个元素： “hello”，“php”，“javase”，使用迭代器遍历集合看看有没有php这个元素，如果有，就使用集合对象删除该元素 123结论： 当要删除的元素在倒数第二个位置的时候 ， 不会产生并发修改异常原因： 因为在调用hasNext方法的时候 ， 光标的值和集合的长度一样 ， 那么就会返回false 因此就不会再去调用next方法获取集合的元素，既然不会调用next ， 也就意味着底层不会产生并发修改异常的问题 相当与在size的时候停止了，不会去比较预期修改次数和实际的修改次数 当要删除的元素在集合的倒数第二个位置的时候不会产生并发的修改异常，原因是因为在调用hasNext方法的时候，光标的值和集合的长度是一样的，就返回false，因此就不会调用下面的方法了，自然就不会产生并发修改异常了（是一个巧合）。 default void remove（） 心情随记，毕业设计没搞，啥都没做，好慌啊！！！","tags":["源码","面试题"]},{"title":"Stream流式计算","path":"/2021/04/01/Stream流式计算/","content":"Stream流式计算什么是Stream流式计算 存储存储： 交给mysql等来进行存储 计算： 要使用stream流进行计算 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.Arrays;import java.util.List;/** * @author Timous * @create 2021-04-01 21:47 * 题目要求： 一分钟内完成此题，只能用一行代码来实现 * 现在有5个用户 ， 筛选 * 1. ID 必须是偶数 * 2. 年龄必须大于23岁 * 3. 用户名转为大写字母 * 4. 用户名字母倒着排序 * 5. 只输出一个用户 */public class StreamTest &#123; public static void main(String[] args) &#123; User user1 = new User(1 , &quot;a&quot;,21); User user2 = new User(2 , &quot;b&quot;,22); User user3 = new User(3 , &quot;c&quot;,23); User user4 = new User(4 , &quot;d&quot;,24); User user5 = new User(6, &quot;e&quot;,25); //集合就是存储 List&lt;User&gt; list = Arrays.asList(user1 , user2 , user3 , user4 , user5); //计算就是交给Stream流 来进行的 //链式编程 list.stream() .filter(u-&gt;&#123;return u.getId()%2==0;&#125;) .filter(u-&gt;&#123;return u.getAge() &gt; 23;&#125;) .map(u-&gt;&#123;return u.getName().toUpperCase();&#125;) .sorted((u1 , u2)-&gt;&#123; return u2.compareTo(u1);&#125;) .limit(1) .forEach(System.out::println); &#125;&#125;class User&#123; private int id; private String name; private int age; public User() &#123; &#125; public User(int id, String name, int age) &#123; this.id = id; this.name = name; this.age = age; &#125; public void setId(int id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125; 测试结果","tags":["JDK新特性"]},{"title":"Lock之8锁详解","path":"/2021/04/01/Lock之8锁详解/","content":"Lock之8锁详解第一组123456789101112131415161718192021222324252627282930313233343536/** * 8锁 就是关于锁的8个问题 * 1. 标准情况下是打电话还是发短息 发短信 打电话 * 2.发短信延时四秒是哪个先 发短信 打电话 */public class Lock1 &#123; public static void main(String[] args) &#123; Phone1 phone1 = new Phone1(); new Thread(()-&gt;&#123; phone1.sendSms(); &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; phone1.call(); &#125;,&quot;B&quot;).start(); &#125;&#125;class Phone1&#123; public synchronized void sendSms()&#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; public synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125;&#125; 测试结果在标准的情况下是先发短信，然后打电话，在打电话睡眠之后还是发短信和打电话，由此可见synchronized锁起了重要作用 还有就是synchronized锁的是方法的调用者，也就是phone对象，下面在再次调用方法的时候，这个时候是有锁的，因而造成了，虽然期间有睡眠的过程，但是还是对于我们的 第二组123456789101112131415161718192021222324252627282930313233343536373839404142/** * 8锁 就是关于锁的8个问题 * 3. 执行完之后是发短信还是 hello hello是一个普通的方法 因为hello没有锁，可以直接使用 * 4. 使用两个对象的时候 ， 两个对象分别调用打电话和发短信的时候 会是打电话 * 因为 synchronized锁的是方法的调用者 相当于是两把锁 ，不需要去进行 争夺锁 */public class Lock2 &#123; public static void main(String[] args) &#123; Phone2 phone = new Phone2(); Phone2 phone1 = new Phone2(); new Thread(()-&gt;&#123; phone.sendSms(); &#125;,&quot;A&quot;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; phone1.call(); &#125;,&quot;B&quot;).start(); &#125;&#125;class Phone2&#123; public synchronized void sendSms()&#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; public synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125;&#125; 测试结果：这里测试的结果是现发短信，然后打电话，从此还有刚才的synchronized锁的是方法的调用者，也就是对象，不是类，因为二者不是一个对象的方法，所以我们的锁不是同一把，可以进行后面的打电话。 第三组123456789101112131415161718192021222324252627282930313233343536373839404142/** * 8锁 就是关于锁的8个问题 * 5.增加两个静态的同步方法 是先打电话还是先发短信 是先发短信 跟前面的是不一样的 * 6. 两个对象 两个方法 这个时候的话 还是发短信 不是打电话 * 因为锁的是模板 不是方法的调用者 两个的class是一样的锁的是class */public class Lock3 &#123; public static void main(String[] args) &#123; Phone3 phone = new Phone3(); Phone3 phone1 = new Phone3(); new Thread(()-&gt;&#123; phone.sendSms(); &#125;,&quot;A&quot;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; phone1.call(); &#125;,&quot;B&quot;).start(); &#125;&#125;class Phone3&#123; public static synchronized void sendSms()&#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; public static synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125;&#125; 测试结果从结果可以看出来，我们的发短信是第一个，打电话是第二个，这是因为加上static的时候锁的是类的模板也就是class，而不是方法的调用这个，锁的是这个类，因为二者是同一个类，所以我们的结果就是先发短信，然后打电话。 第四组12345678910111213141516171819202122232425262728293031323334353637383940/** * 8锁 就是关于锁的8个问题 * 7. 一个静态同步方法 一个普通的同步方法 先打电话 然后 再发短信 * 8.两个对象，输出的是啥 依然是打电话 然后发短信 */public class Lock4 &#123; public static void main(String[] args) &#123; Phone4 phone = new Phone4(); Phone4 phone1 = new Phone4(); new Thread(()-&gt;&#123; phone.sendSms(); &#125;,&quot;A&quot;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; phone1.call(); &#125;,&quot;B&quot;).start(); &#125;&#125;class Phone4&#123; public static synchronized void sendSms()&#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; public synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125;&#125; 测试结果通过结果可以看出，是打电话，发短信，由此可以看出，static只是锁住了加static的类的模板，其他的自己可以进行测试。 以上就是8锁现象的全部内容了，表述不清楚的，可以自己进行测试。","tags":["多线程","锁"]},{"title":"TCP的可靠传输之三次握手","path":"/2021/04/01/TCP的可靠传输之三次握手/","content":"TCP的可靠传输之三次握手第一次握手客户端主动（active open）去连接服务器，并且发送Seq，假设序列号为X，服务器是被动打开的（passive open） 第二次握手服务器在收到SYN之后，它会发送一个Seq以及一个ACK（应答）给客户，ACK的序列号是X+1表示是给Seq X的应答，新发送的Seq Y 序列号是Y 第三次握手客户在收到新的Seq Y ， ACK X+1之后，也会回应ACK Y+1表示收到了，然后两边就开始发送数据了。","tags":["面试题","网络"]},{"title":"回溯之三元组查找","path":"/2021/04/01/回溯之三元组查找/","content":"回溯之三元组查找题目描述判断nums中是否有三个元素a , b , c,使得a+b+c&#x3D;0？ 找到所有满足条件且不重复的三元组 例如nums &#x3D; [-1 , 0 , 1 , 2 , -1 , -4] ，满足要求的三元组为：[ [-1 , 0 , 1], [-1 , -1 , 2]] 代码详解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package top.timous.多益网络;import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * @author Timous * @create 2021-04-01 16:34 * 多益网络笔试编程题 通过回溯的方法进行 * 给定一个包含n个整数的数组nums ， * 判断nums中是否有三个元素a , b , c,使得a+b+c=0？ * 找到所有满足条件且不重复的三元组 * 例如nums = [-1 , 0 , 1 , 2 , -1 , -4] * 满足要求的三元组 * [ * [-1 , 0 , 1], * [-1 , -1 , 2] * ] **/public class Test &#123; int l = -3; int m = -2; int k = -1; int[] arr = new int[3];//存储数组排序 int[] array = &#123;-1 , 0 ,1 ,2 , -1 , -4&#125;; List list = new ArrayList&lt;Integer&gt;(); void place(int n)&#123; if (n == 3)&#123; valid();//校验数据 return; &#125; for (int i = 0; i &lt; array.length; i++) &#123; if (n == 0)&#123; l = i; &#125; if (n == 1)&#123; m = i; &#125; if (n == 2)&#123; k = i; &#125; if (m == k || m == l || l == k)&#123; continue; &#125; place(n + 1); &#125; &#125; private void valid() &#123; arr[0] = array[l]; arr[1] = array[m]; arr[2] = array[k]; Arrays.sort(arr); int sum = 0; for (int i : arr) &#123; sum += i; &#125; if (sum == 0)&#123; //判断是不是重复的 if(judge(arr))&#123; for (int i : arr) &#123; list.add(i); &#125; &#125; &#125; &#125; private boolean judge(int[] arr) &#123; List list1 = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; if (i % 3 == 0)&#123; if (arr[0] == (int)list.get(i) &amp;&amp; arr[1] == (int)list.get(i + 1))&#123; return false; &#125; &#125; &#125; return true; &#125; public static void main(String[] args) &#123; Test test = new Test(); test.place(0); for (int i = 0; i &lt; test.list.size(); i++) &#123; if (i % 3 == 0)&#123; System.out.println(); &#125; System.out.print(test.list.get(i) + &quot;______&quot;); &#125; &#125;&#125; 结果测试： 这里的结果只是没有进行格式化，只是打印出来了。 心情记录： ​\t今天又是一个雨天，本来想在宿舍睡觉，但是同学给我发了个多益网络的招聘，去了之后感觉自己还有很多不会的东西，继续学习！！！","tags":["算法","回溯"]},{"title":"sychronized和lock","path":"/2021/03/31/sychronized和lock/","content":"Lock锁1.传统的sychronized12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.timous.demo;//基本的买票例子/** * 真正的多线程开发 * 1.线程就是一个单独的资源类，没有任何一个附属的操作 属性，方法 */public class SaleTicket &#123; public static void main(String[] args) &#123; Tickets ticket = new Tickets(); //多个线程操作同一个资源类 把资源类丢给线程 //@FunctionalInterface 函数是接口 lambda (参数)-&gt;&#123; &#125; new Thread(()-&gt;&#123; for (int i = 1; i &lt; 110; i++) &#123; ticket.sale(); &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 1; i &lt; 110; i++) &#123; ticket.sale(); &#125; &#125;,&quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 1; i &lt; 110; i++) &#123; ticket.sale(); &#125; &#125;,&quot;C&quot;).start(); &#125;&#125;/*class MyThead implements Runnable&#123; @Override public void run() &#123; &#125;&#125;*///资源类 OOP 基本的面向对象 降低耦合性// 下面只防止属性和方法class Tickets&#123; private int number = 100 ; //买票的方式 //synchronized 本质就是队列和锁 锁 ， 一个是对象 ， 一个是class public synchronized void sale()&#123; if(number &gt; 0)&#123; number--; System.out.println(Thread.currentThread().getName()+&quot;卖出了&quot;+(100-number)+&quot;张票！，剩余&quot;+number+&quot;张票&quot;); &#125; &#125;&#125; 执行的结果如下，可能会出现有重复获取了同一张票的时候。 在使用synchronized之后，发现我们的票不会出现同一张的时候。 代码 123456public synchronized void saleTicket()&#123; if (num &gt; 0)&#123; num--; System.out.println(Thread.currentThread().getName()+&quot;获得了&quot;+ (100 - num) + &quot;张票！&quot;); &#125;&#125; lock 接口 ReentrantLock : 可重入锁 ReentrantReadWriteLock.ReadLock : 读锁 ReentrantReadWriteLock.WriteLock : 写锁 公平锁、非公平锁 非公平锁 十分不公平，可以插队 （默认） 公平锁 十分公平 ， 不能插队 3s 3h 123456789101112131415161718192021222324252627282930313233343536373839404142//资源类 OOP 基本的面向对象 降低耦合性// 下面只防止属性和方法//lockclass Tickets2&#123; private int number = 100 ; Lock lock = new ReentrantLock(); /** * 非公平锁 十分不公平，可以插队 （默认） * 公平锁 十分公平 ， 不能插队 3s 3h * * public ReentrantLock() &#123; * sync = new NonfairSync(); 非公平锁 * &#125; * * public ReentrantLock(boolean fair) &#123; 可以设置是否为公平锁 * sync = fair ? new FairSync() : new NonfairSync(); * &#125; */ /** * 三部曲 * new 锁 * * 加锁 * * 解锁 */ public void sale()&#123; lock.lock(); try &#123; // 业务代码 if(number &gt; 0)&#123; number--; System.out.println(Thread.currentThread().getName()+&quot;卖出了&quot;+(100-number)+&quot;张票！，剩余&quot;+number+&quot;张票&quot;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; Lock和Synchronized的区别 Synchronized是一个内置的java的关键字 Lock是一个类 Synchronized无法判断获取锁的状态 ， Lock可以判断是否获取到了锁 Synchronized会自动释放锁，Lock需要手动释放锁 ， 如果不释放，会造成死锁 Synchronized 线程2（会一直等待）线程1获得锁 ， 就算是1阻塞，2也会一直等待 ， 如果是Lock不会一直等待会进行lock.tryLock（） Synchronized可重入锁，不可以中断，非公平， Lock可重入锁，可以判断锁 ， 非公平（可以自己进行设置） Synchronized适合锁少量的代码同步问题，Lock适合锁大量的代码 锁的是啥，对象还是类模板生产者和消费者的问题synchronized 和 lock 生产者和消费者问题Synchronized有虚假等待12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package top.timous;/** * @author Timous * @create 2021-03-31 19:44 **/public class Test &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.incrementData(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; , &quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrementData(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; , &quot;B&quot;).start(); &#125;&#125;//class Data&#123; private int num = 0; public synchronized void incrementData() throws InterruptedException &#123; if (num != 0)&#123; //执行等待 wait(); &#125; num++; System.out.println(Thread.currentThread().getName()+&quot;获得num：&quot; + num); //通知消费者那物品 notifyAll(); &#125; public synchronized void decrementData() throws InterruptedException &#123; if (num == 0)&#123; //执行等待 wait(); &#125; num--; System.out.println(Thread.currentThread().getName()+&quot;获得num：&quot; + num); //通知生产者进行生产 notifyAll(); &#125;&#125; 测试结果： 思考：如果是A、B、C、D四个线程结果会不会是安全的123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) &#123; Data data = new Data(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.incrementData(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; , &quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.incrementData(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; , &quot;C&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrementData(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; , &quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrementData(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; , &quot;D&quot;).start();&#125; 结果来讲，实际上是线程不安全的1 在有c或者是D的时候回出现问题 ， 会出现虚假唤醒，应该使用while ， 防止虚假唤醒 修改的代码： 结果： JUC版的生产者和消费者：图解 对比： synchronized是wait等待和notify唤醒 lock是await等待和signal唤醒 具体的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package top.timous;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @author Timous * @create 2021-03-31 21:05 **/public class JucTest &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.incrementData(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; , &quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.incrementData(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; , &quot;C&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrementData(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; , &quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrementData(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; , &quot;D&quot;).start(); &#125;&#125;class Datas&#123; private int num; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); public synchronized void incrementData() throws InterruptedException &#123; try &#123; lock.lock(); while (num != 0)&#123; condition.await(); &#125; num++; System.out.println(Thread.currentThread().getName()+&quot;获得num：&quot; + num); //通知其他的线程去进行消费 condition.signalAll(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; public synchronized void decrementData() throws InterruptedException &#123; try &#123; lock.lock(); while (num == 0)&#123; condition.await(); &#125; num--; System.out.println(Thread.currentThread().getName()+&quot;获得num：&quot; + num); //通知生产者生产 condition.signalAll(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; 结果展示 线程是安全的 小结：任何新的技术只是会覆盖原来的技术condition的优势1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package top.timous;/** * @author Timous * @create 2021-03-31 21:15 **/import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * A 执行玩 调用B b之后调用C */public class JucTest1 &#123; public static void main(String[] args) &#123; Date3 date3 = new Date3(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; date3.printA(); &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; date3.printB(); &#125; &#125;,&quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; date3.printC(); &#125; &#125;,&quot;C&quot;).start(); &#125;&#125;//资源类class Date3&#123; private Lock lock = new ReentrantLock(); private int num = 1; private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); public void printA()&#123; try &#123; lock.lock(); //判断 业务 执行 通知 while (num != 1)&#123; condition1.await(); &#125; System.out.println(Thread.currentThread().getName()+&quot;===AAAAAAAAAA&quot;); // 唤醒指定的值 num = 2; condition2.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printB()&#123; try &#123; lock.lock(); while(num != 2)&#123; condition2.await(); &#125; System.out.println(Thread.currentThread().getName()+&quot;===BBBBB&quot;); num = 3; condition3.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printC()&#123; try &#123; lock.lock(); while(num != 3 )&#123; condition3.await(); &#125; System.out.println(Thread.currentThread().getName()+&quot;===CCCCCCC&quot;); num = 1; condition1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;//生产线 购物 下单 支付 交易 物流 思路&#125; 结果展示： 从结果看，我们的线程可以精准的进行唤醒，而不是synchronized的简单的进行锁。A完了之后B，B完了之后是C 线程和锁就到这里了，之后也会有新的更新。 心情随机： ​ 今天下雨了，跑了两圈之后心情还行，回宿舍也看了一会笔记和代码。","tags":["多线程","锁"]},{"title":"linux之Java基本环境的配置","path":"/2021/03/30/linux之Java基本环境的配置/","content":"linux服务器的基本java环境配置一、环境准备 二、服务器 三、配置java解压文件 1tar -zxvf jdk-8u231-linux-x64.tar.gz 配置环境变量 1vim /etc/profile 在文件的最后追加 123456# 这里是你自己解压后的文件的路径export JAVA_HOME=/environment/java/jdk1.8.0_231 export JAVA_BIN=$JAVA_HOME/binexport PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 刷新刚配置的变量 1source /etc/profile 查看配置好的java变量 四、配置tomcat到这java的环境变量就配置好了，接下来配置tomcat先使用9.0的版本配置解压文件tar -zxvf apache-tomcat-9.0.41.tar.gz 123cd apache-tomcat-9.0.41 # 进入tomcat文件夹cd bin # 进入bin目录./startup.sh # 开启tomcat 测试访问本地测试远程测试 五、配置nginx安装pcre 123456789# 解压文件tar -xvf pcre-8.00.tar.gz# 编译检查文件cd pcre-8.00./configure# 安装make &amp;&amp; make install# 查看安装pcre版本pcre-config --version 安装openssl zlib等其他依赖 1yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 安装nginx 123456789101112131415161718# 解压文件tar -xvf nginx-1.18.0.tar.gz# 编译检查文件cd nginx-1.18.0./configure# 安装make &amp;&amp; make install# 安装成功cd /usr/local/nginx/sbin # 里面由启动的脚本# 启动nginx./nginx# 如果不能启动nginx，输入下面的命令ln -s /usr/local/lib/libpcre.so.0 /lib64# 查看nginx是否启动 ps -ef | grep nginx # 访问nginx # 在默认的8080端口的话可能会冲突 ， 导致访问不到 http://ip:80/ nginx访问成功","tags":["linux","服务器"]},{"title":"回溯算法详解","path":"/2021/03/28/回溯算法详解/","content":"回溯算法（Back Tracking）回溯可以理解为： 通过不同的岔路口来通往目的地每一步都选择一条路出发，不能进则退回上一步，换一条路再试一试 树、图的深度优先搜索（DFS）就是典型的回溯应用 回溯很适合使用递归 八皇后问题在8*8的国际象棋上摆放8个皇后，使其不能相互进行攻击：任意两个皇后都不能处于同一列或者同一斜线上，请问有多少种摆法？ 思路1：暴力进行解决任意选出8个格子摆放皇后，检查每一种摆法的可能性 思路2：根据题意减小暴力程度很显然每行只能摆放一个皇后，检查每种的方法就可以了 思路3： 回溯法四皇后： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class BackTracking &#123; public static void main(String[] args) &#123; new BackTracking().placeQueens(4); &#125; /** * 数组索引是行号 数组元素是列号 cols[4] = 5 第四行的皇后在第五列 */ int[] cols; /** * 一共有多少种摆法 */ int ways; //摆放n个皇后 void placeQueens(int n)&#123; if(n &lt; 1)&#123; return; &#125; cols = new int[n];//几个皇后就有几个元素 place(0); System.out.println(cols.length + &quot;皇后一共有&quot;+ways+&quot;种摆法！&quot;); &#125; /** * 从第row行摆放皇后 * @param row */ void place(int row)&#123; if (row == cols.length)&#123;//成功找到了对应的位置 ways++; return; &#125; for (int col = 0; col &lt; cols.length; col++) &#123; if (isValid(row , col))&#123; cols[row] = col;//在第row行第col列摆放皇后 place(row + 1);//直接摆放下一行元素 //在摆放之后，如果第row+1的时候没有进行完会回到这里，然后就能够进行回溯 &#125; &#125; &#125; /** * 判断第row行第col列是不是可以摆放皇后 * @param row * @param col * @return */ boolean isValid(int row , int col)&#123; for (int i = 0; i &lt; row; i++) &#123; //判断格子能不能摆 ， 只需要跟前面的是不是冲突 if (cols[i] == col) return false;//第col列已经有皇后了 //斜线上是不是有元素 if (Math.abs(cols[i] - col) == Math.abs(row - i))&#123; return false; &#125; &#125; return true; &#125;&#125; 通过测试，我们的4皇后有2种摆法。8皇后有92种摆法。","tags":["算法"]},{"title":"Java的IO流","path":"/2021/03/28/Java的IO流/","content":"Java的IO流Java中有几种类型的流？ 按照流的方向： 分为输入流（inputStream）和输出流（outputStream） 按照实现功能进行分类的话： 节点流（可以从或向一个特定的（节点）读写数据。如FileReader）和处理流（是对一个已存在的流的连接和封装，通过封装的流的功能嗲用实现数据读写。如BuffferReader。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，成为流的链接。） 按照处理数据的单位： 字节流和字符流。字节流继承与InputStream和OutputStream,字符流继承与InputStreamReader和OutputStreamWriter。 字节流如何转化为字符流字节输入流转字符输入流通过InputStreamReader实现，该类的构造函数可以传入InputStream对象。 字节输出流转字符输出流通过OutputStreamWriter实现，该类的构造函数可以传入OutputStream对象。 字节流和字符流的区别字节流读取的时候，读到一个字节就返回一个字节；字符流使用了字节流读到一个或多个字节（中文对应的是两个，在UTF-8码表中是三个字节）时。先去查指定的编码表，将查到的字符返回。字节流可以处理所有类型数据。如图片、MP3、AVI视频文件，而字符流只能处理字符数据。只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都是字节流。字节流主要是操作byte类型的数据，以byte数组为准，主要操作类就是InputStream ， OutputStream。 字符流处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，而字节流处理单元为1个字节，操作字节和字节数组。所以字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符组成，所以它对多国语言支持性比较好！如果是音频文件、图片、歌曲，就使用字节流好点，如果是关系到中文（文本）的，使用字符流好点，在程序中一个字符相当于两个字节，java提供了Reader、Writer两个专门操作字符流的类。","tags":["面试题"]},{"title":"typora和picgo配置gitee图床","path":"/2021/03/27/typora和picgo配置gitee图床/","content":"typora和picgo配置gitee图床前置准备下载安装typora、picgo还有gitee的账号，这个这里就不讲了。 创建仓库 仓库的配置 找到https的地址 生成token访问gitee picgo插件下载 picgo配置gitee图床 picgo的配置上传端口 配置typora文件—-&gt;偏好设置 进行测试 到这里就成功了，以后就可以用自己的图床了，之后的话每次粘贴完图片右击鼠标进行上传就行了。","tags":["小技巧"]},{"title":"JavaSE常用的API","path":"/2021/03/27/JavaSE常用的API/","content":"JavaSE常用的APIMath.round(11.5)向上取整 此处是12 ， 如果是-11.5 ， 则取值为-11 switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上?Java5之前switch可以作用在byte、short、char、int，但是Java5中引入了枚举类型，也可以作用在enum上 ， 从Java7开始 ， 还可以作用在字符串上，但是长整型（long）截止目前为止的所有的版本中都是不可以的。 数组有没有 length() 方法？String 有没有 length() 方法？数组没有length（）方法，但是有length属性。String有length（）方法。 String 、StringBuilder 、StringBuffer 的区别？Java提供了两种类型的字符串： String和StringBuffer&#x2F;StringBuilder,他们都可以操作和存储字符串，区别如下： String是字符字符串也就是final类型的，也就意味着String引用的字符串内容是不能被改变的。 12String str = &quot;abc&quot;;str = &quot;bcd&quot;; 如上字符串str明明是可以改变的，其实不然，str仅仅是一个引用对象，它指向一个字符串对象“abc”，第二行代码的含义是让str重新指向一个新的字符串“bcd”对象，而“abc”对象并没有任何的改变，只不过该对象已经成为一个不可及的对象罢了。 StringBuffer&#x2F;StringBuilder表示的是字符串对象可以直接进行修改。 StringBuilder是Java5中引入的，它和StringBuilder的方法完全相同，区别在于它是单线程环境下使用的，因为它的所有的方法都是没有被sychronized修饰的，因此他的效率理论上也比StringBuffer高。 上次看到了71页","tags":["面试题"]},{"title":"旋转链表","path":"/2021/03/27/旋转链表/","content":"61. 旋转链表旋转链表地址 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。示例1 示例2解决代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class _61_旋转链表 &#123; public ListNode rotateRight(ListNode head, int k) &#123; //链表为null直接返回 if (head == null) &#123; return head; &#125; // 计算链表中节点个数 int len = calculateLen(head); //如果是移动的数量比较多的话会直接出现重复移动，所以要进行求余的运算 k = k%len; //开始的时候快慢的指针都指向头结点，然后块的指针直接到对应头结点的位置， // 这个时候的k是不会出现循环多次的结果的 // 慢指针初始指向头节点 ListNode slow = head; // 快指针初始指向头节点 ListNode fast = head; // 快指针先向前移动k步 for(int i = 0; i &lt; k; i++) &#123; fast= fast.next; &#125; // 快慢指针同时向前移动，直到快指针指向的节点的 // 下一个节点为null while (fast.next != null) &#123; fast = fast.next; slow = slow.next; &#125; // 快指针此时在链表末尾 // 然后其指向的节点的后继指针指向头节点 // 这时链表首尾相连成环 fast.next = head; // 新的头节点是慢指针所指节点的下一个节点 head = slow.next; // 慢指针所指节点的的后继指针指向null // 断开环 slow.next = null; return head; &#125; //判断链表的长度 private int calculateLen(ListNode head)&#123; int len = 0; while (head!=null) &#123; head = head.next; len++; &#125; return len; &#125;&#125; 原理讲解 如上图所示，相当于是一个环的链表然后向后移动n个位置，我们可以让fast的指针提前移动n个位置，这样，我们在最后fast走到最后一个节点的时候，相当于是我们整体的向后移动了k个位置。然后我们的问题就解决了。","tags":["leetcode每日一题","快慢指针"]},{"title":"throw...和final...","path":"/2021/03/26/throw-和final/","content":"throw 和 throws 的区别throw throw语句用在方法体内，表示抛出异常，由方法体内的语句处理。 throw是具体向外抛出异常的动作，所以他抛出的是一个异常实例，执行throw一定是抛出了某种异常。 throws throws语句是用在方法声明后面，表示如果抛出异常，由该方法调用者来进行异常的处理。 throws主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型。 throws表示出现异常的一种可能性，不一定会发生这种异常。 final、finally、finalize 的区别？final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，被修饰的类不可继承。 finally异常处理语句结构的一部分，表示总是执行。 finallizeObject的一个方法，在垃圾回收器执行的时候回调用被回收对象的此方法，可以覆盖此方法提供垃圾收集是的其他资源回收，例如关闭文件等。该方法更像是一个对象生命周期的临终方法，当该方法被系统调用则代表该对象即将死亡，但是需要注意，我们主动行为上去调用该方法并不会导致该对象死亡，这是一个被动的方法（其实就是回调方法），不需要我们调用。","tags":["面试题"]},{"title":"JUC学习","path":"/2021/03/26/JUC学习/","content":"JUC学习源码+官方文档 面试高频问 什么是JUC java.util工具包 包、屏蔽同名 考虑分类 业务：无法通过普通的程序代码实现Thread Runnable 没有返回值 ， 效率相比于Callable比较低！ 我们更多使用Callable 线程和进程 线程和进程 如果不能使用一句话说出来的技术就是不扎实 进程： 它是一个程序 qq.exe music.exe 本身是一些程序的集合 .jar 一个进程往往可以包含多个线程，至少包含一个 ， java默认有两个线程，一个是GC线程，一个是main线程 线程： 开了一个进程 ， typora ， 可以写字 ， 自动保存（线程负责） Thread、Runnable 、 Callable 对于java而言 java真的可以开启线程吗？ 开不了的 123456789101112131415161718192021222324252627282930313233public synchronized void start() &#123; /** * This method is not invoked for the main method thread or &quot;system&quot; * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state &quot;NEW&quot;. */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group&#x27;s list of threads * and the group&#x27;s unstarted count can be decremented. */ group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125;&#125;//本地方法，是java调用的c++private native void start0(); 并发和并行 并发编程： 并发，并行 并发（多线程操作同一个资源） CPU只有1核 ， 在一瞬间只能处理一个事 ， 模拟出来多条线程 天下武功，唯快不破 ， 快速交替 并行（多个人一起行走） 多核CPU下，多个线程可以同时执行 123456789package com.timous.demo;public class Test1 &#123; public static void main(String[] args) &#123; //获取cpu的核数 //cpu密集型和IO密集型 System.out.println(Runtime.getRuntime().availableProcessors()); &#125;&#125; 并发编程的本质： 充分的利用CPU的资源 所有的公司都很看中的东西！ 企业是为了赚钱： 提高效率 裁员 找一个厉害的人，顶替三个不咋样的人 线程有几个状态 123456NEW, # 新生RUNNABLE, # 运行BLOCKED, #阻塞WAITING, # 等待TIMED_WAITING, # 超时等待 等多久然后不等了TERMINATED; # 终止 wait sleep 来自不同的类 wait 是object类的 sleep是Thread独有的 企业中不使用sleep wait会释放锁 ， sleep睡觉了，不会释放锁 使用的范围是不同的 wait必须在同步代码块之中使用 sleep是可以在任何的地方睡 wait不需要捕获异常（有中断异常） ， sleep是需要捕获异常的 Lock（锁 重点） 传统的Synchronized 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.timous.demo;//基本的买票例子/** * 真正的多线程开发 * 1.线程就是一个单独的资源类，没有任何一个附属的操作 属性，方法 */public class SaleTicket &#123; public static void main(String[] args) &#123; Tickets ticket = new Tickets(); //多个线程操作同一个资源类 把资源类丢给线程 //@FunctionalInterface 函数是接口 lambda (参数)-&gt;&#123; &#125; new Thread(()-&gt;&#123; for (int i = 1; i &lt; 110; i++) &#123; ticket.sale(); &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 1; i &lt; 110; i++) &#123; ticket.sale(); &#125; &#125;,&quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 1; i &lt; 110; i++) &#123; ticket.sale(); &#125; &#125;,&quot;C&quot;).start(); &#125;&#125;/*class MyThead implements Runnable&#123; @Override public void run() &#123; &#125;&#125;*///资源类 OOP 基本的面向对象 降低耦合性// 下面只防止属性和方法class Tickets&#123; private int number = 100 ; //买票的方式 //synchronized 本质就是队列和锁 锁 ， 一个是对象 ， 一个是class public synchronized void sale()&#123; if(number &gt; 0)&#123; number--; System.out.println(Thread.currentThread().getName()+&quot;卖出了&quot;+(100-number)+&quot;张票！，剩余&quot;+number+&quot;张票&quot;); &#125; &#125;&#125; lock 接口 ReenTrantLock 可重入锁 ReentrantReadWriteLock.ReadLock 读锁 ReentrantReadWriteLock.WriteLock 写锁 12非公平锁 十分不公平，可以插队 （默认）公平锁 十分公平 ， 不能插队 3s 3h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.timous.demo;//基本的买票例子import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 真正的多线程开发 * 1.线程就是一个单独的资源类，没有任何一个附属的操作 属性，方法 * * Lock l = ...; l.lock(); try &#123; // access the resource protected by this lock &#125; finally &#123; l.unlock(); &#125; */public class SaleTicket02 &#123; public static void main(String[] args) &#123; Tickets2 ticket = new Tickets2(); //多个线程操作同一个资源类 把资源类丢给线程 //@FunctionalInterface 函数是接口 lambda (参数)-&gt;&#123; &#125; new Thread(()-&gt;&#123; for (int i = 1; i &lt; 110; i++) &#123; ticket.sale(); &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 1; i &lt; 110; i++) &#123; ticket.sale(); &#125; &#125;,&quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 1; i &lt; 110; i++) &#123; ticket.sale(); &#125; &#125;,&quot;C&quot;).start(); &#125;&#125;/*class MyThead implements Runnable&#123; @Override public void run() &#123; &#125;&#125;*///资源类 OOP 基本的面向对象 降低耦合性// 下面只防止属性和方法//lockclass Tickets2&#123; private int number = 100 ; Lock lock = new ReentrantLock(); /** * 非公平锁 十分不公平，可以插队 （默认） * 公平锁 十分公平 ， 不能插队 3s 3h * * public ReentrantLock() &#123; * sync = new NonfairSync(); 非公平锁 * &#125; * * public ReentrantLock(boolean fair) &#123; 可以设置是否为公平锁 * sync = fair ? new FairSync() : new NonfairSync(); * &#125; */ /** * 三部曲 * new 锁 * * 加锁 * * 解锁 */ public void sale()&#123; lock.lock(); try &#123; // 业务代码 if(number &gt; 0)&#123; number--; System.out.println(Thread.currentThread().getName()+&quot;卖出了&quot;+(100-number)+&quot;张票！，剩余&quot;+number+&quot;张票&quot;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; Lock和Synchronized的区别： Synchronized是一个内置的java关键字 Lock是一个java类 Synchronized无法判断获取锁的状态 Lock可以判断是否获取到了锁 Synchronized会自动释放锁 Lock需要手动释放锁如果不释放锁会造成死锁 Synchronized 线程2（会一直等待） 线程1（获得锁） 就算是1阻塞，2也会一直等待 ， 如果是lock不会一直等待lock.tryLock() Synchronized 可重入锁 不可以中断 非公平 Lock 可重入锁 可以判断锁 ， 非公平（可以自己设置） Synchronized 适合锁少量的代码同步问题 Lock 适合锁大量的代码 锁是什么 ， 如何判断锁 锁的是谁 生产者和消费者问题Synchronized 和 lock 生产者和消费者问题Synchronized有虚假等待12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.timous.pc;/** * 线程交替执行 通信问题 生产者和消费者问题 * 等待唤醒 通知唤醒 * A B 操作同一个变量 num = 0 * A + 1 B - 1 */public class Test &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;B&quot;).start(); &#125;&#125;//等待 业务 通知class Data&#123; private int num = 0; //+1 public synchronized void increment() throws InterruptedException &#123; if(num!=0)&#123; //等待操作 wait(); &#125; num++; System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+num); //通知其他线程 ， +1完毕 notifyAll(); &#125; //-1 public synchronized void decrement() throws InterruptedException &#123; if(num==0)&#123; //等待操作 wait(); &#125; num--; System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+num); //通知其他线程 ， -1完毕 notifyAll(); &#125;&#125; 测试结果： 问题存在 A B C D 多的线程是不是还是安全的？ 在有c或者是D的时候回出现问题 ， 会出现虚假唤醒，应该使用while ， 防止虚假唤醒 测试： 防止虚假唤醒的代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.timous.pc;/** * 线程交替执行 通信问题 生产者和消费者问题 * 等待唤醒 通知唤醒 * A B 操作同一个变量 num = 0 * A + 1 B - 1 */public class Test &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;C&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;D&quot;).start(); &#125;&#125;//等待 业务 通知class Data&#123; private int num = 0; //+1 public synchronized void increment() throws InterruptedException &#123; while(num!=0)&#123; //等待操作 wait(); &#125; num++; System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+num); //通知其他线程 ， +1完毕 notifyAll(); &#125; //-1 public synchronized void decrement() throws InterruptedException &#123; while(num==0)&#123; //等待操作 wait(); &#125; num--; System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+num); //通知其他线程 ， -1完毕 notifyAll(); &#125;&#125; JUC版的生产者和消费者 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.timous.pc;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 线程交替执行 通信问题 生产者和消费者问题 * 等待唤醒 通知唤醒 * A B 操作同一个变量 num = 0 * A + 1 B - 1 */public class Test1 &#123; public static void main(String[] args) &#123; Data1 data = new Data1(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;C&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;D&quot;).start(); &#125;&#125;//等待 业务 通知class Data1&#123; private int num = 0; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); //+1 public void increment() throws InterruptedException &#123; try &#123; lock.lock(); while(num!=0)&#123; //等待操作 condition.await();/* condition.await(); //等待 condition.signal(); //唤醒*/ &#125; num++; System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+num); //通知其他线程 ， +1完毕 condition.signalAll(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; //-1 public void decrement() throws InterruptedException &#123; try &#123; lock.lock(); //业务代码 while(num==0)&#123; //等待操作 condition.await(); &#125; num--; System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+num); //通知其他线程 ， -1完毕 condition.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; //做完释放锁 lock.unlock(); &#125; &#125;&#125; 任何的新技术 绝对会只是覆盖原来的技术 condition的优势 代码测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.timous.pc;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * A 执行玩 调用B b之后调用C */public class Test2 &#123; public static void main(String[] args) &#123; Date3 date3 = new Date3(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; date3.printA(); &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; date3.printB(); &#125; &#125;,&quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; date3.printC(); &#125; &#125;,&quot;C&quot;).start(); &#125;&#125;//资源类class Date3&#123; private Lock lock = new ReentrantLock(); private int num = 1; private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); public void printA()&#123; try &#123; lock.lock(); //判断 业务 执行 通知 while (num != 1)&#123; condition1.await(); &#125; System.out.println(Thread.currentThread().getName()+&quot;===AAAAAAAAAA&quot;); // 唤醒指定的值 num = 2; condition2.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printB()&#123; try &#123; lock.lock(); while(num != 2)&#123; condition2.await(); &#125; System.out.println(Thread.currentThread().getName()+&quot;===BBBBB&quot;); num = 3; condition3.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printC()&#123; try &#123; lock.lock(); while(num != 3 )&#123; condition3.await(); &#125; System.out.println(Thread.currentThread().getName()+&quot;===CCCCCCC&quot;); num = 1; condition1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;//生产线 购物 下单 支付 交易 物流 思路 &#125; 8锁现象如何判断锁 ， 锁的是谁 对象 和 class 深刻理解锁 第一组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.timous.lock8;import java.util.concurrent.TimeUnit;/** * 8锁 就是关于锁的8个问题 * 1. 标准情况下是打电话还是发短息 发短信 打电话 * 2.发短信延时四秒是哪个先 发短信 打电话 */public class Test1 &#123; public static void main(String[] args) &#123; Phone1 phone = new Phone1(); //这个是先调用的是错误的 是有锁的问题 new Thread(()-&gt;&#123; phone.sendmsm(); &#125;,&quot;A&quot;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; phone.call(); &#125;,&quot;B&quot;).start(); &#125;&#125;class Phone1&#123; //synchronized 修饰的对象锁的是方法的调用者 //两个方法用的是同一个锁 谁先拿到谁执行 public synchronized void sendmsm()&#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; public synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125;&#125; 第二组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.timous.lock8;import java.util.concurrent.TimeUnit;/** * 8锁 就是关于锁的8个问题 * 3. 执行完之后是发短信还是 hello hello是一个普通的方法 因为hello没有锁，可以直接使用 * 4. 使用两个对象的时候 ， 两个对象分别调用打电话和发短信的时候 会是打电话 * 因为 synchronized锁的是方法的调用者 相当于是两把锁 ，不需要去进行 争夺锁 */public class Test2 &#123; public static void main(String[] args) &#123; //两个对象 Phone2 phone = new Phone2(); Phone2 phone1 = new Phone2(); Phone2 phone2 = new Phone2(); //这个是先调用的是错误的 是有锁的问题 new Thread(()-&gt;&#123; phone1.sendmsm(); &#125;,&quot;A&quot;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; phone2.call(); &#125;,&quot;B&quot;).start(); &#125;&#125;class Phone2&#123; //synchronized 修饰的对象锁的是方法的调用者 //两个方法用的是同一个锁 谁先拿到谁执行 public synchronized void sendmsm()&#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; public synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125; //这里没有锁 ， 因此在调用的时候可以直接输出 ， 不受锁的影响 public void hello()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 第三组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.timous.lock8;import java.util.concurrent.TimeUnit;/** * 8锁 就是关于锁的8个问题 * 5.增加两个静态的同步方法 是先打电话还是先发短信 是先发短信 跟前面的是不一样的 * 6. 两个对象 两个方法 这个时候的话 还是发短信 不是打电话 * 因为锁的是模板 不是方法的调用者 两个的class是一样的锁的是class */public class Test3 &#123; public static void main(String[] args) &#123; //两个对象 Phone3 phone3 = new Phone3(); Phone3 phone4 = new Phone3(); //这个是先调用的是错误的 是有锁的问题 new Thread(()-&gt;&#123; phone3.sendmsm(); &#125;,&quot;A&quot;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; phone4.call(); &#125;,&quot;B&quot;).start(); &#125;&#125;//Phone3 只有唯一的class 全局唯一class Phone3&#123; //static 在设置的时候锁的是class 类一加载就有了 是模板 public static synchronized void sendmsm()&#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; public static synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125; //这里没有锁 ， 因此在调用的时候可以直接输出 ， 不受锁的影响 public void hello()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 第四组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.timous.lock8;import java.util.concurrent.TimeUnit;/** * 8锁 就是关于锁的8个问题 * 7. 一个静态同步方法 一个普通的同步方法 先打电话 然后 再发短信 * 8.两个对象，输出的是啥 依然是打电话 然后发短信 */public class Test4 &#123; public static void main(String[] args) &#123; //两个对象 Phone4 phone = new Phone4(); Phone4 phone1 = new Phone4(); //这个是先调用的是错误的 是有锁的问题 new Thread(()-&gt;&#123; phone.sendmsm(); &#125;,&quot;A&quot;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; phone1.call(); &#125;,&quot;B&quot;).start(); &#125;&#125;//Phone3 只有唯一的class 全局唯一class Phone4&#123; //锁的类模板 //静态的同步方法 public static synchronized void sendmsm()&#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; //普通的同步方法 //锁的是方法的调用者 public synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125; //这里没有锁 ， 因此在调用的时候可以直接输出 ， 不受锁的影响 public void hello()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 小结new this 具体的一个手机 static 是唯一的一个模板 集合类不安全单线程Array安全 List不安全 12345678910111213141516171819202122232425262728293031323334353637package com.timous.unsafe;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.UUID;import java.util.concurrent.CopyOnWriteArrayList;/** * java.util.ConcurrentModificationException 并发修改异常 * 并发下arraylist是不安全的 解决方案 Vector 默认就是安全的 synchronized 解决 * 1. List&lt;String&gt; list = new Vector&lt;&gt;(); 就不会报错了 不要回答这个 @since JDK1.0 * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); * 3. List&lt;String&gt; list = new CopyOnWriteArrayList(); * CopyOnWriteArrayList 比 Vector 好在哪里 Vector 是synchronized 的 所以效率会比较低 */public class ListTest &#123; public static void main(String[] args) &#123;/* List&lt;String&gt; lists = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;); lists.forEach(System.out::println);*/ //collections // CopyOnWrite 写入时复制 COW 计算机程序设计领域的一种优化策略 //多个线程调用的时候 ， list是唯一的 读取的是一个固定的 ， 写入的时候可能会出现覆盖的操作 //写入的时候避免覆盖造成数据问题 写入的时候 复制出来 写完之后吧它set回去 //读写分离 mycat 这些都是读些分离的出来 List&lt;String&gt; list = new CopyOnWriteArrayList(); for (int i = 1; i &lt;= 10; i++) &#123;// list.add(UUID.randomUUID().toString().substring(0,5));// System.out.println(list); new Thread(()-&gt;&#123; list.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(list); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; Set不安全 12345678910111213141516171819202122232425262728package com.timous.unsafe;import java.util.Collections;import java.util.HashSet;import java.util.Set;import java.util.UUID;import java.util.concurrent.CopyOnWriteArraySet;/** * 同理可证 java.util.ConcurrentModificationException 并发修改异常 * Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); * Set&lt;String&gt; set = new CopyOnWriteArraySet(); */public class SetTest &#123; public static void main(String[] args) &#123; //Set&lt;String&gt; set = new HashSet&lt;&gt;();// Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); Set&lt;String&gt; set = new CopyOnWriteArraySet(); for (int i = 1; i &lt;= 30; i++) &#123; new Thread(()-&gt;&#123; set.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(set); &#125; , String.valueOf(i)).start(); &#125; &#125;&#125; hashset的底层是啥HashMap ， 就是用了hashmap的key 1234//set的本质是 map 的 key是无法重复的 PRESENT 是一个固定的数值public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; Map不安全 12345678910111213141516171819202122232425262728293031323334package com.timous.unsafe;import java.util.Collections;import java.util.HashMap;import java.util.Map;import java.util.UUID;import java.util.concurrent.ConcurrentHashMap;/** * static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 * 16 默认的容量 是通过位运算来进行的 *static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; * 最大的容量 也是通过位运算来进行的 *static final float DEFAULT_LOAD_FACTOR = 0.75f; * 加载因子 ， 默认是0.75 * * java.util.ConcurrentModificationException 依然会出现并发安修改异常 企业的开发一般都是有并发问题的 * 1. Map&lt;String, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;()); * 2. Map&lt;String, Object&gt; map = new ConcurrentHashMap&lt;&gt;(); */public class MapTest &#123; public static void main(String[] args) &#123; //map是这样用的吗 默认等价于什么 //工作中不用这个 默认的是原始的参数 0.75 默认的加载因子 16// Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();// Map&lt;String, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;()); Map&lt;String, Object&gt; map = new ConcurrentHashMap&lt;&gt;(); //加载因子 初始化容量 for (int i = 1; i &lt;= 30; i++) &#123; new Thread(()-&gt;&#123; map.put(Thread.currentThread().getName() , UUID.randomUUID().toString().substring(0 ,5)); System.out.println(map); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; Callable 特点 可以有返回值 可以跑出异常 方法不同 run是普通的Runnable 这个是call 关系 代码实现12345678910111213141516171819202122232425262728293031323334353637package com.timous.Callable;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //这种方式不要用了// new Thread(new MyThread()).start();// new Thread().start(); //怎么启动callable MyThread myThread = new MyThread(); //适配类 FutureTask futureTask = new FutureTask(myThread); //会打印几个call 结果会被缓存 也就是直接 去打印一次 第二次就在缓存里面了 new Thread(futureTask , &quot;A&quot;).start(); new Thread(futureTask , &quot;B&quot;).start(); Integer o = (Integer) futureTask.get(); //返回callable的结果 //get方法可能会产生阻塞 把它放大最后 或者使用异步通信 System.out.println(o); &#125;&#125;//class MyThread implements Runnable&#123;////// @Override// public void run() &#123;//// &#125;//&#125;class MyThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(&quot;call()&quot;); return 1024; &#125;&#125; 细节： 有缓存 结果可能需要等待 ， 阻塞 常用的辅助类 CountDownLatch 允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。 123456789101112131415161718192021222324package com.timous.add;import java.util.concurrent.CountDownLatch;//技术器public class CountDownLatchTest &#123; public static void main(String[] args) throws InterruptedException &#123; //总数是6 倒计时 //必须要执行任务的时候用这个 CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i &lt;= 6; i++) &#123; new Thread(()-&gt;&#123; countDownLatch.countDown(); // -1 System.out.println(Thread.currentThread().getName()+&quot;走了！！！&quot;); &#125;).start(); &#125; countDownLatch.await(); //等待计数器归0 然后向下执行 System.out.println(&quot;关门！！！！&quot;); &#125;&#125; 原理: countDownLatch.countDown(); &#x2F;&#x2F; -1 countDownLatch.await(); &#x2F;&#x2F;等待计数器归0 然后向下执行 每次线程调用countDown的时候计数器会减一，假设计数器变为，countDownLatch.await()就会被唤醒执行下面的操作 CyclicBarrier 加法计数器 允许一组线程全部等待彼此达到共同屏障点的同步辅助。 循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。 屏障被称为循环 ，因为它可以在等待的线程被释放之后重新使用。 12345678910111213141516171819202122232425262728package com.timous.add;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierTest &#123; /** * 集齐7个龙珠 然后完成任务 */ public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123; System.out.println(&quot;成功&quot;); &#125;); for (int i = 1; i &lt;= 7; i++) &#123; //lambda能不能操作到变量 i 不能 通过 final 来进行获取 final int temp = i; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + &quot;收集了&quot; +temp+&quot;颗龙珠&quot;); //这个时候回报错 try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;,&quot;A&quot;).start(); &#125; &#125;&#125; SemaPhore 抢车位： 6 量车 3个车位 12345678910111213141516171819202122232425262728293031package com.timous.add;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;public class SemaPhoreTest &#123; public static void main(String[] args) &#123; //线程数量 停车位 Semaphore semaphore = new Semaphore(3); for (int i = 1; i &lt;= 6; i++) &#123; /** * acquire() 得到 * release() 释放 */ new Thread(()-&gt;&#123; try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName()+&quot;得到了车位&quot;); TimeUnit.SECONDS.sleep(2); System.out.println(Thread.currentThread().getName()+&quot;离开了车位&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; semaphore.release(); &#125; &#125; , String.valueOf(i)).start(); &#125; &#125;&#125; 原理： acquire() 得到 已经满了 ， 等待被释放 -1 release() 释放 会将当前的信号量释放 + 1 然后唤醒等待的操作 作用： 多个共享资源互斥的使用！ 控制最大的线程数 读写锁ReadWriteLock 读：可以被多个线程同时读 写： 只能有一个线程去写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.timous.rw;import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * 独占锁 写锁 一次只能被一个线程使用 * 共享锁 读锁 一次可以被多个线程进行读写的 * ReadWriteLock * 读 - 写 不能共存 * 读 - 读 可以共存 * 写 - 写 不能共存 */public class ReadWriteLockTest &#123; public static void main(String[] args) &#123; MyCache myCache = new MyCache(); //写入 for (int i = 1; i &lt;= 5; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; myCache.put(temp+&quot;&quot; , temp+&quot;&quot;); &#125; , String.valueOf(i)).start(); &#125; //读取 for (int i = 1; i &lt;= 5; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; myCache.get(temp+&quot;&quot;); &#125; , String.valueOf(i)).start(); &#125; &#125;&#125;class MyCache1&#123; private volatile Map&lt;String , Object&gt; map = new HashMap&lt;&gt;(); //存 public void put(String key, Object value)&#123; System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key); map.put(key , value); System.out.println(Thread.currentThread().getName() + &quot;写入ok&quot;); &#125; //取 public void get(String key)&#123; System.out.println(Thread.currentThread().getName() + &quot;读出&quot; + key); map.get(key); System.out.println(Thread.currentThread().getName() + &quot;读出ok&quot;); &#125;&#125;/** * 加锁 */class MyCache&#123; private volatile Map&lt;String , Object&gt; map = new HashMap&lt;&gt;(); //读写锁 相当于是更加细粒度的操作 private ReadWriteLock readWriteLock= new ReentrantReadWriteLock(); //存 public void put(String key, Object value)&#123; try &#123; readWriteLock.writeLock().lock(); System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key); map.put(key , value); System.out.println(Thread.currentThread().getName() + &quot;写入ok&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; readWriteLock.writeLock().unlock(); &#125; &#125; //取 public void get(String key)&#123; try &#123; readWriteLock.readLock().lock(); System.out.println(Thread.currentThread().getName() + &quot;读出&quot; + key); map.get(key); System.out.println(Thread.currentThread().getName() + &quot;读出ok&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; readWriteLock.readLock().unlock(); &#125; &#125;&#125; 阻塞队列 BlockingQueue ： 不是新的东西 什么情况下 ， 我们会如何使用阻塞队列： 多线程 线程池并发处理 学会使用队列.添加 移除 四组API 抛出异常 不会抛出异常‘ 阻塞等待 超时等待 方式 抛出异常 有返回值 ， 不抛出异常 阻塞等待 超时等待 添加 add offer put offer带参数 移除 remove poll take poll带参数 检测队首元素 element peek 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.timous.bq;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.TimeUnit;public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; test3(); &#125; /** * 抛出异常 */ public static void test()&#123; //队列的大小 ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(arrayBlockingQueue.add(&quot;a&quot;)); System.out.println(arrayBlockingQueue.add(&quot;b&quot;)); System.out.println(arrayBlockingQueue.add(&quot;c&quot;)); System.out.println(&quot;-------------------------&quot;); System.out.println(arrayBlockingQueue.element());// System.out.println(arrayBlockingQueue.add(&quot;d&quot;)); System.out.println(arrayBlockingQueue.remove()); System.out.println(arrayBlockingQueue.remove()); System.out.println(arrayBlockingQueue.remove()); System.out.println(arrayBlockingQueue.remove()); &#125; /** * 有返回值 但是不抛出异常 */ public static void test1() &#123; //队列的大小 ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(arrayBlockingQueue.offer(&quot;a&quot;)); System.out.println(arrayBlockingQueue.offer(&quot;b&quot;)); System.out.println(arrayBlockingQueue.offer(&quot;c&quot;));// System.out.println(arrayBlockingQueue.offer(&quot;d&quot;)); System.out.println(arrayBlockingQueue.peek()); //返回队首的元素 System.out.println(arrayBlockingQueue.poll()); System.out.println(arrayBlockingQueue.poll()); System.out.println(arrayBlockingQueue.poll()); System.out.println(arrayBlockingQueue.poll()); // null 不抛出异常 &#125; /** * 等待阻塞 * 一直 * 等待超时 */ public static void test2() throws InterruptedException &#123; //队列的大小 ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3); // 一直阻塞 arrayBlockingQueue.put(&quot;a&quot;); arrayBlockingQueue.put(&quot;b&quot;); arrayBlockingQueue.put(&quot;c&quot;);// arrayBlockingQueue.put(&quot;d&quot;);//队列没有位置了会一直等待 一直阻塞 下面会一直等待 System.out.println(arrayBlockingQueue.take()); System.out.println(arrayBlockingQueue.take()); System.out.println(arrayBlockingQueue.take()); &#125; /** * 超时退出 */ public static void test3() throws InterruptedException &#123; //队列的大小 ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(arrayBlockingQueue.offer(&quot;a&quot;)); System.out.println(arrayBlockingQueue.offer(&quot;b&quot;)); System.out.println(arrayBlockingQueue.offer(&quot;c&quot;)); System.out.println(arrayBlockingQueue.offer(&quot;d&quot; , 2 , TimeUnit.SECONDS));//超过2秒直接返回没有加入false System.out.println(arrayBlockingQueue.poll(2, TimeUnit.SECONDS)); System.out.println(arrayBlockingQueue.poll(2, TimeUnit.SECONDS)); System.out.println(arrayBlockingQueue.poll(2, TimeUnit.SECONDS)); System.out.println(arrayBlockingQueue.poll(2, TimeUnit.SECONDS));//超时直接返回null &#125;&#125; SynchronousQueue 进去一个元素 必须取出来然后再在里面放置元素 1234567891011121314151617181920212223242526272829303132333435363738package com.timous.bq;import java.util.concurrent.SynchronousQueue;/** * 同步队列的测试 */public class SynchronousQueueTest &#123; public static void main(String[] args) &#123; /** * 和其他的是不一样的 ， 我们这个是不存储元素的 只要put 一个元素 ， 必须从里面先取出来一个元素，否则 不能再加入元素 */ SynchronousQueue synchronousQueue = new SynchronousQueue&lt;String&gt;(); //同步队列 //放入值 new Thread(()-&gt;&#123; try &#123; System.out.println(Thread.currentThread().getName()+&quot;put 1&quot;); synchronousQueue.put(&quot;1&quot;); System.out.println(Thread.currentThread().getName()+&quot;put 1&quot;); synchronousQueue.put(&quot;2&quot;); System.out.println(Thread.currentThread().getName()+&quot;put 1&quot;); synchronousQueue.put(&quot;3&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; , &quot;t1&quot;).start(); //取出值 new Thread(()-&gt;&#123; try &#123; System.out.println(Thread.currentThread().getName()+&quot;====&quot;+synchronousQueue.take()); System.out.println(Thread.currentThread().getName()+&quot;====&quot;+synchronousQueue.take()); System.out.println(Thread.currentThread().getName()+&quot;====&quot;+synchronousQueue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; , &quot;t2&quot;).start(); &#125;&#125; 学了技术不会用 ， 看的少 ， 我们要多看多学 ， 多看视频 ， 不敲代码也可以 线程池（重点） 池化技术 程序的运行 ， 本质： 占用系统资源 ！ 优化资源的使用 ， 每次在创建线程和销毁的时候都会耗费大量资源 - 》 池化技术 线程池 连接池 内存池 对象池 jdbc 最大的 最小的 不让不停地开和关 池化技术： 实现准备好一些资源 ， 有人要用的话 ， 就到哪去拿 ， 用完之后 ， 再还给它 默认是：2 max 根据电脑去设置 cpu密集和io密集 线程池的好处： 降低资源的消耗 提高响应的速度 方便管理 &#x3D;&#x3D;线程可以服用 ， 可以控制最大并发数 ， 可以管理我们的线程&#x3D;&#x3D; 线程池三大方法、七大参数 、四种拒绝策略 [强制] 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则 ， 规避资源的耗尽的风险 ， 说明： Executors返回的线程池对象的弊端如下： FixedThreadPool 和SingleThreadPool 允许请求队列长度为Integer.MAX_VALUE,可能会堆积大量的请求 ， 从而导致OOM CacheThreadPool和ScheduledThreadPool 允许创建线程数量为Integer.MAX_VALUE ， 可能会创建大量的线程 ， 导致OOM 三大方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.timous.pool;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Executors * 使用了线程池之后， 要使用线程池创建 */public class Test01 &#123; public static void main(String[] args) &#123;// ExecutorService executorService = Executors.newSingleThreadExecutor();//创建单个线程 ExecutorService executorService = Executors.newFixedThreadPool(5);//创建一个固定数量的线程池// ExecutorService executorService = Executors.newCachedThreadPool();//遇强则强 ， 遇弱则弱 try &#123; for (int i = 1; i &lt;= 100; i++) &#123; executorService.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;ok&quot;); &#125;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; executorService.shutdown(); &#125; &#125;&#125;//newSingleThreadExecutorpublic static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;//newFixedThreadPoolpublic static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;//newCachedThreadPoolpublic static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;//本质：ThreadPoolExecutorpublic ThreadPoolExecutor(int corePoolSize, //核心线程池带下 int maximumPoolSize,//最大的线程池大小 long keepAliveTime,//超时没有人调用就会释放 TimeUnit unit,//超时的单位 BlockingQueue&lt;Runnable&gt; workQueue,// 阻塞队列 ThreadFactory threadFactory, // 线程工厂 创建线程的 一般不用动 RejectedExecutionHandler handler // 拒绝策略 ) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 七大参数和四种拒绝策略1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.timous.pool;import java.util.concurrent.Executors;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Test2 &#123; public static void main(String[] args) &#123; /** * 自定义线程池 */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 5, 3, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(3), Executors.defaultThreadFactory(),// new ThreadPoolExecutor.CallerRunsPolicy()//那来的去哪里// new ThreadPoolExecutor.AbortPolicy() // 银行满了 ， 还有人进来 如果队列满了 ， 还有人进来 ， 就抛出异常// new ThreadPoolExecutor.DiscardOldestPolicy() // 队列满了 ， 不会抛出异常 ， 丢掉任务 new ThreadPoolExecutor.DiscardOldestPolicy() // 和第一个尝试竞争 ， 如果成功就会执行 ， 不成功就会丢掉 ， 不会抛出异常 ); /** * 测试 */ try &#123; // 最大 ： Deque + max //超过 java.util.concurrent.RejectedExecutionException 会跑出异常 for (int i = 1; i &lt;= 9; i++) &#123; threadPoolExecutor.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;ok&quot;); &#125;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; threadPoolExecutor.shutdown(); &#125; &#125;&#125; 小结和拓展最大的线程池如何去定义 最大线程到底该如何定义： CPU密集型 4核 4条线程同时执行 几核的CPU就定义为几 ， 可以保证CPU的效率最高Runtime.getRuntime().availableProcessors() IO密集型 程序 15 个大型任务 ， IO十分占用资源 ， 至少留15个线程 判断程序中十分耗IO的线程有多少个 ， 只要大于这个就行 ， 一般设置为两倍 ， 不会造成系统的阻塞 四大函数式接口（重要）新时代的程序员 ， 必须要会的操作 lambda表达式 ， 链式编程 ， 函数式接口 ， Stream流式计算 函数式接口是什么东西？只有一个方法的接口 123456789@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125;//会有很多的FunctionalInterface//简化编程模型 ， 在新版本的框架 ， 底层大量应用//消费者类的函数式接口public void forEach(Consumer&lt;? super E&gt; action) 代码测试：Function函数式接口 123456789101112131415161718192021222324252627package com.timous.function;import java.util.function.Consumer;import java.util.function.Function;/** * Function * 有一个输入参数 ， 有一个输出 */public class Test01 &#123; public static void main(String[] args) &#123;// // 输出输入的值// Function function = new Function&lt;String , String&gt;() &#123;// @Override// public String apply(String str) &#123;// return str;// &#125;// &#125;;//// System.out.println(function.apply(&quot;123&quot;)); Function function = (str) -&gt; &#123; return &quot;123&quot;; &#125;; System.out.println(function.apply(&quot;123&quot;)); &#125;&#125; Predict断定性接口 1234567891011121314151617181920package com.timous.function;import java.util.function.Predicate;public class Test02 &#123; public static void main(String[] args) &#123;// Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;()&#123;// //判断字符串是够为空// @Override// public boolean test(String str) &#123;// return str.isEmpty();// &#125;// &#125;; Predicate&lt;String&gt; predicate = (str)-&gt;&#123; return str.isEmpty(); &#125;; System.out.println(predicate.test(&quot;123&quot;)); &#125;&#125; Consumer 消费型接口 1234567891011121314151617181920212223package com.timous.function;import java.util.function.Consumer;/** * Consumer 消费型接口 只有输入 ， 没有返回值 */public class Test03 &#123; public static void main(String[] args) &#123;// Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;()&#123;// @Override// public void accept(String str) &#123;// System.out.println(str);// &#125;// &#125;; Consumer&lt;String&gt; consumer = (str)-&gt;&#123; System.out.println(str); &#125;; consumer.accept(&quot;123212&quot;); &#125;&#125; 可以打印字符串 Supplier供给型接口 123456789101112131415161718package com.timous.function;import java.util.function.Supplier;public class Test04 &#123; public static void main(String[] args) &#123;// Supplier supplier = new Supplier&lt;Integer&gt;()&#123;// @Override// public Integer get() &#123;// return 1024;// &#125;// &#125;; Supplier supplier = ()-&gt;&#123; return 1024; &#125;; System.out.println(supplier.get()); &#125;&#125; Stream流式计算什么是Stream流式计算 存储 计算存储： mysql 等 本质是用来存储的 计算： 我们要交给流来操作 Scales 123456789101112131415161718192021222324252627282930313233package com.timous.stream;import java.util.Arrays;import java.util.List;import java.util.stream.Stream;/** * 题目要求： 一分钟内完成此题，只能用一行代码来实现 * 现在有5个用户 ， 筛选 * 1. ID 必须是偶数 * 2. 年龄必须大于23岁 * 3. 用户名转为大写字母 * 4. 用户名字母倒着排序 * 5. 只输出一个用户 */public class Test &#123; public static void main(String[] args) &#123; User user1 = new User(1 , &quot;a&quot;,21); User user2 = new User(2 , &quot;b&quot;,22); User user3 = new User(3 , &quot;c&quot;,23); User user4 = new User(4 , &quot;d&quot;,24); User user5 = new User(6, &quot;e&quot;,25); //集合就是存储 List&lt;User&gt; list = Arrays.asList(user1 , user2 , user3 , user4 , user5); //计算就是交给Stream流 来进行的 //链式编程 list.stream() .filter(u-&gt;&#123;return u.getId()%2==0;&#125;) .filter(u-&gt;&#123;return u.getAge() &gt; 23;&#125;) .map(u-&gt;&#123;return u.getName().toUpperCase();&#125;) .sorted((u1 , u2)-&gt;&#123; return u2.compareTo(u1);&#125;) .limit(1) .forEach(System.out::println); &#125;&#125; ForkJoin什么是ForkJoin在jdk1.7就有了 ， 开始执行任务 ， 提高效率 ， 大数据量 大数据： 把大人物拆分成为小任务 ForkJoin工作特点： 工作窃取 例子 测试123456789101112131415161718192021222324252627282930313233343536373839404142package com.timous.forkjoin;import java.util.concurrent.RecursiveTask;/** * forkjoin stream * 使用 forkjoin * 1. forkjoinPool * 2. 继承RecursiveTask * 3. 任务拆分 */public class forkjoindemo extends RecursiveTask&lt;Long&gt; &#123; private Long start; private Long end; //临界值 private Long temp = 10000l; public forkjoindemo(Long start, Long end) &#123; this.start = start; this.end = end; &#125; //计算方法 @Override protected Long compute() &#123; if (end - start &lt; temp)&#123; Long sum = 0l; for (Long i = start; i &lt;= end; i++) &#123; sum += i; &#125; return sum; &#125;else &#123; //forkjoin Long middle = (start+end)/2; forkjoindemo task1 = new forkjoindemo(start, middle); //拆分任务 ， 吧任务压入线程队列 task1.fork(); forkjoindemo task2 = new forkjoindemo(middle+1, end); task2.fork(); Long sum = task1.join() + task2.join(); return sum; &#125; &#125;&#125; 测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.timous.forkjoin;import com.timous.tools.Times;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.stream.LongStream;public class Test &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; test(); test1(); test2(); &#125; public static void test() throws ExecutionException, InterruptedException &#123; Times.test(&quot;test&quot;, new Times.Task() &#123; @Override public void execute() &#123; Long sum = 0l; for (Long i = 0l; i &lt;= 10_0000_0000; i++) &#123; sum += i; &#125; System.out.println(sum); &#125; &#125;); &#125; public static void test1() throws ExecutionException, InterruptedException &#123; Times.test(&quot;test1&quot;, new Times.Task() &#123; @Override public void execute() throws ExecutionException, InterruptedException &#123; ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask&lt;Long&gt; task = new forkjoindemo(0l, 10_0000_0000l); ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task); Long sum = submit.get(); System.out.println(sum); &#125; &#125;); &#125; public static void test2() throws ExecutionException, InterruptedException &#123; Times.test(&quot;test2&quot;, new Times.Task() &#123; @Override public void execute() &#123; // Stream 并行流 long reduce = LongStream.rangeClosed(0l, 10_0000_0000l).parallel().reduce(0, Long::sum); System.out.println(reduce); &#125; &#125;); &#125;&#125; forkjoin在大数据量的时候使用 ， 小的数据不会去使用这些 异步回调Future 未来： 可以对将来的某个时间的结果进行建模 ， 1234567891011121314151617181920212223242526272829303132333435363738package com.timous.future;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;/** * 异步调用Ajax * 异步执行 * 成功回调 * 失败回调 */public class Test &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //发起一个请求 //没有返回值的runAsync 异步回调// CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(()-&gt;&#123;//// System.out.println(Thread.currentThread().getName()+&quot;runAsync&quot;);// &#125;);//// System.out.println(21111);// //阻塞获取执行结果// completableFuture.get(); CompletableFuture&lt;Integer&gt; uCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(Thread.currentThread().getName()+&quot;supplyAsync-&gt;Integer&quot;); int i = 10/0; return 1024; &#125;); System.out.println(uCompletableFuture.whenComplete((T, U) -&gt; &#123; System.out.println(&quot;T:&quot; + T + &quot;,U:&quot; + U); //java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero &#125;).exceptionally((e) -&gt; &#123; e.getMessage(); return 233;//可以获得错误的返回结果 &#125;).get()); &#125;&#125; 理解JMM请你谈谈你对Volatile的理解 Volatile是一个java的虚拟机提供的一个&#x3D;&#x3D;轻量级&#x3D;&#x3D;的同步机制 Sychronized 保证可见性 不保证原子性 禁止指令重排 什么是JMM？ JVM是java虚拟机 JMM是java内存模行 ， 不存在的东西 ， 概念 ， 约定 关于JMM的约定： 线程的解锁必须把共享变量&#x3D;&#x3D;立刻&#x3D;&#x3D; 线程加锁前 ， 必须读取主存中的最新值到工作内存当中去 加的锁和解得锁必须是同一把锁 线程： 工作内存 、 主内存 线程B修改了值 ， 但是A不会不会立即更新这个值 内存交互操作 内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外） lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态 unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用 load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中 use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令 assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中 store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用 write （写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中 JMM对这八种指令的使用，制定了如下规则： 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存 不允许一个线程将没有assign的数据从工作内存同步回主内存 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量 对一个变量进行unlock操作之前，必须把此变量同步回主内存 程序不知道主内存已经改变了 ， 我们需要改变 Volatile保证可见性12345678910111213141516171819202122package com.timous.Volatile;import java.util.concurrent.TimeUnit;public class JmmDemo &#123; private volatile static int num=0;// 不加volatile 就会死循环 ， 也就是没有可见性 public static void main(String[] args) &#123;//main线程 new Thread(()-&gt;&#123; // 线程的主内存这里不知道 while (num == 0)&#123; &#125; &#125;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; num = 1; System.out.println(num); &#125;&#125; 不保证原子性不可分割 线程A 在执行业务的时候是不能被干扰的 ， 也不能被分割要么同时成功 ， 要么同时失败 12345678910111213141516171819202122232425package com.timous.Volatile;// 不保证原子性public class VDemo &#123; private volatile static int num = 0; //看出来不能保证原子性 如果在add方法前面加上synchronized的话是可以成功的 public static void add()&#123; num++; &#125; public static void main(String[] args) &#123; //理论上 num是20000 ， 但是 在多线程里面就会出现问题 for (int i = 1; i &lt;= 20; i++) &#123; new Thread(()-&gt;&#123; for (int j = 1; j &lt;= 1000; j++) &#123; add(); &#125; &#125;).start(); &#125; while(Thread.activeCount()&gt;2)&#123; Thread.yield(); &#125; System.out.println(Thread.currentThread().getName()+&quot;&quot;+num); &#125;&#125; 如果不加Lock和synchronized ， 如何保证原子性？ num++ 不是一个原子性操作 会使用这个来进行处理我们的各种变量 ， 解决原子性问题 原子类为啥能折磨做？ 1num.getAndIncrement(); // +1方法 并不是一个简单的+1操作 ， CAS 这些类的底层都和底层的操作系统相关 ， UnSafe类是一个很特殊的存在 ， CAS里会讲 禁止指令重排：什么是指令重排： 你写的程序 ， 计算机并不是按照你写的那样执行的。 源代码 编译器优化你的代码 指令并行也可能会重排 内存系统可能也会进行重排 &#x3D;&#x3D;处理器在进行指令重排的时候会考虑： 数据之间的依赖性&#x3D;&#x3D; 12345int x = 1 ;int y = 2 ;x = x + 5 ;y = x * x ;//我们所期望的是 从上到下 可能是 2 1 3 4 或者是其他的顺序 可能造成影响的结果: A , B ,X , Y 默认都是0 线程A 线程B x &#x3D; A Y &#x3D; B B &#x3D; 1 A &#x3D; 2 x 0 y 0 , 但是在指令重排的时候会出现问题 ， 因此 ， 这个时候会禁止指令重排的 1000万次 ， 不一定出现一次 ， 可以避免指令重排 ？ 非计算机专业 ， 不要听懂了 ， CPU ， 内存屏障，CPU指令作用; 保证特定的操作的执行顺序 可以保证某些变量的内存可见性 利用这些特性 ， 我们的volatile就会有可见性 Volatile能够保证我们的可见性 ， 不能保证原子性， 由于我们的内存屏障 ， 可以避免我们的 ， 在单例模式使用的最多 彻底玩转单例模式饿汉式 ， DCL懒汉式 123456789101112131415161718package com.timous.single;/** * 饿汉式单例模式 */public class Hungry &#123; private byte[] data1 = new byte[1024*1024] ; private byte[] data2 = new byte[1024*1024] ; private byte[] data3 = new byte[1024*1024] ; private byte[] data4 = new byte[1024*1024] ; private Hungry()&#123; &#125; private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance()&#123; return HUNGRY; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.timous.single;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.time.Instant;/** * 懒汉式单例模式 DCL 道高一尺 ， 魔高一丈 */public class Lazy &#123; private static boolean timous = false; private Lazy()&#123; synchronized (Lazy.class)&#123; if (timous == false)&#123; timous = true; &#125;else&#123; throw new RuntimeException(&quot;不要试图使用反射区破坏单例！！！&quot;); &#125; if(lazy != null)&#123; throw new RuntimeException(&quot;不要试图使用反射区破坏单例！！！&quot;); &#125; &#125; System.out.println(Thread.currentThread().getName()+&quot;ok&quot;); &#125; private volatile static Lazy lazy; //双重检测锁模式的懒汉式单例 DCL懒汉式单例 public static Lazy getInstance()&#123; if (lazy == null)&#123; synchronized (Lazy.class)&#123; if(lazy == null)&#123; lazy = new Lazy(); // 不是一个原子性操作 // 分配内存空间 执行构造方法（初始化对象） 吧这个对象只想空间 指令重排 &#125; &#125;; &#125; return lazy;//此时lazy 没有完成构造 我们要保证避免指令重排 &#125; //单线程下 单例是可以的 ，我们在进行多线程的时候就会出现问题// public static void main(String[] args) &#123;// for (int i = 0; i &lt; 10; i++) &#123;// new Thread(()-&gt;&#123;// Lazy.getInstance();// &#125;).start();// &#125;// &#125; //反射 public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;// Lazy lazy = Lazy.getInstance(); Field timous = Lazy.class.getDeclaredField(&quot;timous&quot;); timous.setAccessible(true); Constructor&lt;Lazy&gt; declaredConstructor = Lazy.class.getDeclaredConstructor(null); declaredConstructor.setAccessible(true); Lazy lazy1 = declaredConstructor.newInstance(); timous.set(lazy1 , false); Lazy lazy2 = declaredConstructor.newInstance(); System.out.println(lazy2); System.out.println(lazy1); &#125;&#125; 静态内部类1234567891011121314151617181920212223242526package com.timous.single;import com.sun.org.apache.bcel.internal.generic.RET;import java.util.PrimitiveIterator;/** * 静态内部类 * * 这些都是不安全的 */public class Holder &#123; private Holder()&#123; &#125; public static Holder getInstance()&#123; return InnerClass.HOLDER; &#125; public static class InnerClass&#123; private static final Holder HOLDER = new Holder(); &#125;&#125; 单例模式不安全 ，因为有反射 ， 枚举：12345678910111213141516171819202122232425262728293031package com.timous.single;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * enum 是一个什么 本身也是一个class类 */public enum EnumSingle &#123; INSTANCE; public EnumSingle getInstance()&#123; return INSTANCE; &#125;&#125;class Test&#123; //会产生一个午餐的构造方法 public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;// EnumSingle instance1 = EnumSingle.INSTANCE;// EnumSingle instance2 = EnumSingle.INSTANCE;// System.out.println(instance1);// System.out.println(instance2); EnumSingle instance = EnumSingle.INSTANCE; Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class , int.class); declaredConstructor.setAccessible(true); EnumSingle instance1 = declaredConstructor.newInstance(); //java.lang.NoSuchMethodException 我们的探究失败了 通过反编译也看到 ， 我们的也是有一个空参的构造 System.out.println(instance); System.out.println(instance1); &#125;&#125; 枚举类型的最终反编译源码是没有一个空参的构造方式 ， 只有一个String ， int的构造方法 深入理解CAS什么是CAS为啥要学CAS ， 大厂必须要会这些底层的东西 ！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336/* * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * * * * * * * * * * * * * * * * * * * *//* * * * * * * Written by Doug Lea with assistance from members of JCP JSR-166 * Expert Group and released to the public domain, as explained at * http://creativecommons.org/publicdomain/zero/1.0/ */package java.util.concurrent.atomic;import java.util.function.IntUnaryOperator;import java.util.function.IntBinaryOperator;import sun.misc.Unsafe;/** * An &#123;@code int&#125; value that may be updated atomically. See the * &#123;@link java.util.concurrent.atomic&#125; package specification for * description of the properties of atomic variables. An * &#123;@code AtomicInteger&#125; is used in applications such as atomically * incremented counters, and cannot be used as a replacement for an * &#123;@link java.lang.Integer&#125;. However, this class does extend * &#123;@code Number&#125; to allow uniform access by tools and utilities that * deal with numerically-based classes. * * @since 1.5 * @author Doug Lea*/public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; /** * Creates a new AtomicInteger with the given initial value. * * @param initialValue the initial value */ public AtomicInteger(int initialValue) &#123; value = initialValue; &#125; /** * Creates a new AtomicInteger with initial value &#123;@code 0&#125;. */ public AtomicInteger() &#123; &#125; /** * Gets the current value. * * @return the current value */ public final int get() &#123; return value; &#125; /** * Sets to the given value. * * @param newValue the new value */ public final void set(int newValue) &#123; value = newValue; &#125; /** * Eventually sets to the given value. * * @param newValue the new value * @since 1.6 */ public final void lazySet(int newValue) &#123; unsafe.putOrderedInt(this, valueOffset, newValue); &#125; /** * Atomically sets to the given value and returns the old value. * * @param newValue the new value * @return the previous value */ public final int getAndSet(int newValue) &#123; return unsafe.getAndSetInt(this, valueOffset, newValue); &#125; /** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful. False return indicates that * the actual value was not equal to the expected value. */ public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; /** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * &lt;p&gt;&lt;a href=&quot;package-summary.html#weakCompareAndSet&quot;&gt;May fail * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is * only rarely an appropriate alternative to &#123;@code compareAndSet&#125;. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful */ public final boolean weakCompareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; /** * Atomically increments by one the current value. * * @return the previous value */ public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1); &#125; /** * Atomically decrements by one the current value. * * @return the previous value */ public final int getAndDecrement() &#123; return unsafe.getAndAddInt(this, valueOffset, -1); &#125; /** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the previous value */ public final int getAndAdd(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta); &#125; /** * Atomically increments by one the current value. * * @return the updated value */ public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1; &#125; /** * Atomically decrements by one the current value. * * @return the updated value */ public final int decrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, -1) - 1; &#125; /** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the updated value */ public final int addAndGet(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta) + delta; &#125; /** * Atomically updates the current value with the results of * applying the given function, returning the previous value. The * function should be side-effect-free, since it may be re-applied * when attempted updates fail due to contention among threads. * * @param updateFunction a side-effect-free function * @return the previous value * @since 1.8 */ public final int getAndUpdate(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return prev; &#125; /** * Atomically updates the current value with the results of * applying the given function, returning the updated value. The * function should be side-effect-free, since it may be re-applied * when attempted updates fail due to contention among threads. * * @param updateFunction a side-effect-free function * @return the updated value * @since 1.8 */ public final int updateAndGet(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return next; &#125; /** * Atomically updates the current value with the results of * applying the given function to the current and given values, * returning the previous value. The function should be * side-effect-free, since it may be re-applied when attempted * updates fail due to contention among threads. The function * is applied with the current value as its first argument, * and the given update as the second argument. * * @param x the update value * @param accumulatorFunction a side-effect-free function of two arguments * @return the previous value * @since 1.8 */ public final int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction) &#123; int prev, next; do &#123; prev = get(); next = accumulatorFunction.applyAsInt(prev, x); &#125; while (!compareAndSet(prev, next)); return prev; &#125; /** * Atomically updates the current value with the results of * applying the given function to the current and given values, * returning the updated value. The function should be * side-effect-free, since it may be re-applied when attempted * updates fail due to contention among threads. The function * is applied with the current value as its first argument, * and the given update as the second argument. * * @param x the update value * @param accumulatorFunction a side-effect-free function of two arguments * @return the updated value * @since 1.8 */ public final int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction) &#123; int prev, next; do &#123; prev = get(); next = accumulatorFunction.applyAsInt(prev, x); &#125; while (!compareAndSet(prev, next)); return next; &#125; /** * Returns the String representation of the current value. * @return the String representation of the current value */ public String toString() &#123; return Integer.toString(get()); &#125; /** * Returns the value of this &#123;@code AtomicInteger&#125; as an &#123;@code int&#125;. */ public int intValue() &#123; return get(); &#125; /** * Returns the value of this &#123;@code AtomicInteger&#125; as a &#123;@code long&#125; * after a widening primitive conversion. * @jls 5.1.2 Widening Primitive Conversions */ public long longValue() &#123; return (long)get(); &#125; /** * Returns the value of this &#123;@code AtomicInteger&#125; as a &#123;@code float&#125; * after a widening primitive conversion. * @jls 5.1.2 Widening Primitive Conversions */ public float floatValue() &#123; return (float)get(); &#125; /** * Returns the value of this &#123;@code AtomicInteger&#125; as a &#123;@code double&#125; * after a widening primitive conversion. * @jls 5.1.2 Widening Primitive Conversions */ public double doubleValue() &#123; return (double)get(); &#125;&#125; CAS比较当前工作内存中的值 ， 和主内存中的值 ， 如果这个值是期望的 ， 那么就执行操作！ 如果不是就一直循环！！！ 缺点： 循环会耗时 一次性只能保证一个共享变量的原子性 ABA问题 cas ABA问题（狸猫换太子） 1234567891011121314151617181920212223242526package com.timous.cas;import java.util.concurrent.atomic.AtomicInteger;public class CasDemo &#123; //cas public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(2020); /** * expect 期望 update 更新 * public final boolean compareAndSet(int expect, int update) &#123; * return unsafe.compareAndSwapInt(this, valueOffset, expect, update); * &#125; * 如果期望的值达到了 ， 就更新 ， 否则 ， 不更新 cas 是 CPU的并发原语 */ // 对于我们平时写的sql 乐观锁 System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(2021, 2020)); System.out.println(atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(2020, 6666)); System.out.println(atomicInteger.get()); &#125;&#125; 如何解决 原子引用带版本号的原子操作 对应的是乐观锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.timous.cas;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicStampedReference;public class CasDemo &#123; //cas public static void main(String[] args) &#123;// AtomicInteger atomicInteger = new AtomicInteger(2020); //注意： 如果泛型是一个包装类 ， 注意引用的问题 乐观锁的原理相同 AtomicStampedReference&lt;Integer&gt; atomicInteger = new AtomicStampedReference&lt;&gt;(1, 1); new Thread(()-&gt;&#123; int stamp = atomicInteger.getStamp(); // 获得版本号 System.out.println(stamp); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicInteger.compareAndSet(1, 2, atomicInteger.getStamp(), atomicInteger.getStamp() + 1)); int stamp2 = atomicInteger.getStamp(); // 获得版本号 System.out.println(stamp2); System.out.println(&quot;-----&gt;&quot;+atomicInteger.compareAndSet(2, 1, atomicInteger.getStamp(), atomicInteger.getStamp() + 1)); &#125; , &quot;A&quot;).start(); new Thread(()-&gt;&#123; int stamp = atomicInteger.getStamp(); // 获得版本号 System.out.println(&quot;=====&quot;+stamp); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicInteger.compareAndSet(1, 66, stamp, stamp + 1)); int stamp1 = atomicInteger.getStamp(); System.out.println(stamp1); &#125; , &quot;B&quot;).start(); /** * * expect 期望 update 更新 * public final boolean compareAndSet(int expect, int update) &#123; * return unsafe.compareAndSwapInt(this, valueOffset, expect, update); * &#125; * 如果期望的值达到了 ， 就更新 ， 否则 ， 不更新 cas 是 CPU的并发原语 */ // 对于我们平时写的sql 乐观锁// System.out.println(atomicInteger.compareAndSet(2020, 2021));// System.out.println(atomicInteger.get());// System.out.println(atomicInteger.compareAndSet(2021, 2020));// System.out.println(atomicInteger.get());// System.out.println(atomicInteger.compareAndSet(2020, 6666));// System.out.println(atomicInteger.get()); &#125;&#125; 各种锁的理解公平锁 ， 非公平锁公平锁： 非常公平 ， 不能插队 非公平锁：非常不公平 ， 可以插队 ， 后面的可以插到前面的 （默认都是非公平的） 可重入锁递归锁 ， 也就是可重入锁 拿到了外面的锁 ， 就可以拿到里面的锁 ， 是自动获取的 Demo01 123456789101112131415161718192021222324252627282930313233343536package com.timous.lock;import java.util.concurrent.TimeUnit;// sychronizedpublic class Demo01 &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); new Thread(()-&gt;&#123; try &#123; phone.sms(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; , &quot;A&quot;).start(); new Thread(()-&gt;&#123; try &#123; phone.sms(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; , &quot;B&quot;).start(); &#125;&#125;class Phone&#123; public synchronized void sms() throws InterruptedException &#123; System.out.println(Thread.currentThread().getName()+&quot;sms&quot;); TimeUnit.SECONDS.sleep(2); call(); &#125; public synchronized void call()&#123; System.out.println(Thread.currentThread().getName()+&quot;call&quot;); &#125;&#125; lock 123456789101112131415161718192021222324252627282930313233343536373839404142package com.timous.lock;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Demo02 &#123; public static void main(String[] args) &#123; Phone1 phone1 = new Phone1(); new Thread(()-&gt;&#123; phone1.sms(); &#125; , &quot;A&quot;).start(); new Thread(()-&gt;&#123; phone1.sms(); &#125; , &quot;B&quot;).start(); &#125;&#125;class Phone1&#123; Lock lock = new ReentrantLock(); // lock 必须配对 ， 否则必须配对 public void sms()&#123; try &#123; lock.lock(); System.out.println(Thread.currentThread().getName()+&quot;sms&quot;); call(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; private void call() &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName()+&quot;call&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; 自旋锁 会不断尝试 ， 一直到成功 自定义的自旋锁 123456789101112131415161718192021222324252627package com.timous.lock;import java.util.concurrent.atomic.AtomicReference;/** * 自旋锁 */public class SpinLockDemo &#123; // Thread null AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); //加锁 public void mylock()&#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName()+&quot;----&gt; mylock&quot;); //自旋锁 while (!atomicReference.compareAndSet(null , thread))&#123; &#125; &#125; //解锁 public void myunlock()&#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName()+&quot;----&gt; myunlock&quot;); //自旋锁 atomicReference.compareAndSet(thread , null); &#125;&#125; 测试： 1234567891011121314151617181920212223242526272829303132package com.timous.lock;import com.timous.single.EnumSingle;import java.util.concurrent.TimeUnit;public class Test &#123; public static void main(String[] args) &#123; SpinLockDemo lock = new SpinLockDemo(); new Thread(()-&gt;&#123; lock.mylock(); try &#123; TimeUnit.SECONDS.sleep(3); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.myunlock(); &#125; &#125; , &quot;A&quot;).start(); new Thread(()-&gt;&#123; lock.mylock(); try &#123; TimeUnit.SECONDS.sleep(1); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.myunlock(); &#125; &#125; , &quot;B&quot;).start(); &#125;&#125; 死锁死锁是什么？ 两个线程相互争夺资源 排查死锁 ， 解决问题 jdk bin 1.jps定位进程号 jps -l 2.jstack 进程号 查看思索的信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112C:\\Program Files\\Java\\jdk1.8.0_201\\bin&gt;jstack 162442020-11-01 22:06:42Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.201-b09 mixed mode):&quot;DestroyJavaVM&quot; #13 prio=5 os_prio=0 tid=0x0000000002943800 nid=0x3f0c waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;T2&quot; #12 prio=5 os_prio=0 tid=0x0000000018ab6800 nid=0x11a4 waiting for monitor entry [0x00000000196af000] java.lang.Thread.State: BLOCKED (on object monitor) at com.timous.lock.MyThread.run(DeadLock.java:39) - waiting to lock &lt;0x00000000d63a2b98&gt; (a java.lang.String) - locked &lt;0x00000000d63a2bd0&gt; (a java.lang.String) at java.lang.Thread.run(Thread.java:748)&quot;T1&quot; #11 prio=5 os_prio=0 tid=0x0000000018ab6000 nid=0x37fc waiting for monitor entry [0x00000000195af000] java.lang.Thread.State: BLOCKED (on object monitor) at com.timous.lock.MyThread.run(DeadLock.java:39) - waiting to lock &lt;0x00000000d63a2bd0&gt; (a java.lang.String) - locked &lt;0x00000000d63a2b98&gt; (a java.lang.String) at java.lang.Thread.run(Thread.java:748)&quot;Service Thread&quot; #10 daemon prio=9 os_prio=0 tid=0x00000000189bf800 nid=0x1ce8 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C1 CompilerThread2&quot; #9 daemon prio=9 os_prio=2 tid=0x0000000018929000 nid=0x2880 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C2 CompilerThread1&quot; #8 daemon prio=9 os_prio=2 tid=0x0000000018925800 nid=0x3684 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C2 CompilerThread0&quot; #7 daemon prio=9 os_prio=2 tid=0x000000001891f800 nid=0x3d38 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Monitor Ctrl-Break&quot; #6 daemon prio=5 os_prio=0 tid=0x00000000188ee000 nid=0x3204 runnable [0x0000000018fae000] java.lang.Thread.State: RUNNABLE at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) - locked &lt;0x00000000d642bf08&gt; (a java.io.InputStreamReader) at java.io.InputStreamReader.read(InputStreamReader.java:184) at java.io.BufferedReader.fill(BufferedReader.java:161) at java.io.BufferedReader.readLine(BufferedReader.java:324) - locked &lt;0x00000000d642bf08&gt; (a java.io.InputStreamReader) at java.io.BufferedReader.readLine(BufferedReader.java:389) at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:61)&quot;Attach Listener&quot; #5 daemon prio=5 os_prio=2 tid=0x0000000017500800 nid=0x4dc waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=2 tid=0x00000000174ff800 nid=0xb54 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 tid=0x0000000002a36800 nid=0x1db4 in Object.wait() [0x000000001884e000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000000d6208ed0&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144) - locked &lt;0x00000000d6208ed0&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165) at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=2 tid=0x0000000002a33000 nid=0x4680 in Object.wait() [0x000000001874f000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000000d6206bf8&gt; (a java.lang.ref.Reference$Lock) at java.lang.Object.wait(Object.java:502) at java.lang.ref.Reference.tryHandlePending(Reference.java:191) - locked &lt;0x00000000d6206bf8&gt; (a java.lang.ref.Reference$Lock) at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)&quot;VM Thread&quot; os_prio=2 tid=0x00000000174b7800 nid=0x36c0 runnable&quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x0000000002959000 nid=0x3890 runnable&quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x000000000295a800 nid=0x271c runnable&quot;GC task thread#2 (ParallelGC)&quot; os_prio=0 tid=0x000000000295c000 nid=0x1b74 runnable&quot;GC task thread#3 (ParallelGC)&quot; os_prio=0 tid=0x000000000295e800 nid=0x3dc8 runnable&quot;VM Periodic Task Thread&quot; os_prio=2 tid=0x00000000189da800 nid=0x24fc waiting on conditionJNI global references: 12Found one Java-level deadlock:=============================&quot;T2&quot;: waiting to lock monitor 0x00000000174ddc48 (object 0x00000000d63a2b98, a java.lang.String), which is held by &quot;T1&quot;&quot;T1&quot;: waiting to lock monitor 0x00000000174e0638 (object 0x00000000d63a2bd0, a java.lang.String), which is held by &quot;T2&quot;Java stack information for the threads listed above:===================================================&quot;T2&quot;: at com.timous.lock.MyThread.run(DeadLock.java:39) - waiting to lock &lt;0x00000000d63a2b98&gt; (a java.lang.String) - locked &lt;0x00000000d63a2bd0&gt; (a java.lang.String) at java.lang.Thread.run(Thread.java:748)&quot;T1&quot;: at com.timous.lock.MyThread.run(DeadLock.java:39) - waiting to lock &lt;0x00000000d63a2bd0&gt; (a java.lang.String) - locked &lt;0x00000000d63a2b98&gt; (a java.lang.String) at java.lang.Thread.run(Thread.java:748)Found 1 deadlock. 面试工作中 ， 发现是否有异常 ， &#x3D;&#x3D;查看日志&#x3D;&#x3D; ， &#x3D;&#x3D;查看堆栈的信息&#x3D;&#x3D;","tags":["多线程"]},{"title":"equals和异常","path":"/2021/03/26/equals和异常/","content":"equals和异常equals详解两个对象的值相等，但却可能有不同的hashcode，这句话对不对？两个对象x , y如果满足x.equals（y）&#x3D;&#x3D; true , 它们的哈希码（hashcode）应当相同。Java对于equals方法和hashcode是这样规定的： 如果两个对象相同（equals方法返回true），那么它们的hashcode值一定相同。 如果两个对象的hashcode值相同，它们并不一定相同。当然，你未必按照要求去做，但是如果你违背了上述的原则就会发现使用容器的时候，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希频繁的冲突会造成存取性能几句下降） 异常处理Java异常的分类按照异常处理的时机分类的话有 编译时异常（强制性异常）也叫CheckedException 运行时异常（非强制异常）也叫RunTimeException 异常处理 当前方法知道如何处理该异常，则用 try…catch 块来处理该异常。 当前方法不知道如何处理，则在定义该方法是声明抛出该异常。 测试12345678910public int getNum()&#123; try&#123; int a = 1/0; return 1; &#125;catch(Exception e)&#123; return 2; &#125;finally&#123; return 3; &#125;&#125; 测试 结果为3，代码在遇到第三行的时候遇到异常，会到catch语句中，执行第六行，但是异常机制有这么一个原则，在catch中遇到return的或者异常能够使该函数终止的话，finally就必须先执行完，所以第六行不会返回值，返回的是第八行的值。真正返回的值是3。 常见的RuntimeException java.lang.NullPointerException空指针异常；出现原因是：调用了未经初始化的对象或者是不存在的对象 java.lang.ClassNotFoundException指定的类找不到；出现原因是：类的名称和路径加载错误，通常都是程序试图通过字符串来加载某个类时所发生的异常。 java.lang.NumberFormatException字符串转化为数字异常；出现原因： 字符型数据中包含非数字型字符。 java.langIndexOutOfBoundsException数组角标越界异常，常见于操作数组对象是发生。 java.lang.IllegalArgumentException方法传递参数错误。 java.lang.ClassCastException数据类型转换异常。 java.lang.NoClassDefFoundException未找到类定义错误。 SQLException异常，常见于操作数据库是的SQL语句错误。 java.lang.InstantiationException实例化异常 java.lang.NoSuchMerthodException方法不存在异常。","tags":["面试题"]},{"title":"ShardingJDBC之mysql的主从复制","path":"/2021/03/26/shadingJDBC之mysql主从复制/","content":"ShardingJDBC1.yum安装mysql1.1下载mysql的rpm地址http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64&#x2F; 1.2配置mysql扩展源1rpm -ivh http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql57-community-release-el7-10.noarch.rpm 1.3yum安装mysql1yum install mysql-community-server -y 1.4启动mysql设置开机自启动1234systemctl start mysqldsystemctl status mysqldsystemctl stop mysqldsystemctl enable mysqld 1.5使用mysql初始密码进行登录12345gerp &quot;password&quot; /var/log/mysqld.logmysql -uroot -p出来的密码或者是以下的做法mysql -uroot -p$(awk &#x27;/temporary password/&#123;print $NF&#125;&#x27; /var/log/mysqld.log) 1.6修改数据库的密码数据库的默认的规则是必须携带大小写字母、特殊符号，字符串长度大于8，否则会报错 因此设定较为简单的密码是首先要修改set gloable validate_password_policy和length 12set global validate_password_policy=0;set global validate_password_length=1; 1.7修改密码1234567set password for root@localhost = password(&#x27;123456&#x27;);# 或者alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;# 给用户授权grant all on *.* to root@&#x27;%&#x27; identified by &#x27;123456&#x27;;# 刷新flush privileges; 1.8登录测试 通过测试，能够进行登录 2主从复制的配置2.1Master节点的配置12345678910111213vim /etc/my.cnf[mysqld]## 同一局域网内，注意要唯一server-id=100### 开启二进制日志 可以随便取（关键）log-bin=mysql-bin### 复制过滤： 不需要备份的数据库不输出（mysql库一般不同步）binlog-ignore-db=mysql### 为每个session分配内存，在事务过程中用来存储二进制日志的缓存binlog_cache_size=1M### 主从复制的格式（mixed ， statement ， row 默认格式是statement）binlog_format=mixed 2.2slave节点的配置123456789101112131415161718192021222324252627282930313233vim /etc/my.cnf[mysqld]## 同一局域网内，注意要唯一server-id=102### 开启二进制日志功能 ， 已备份slave作为其他slave的Master时使用log-bin=mysql-slave-bin### relay_log配置中继日志relay_log=edu-mysql-relay-bin### 复制过滤： 不需要备份的数据库不输出（mysql库一般不同步）binlog-ignore-db=mysql### 如果需要同步函数或者是存储过程log_bin_trust_function_creators=true### 为每个session分配内存，在事务过程中用来存储二进制日志的缓存binlog_cache_size=1M### 主从复制的格式（mixed ， statement ， row 默认格式是statement）binlog_format=mixed[mysqld]## 同一局域网内，注意要唯一server-id=101### 开启二进制日志功能 ， 已备份slave作为其他slave的Master时使用log-bin=mysql-slave-bin### relay_log配置中继日志relay_log=edu-mysql-relay-bin### 复制过滤： 不需要备份的数据库不输出（mysql库一般不同步）binlog-ignore-db=mysql### 如果需要同步函数或者是存储过程log_bin_trust_function_creators=true### 为每个session分配内存，在事务过程中用来存储二进制日志的缓存binlog_cache_size=1M### 主从复制的格式（mixed ， statement ， row 默认格式是statement）binlog_format=mixed 2.3在master服务器上进行授权123456789## 登录数据库mysql -uroot -p123456## 进行授权grant replication slave , replication client on *.* to &#x27;root&#x27;@&#x27;47.105.129.77&#x27; identified by &#x27;123456&#x27;;## 刷新权限flush privileges;##查看mysql具有哪些用户及对应的IP权限（可以不执行，只是一个查看）select user , host from mysql.user; 2.4查看对应的binlog文件名和位置（master节点执行）1show master status; 2.5配置从服务器的连接1234## 连接对应的主数据库change master to master_host=&#x27;81.69.232.6&#x27; , master_user=&#x27;root&#x27; , master_password=&#x27;123456&#x27; , master_port=3306, master_log_file=&#x27;mysql-bin.000001&#x27; , master_log_pos=1247;## 启动 2.6经过测试，主从复制就会完成了3.读写分离的springboot实现3.1pom.xml文件配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;top.timous&lt;/groupId&gt; &lt;artifactId&gt;shadingjdbctest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;shadingjdbctest&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;shading-sphere.version&gt;4.0.0-RC1&lt;/shading-sphere.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--web的基本依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis的jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok简化实体类的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--测试的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--shardingjdbc 的starter包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;shading-sphere.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-core-common&lt;/artifactId&gt; &lt;version&gt;$&#123;shading-sphere.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;com.alibaba&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;druid&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;1.2.3&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;top.timous.ShadingjdbctestApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.2yml文件配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950server: port: 8080spring: main: allow-bean-definition-overriding: true shardingsphere: props: sql: show: true #配置数据源 datasource: # ds1 一个主的mysql ds2 和 ds3都是slave从库 names: ds1,ds2,ds3 # 配置数据源的具体的信息 ds1: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://81.69.232.6:3306/ksd_order_db?useUnicide=true&amp;characterEncoding=utf-8&amp;tinyIntlisBit=false&amp;useSSL=false&amp;serverTimeZone=GMT%2b8 username: root password: 123456 maxPoolSize: 100 minPoolSize: 5 ds2: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://121.4.161.181:3306/ksd_order_db?useUnicide=true&amp;characterEncoding=utf-8&amp;tinyIntlisBit=false&amp;useSSL=false&amp;serverTimeZone=GMT%2b8 username: root password: 123456 maxPoolSize: 100 minPoolSize: 5 ds3: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://47.105.129.77:3306/ksd_order_db?useUnicide=true&amp;characterEncoding=utf-8&amp;tinyIntlisBit=false&amp;useSSL=false&amp;serverTimezone=GMT%2b8 username: root password: 123456 maxPoolSize: 100 minPoolSize: 5 # 不配置下面的话写入的时候会出现问题 ， 会报错 下面才是读写分离的 sharding: default-data-source-name: ds1 # 之后下面配置的就是我们的策略等规则的东西 可以不用配置 masterslave: name: ms master-data-source-name: ds1 slave-data-source-names: ds2,ds3 load-balance-algorithm-type: round_robinmybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: top.timous.entity 3.3代码的基本结构 3.4controller层12345678910111213141516171819202122232425262728293031323334353637383940package top.timous.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import top.timous.entity.User;import top.timous.mapper.UserMapper;import java.util.Date;import java.util.List;/** * @author Timous * @create 2021-03-23 18:33 **/@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserMapper userMapper; @GetMapping(&quot;/save&quot;) public String insert()&#123; User user = new User(); user.setAge(12); user.setBirthday(new Date()); user.setNickname(&quot;timous1&quot;); user.setPassword(&quot;123456&quot;); userMapper.addUser(user); return &quot;success&quot;; &#125; @GetMapping(&quot;/listuser&quot;) public List&lt;User&gt; listUser()&#123; return userMapper.findUser(); &#125;&#125; 3.5mapper层123456789101112131415161718192021222324252627282930313233package top.timous.mapper;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import org.springframework.stereotype.Component;import top.timous.entity.User;import java.util.List;/** * @author Timous * @create 2021-03-23 18:29 **/@Mapperpublic interface UserMapper &#123; /** * 插入用户 */ @Insert(&quot;insert into ksd_user(nickname , password , age , birthday) values (#&#123;nickname&#125; , &quot; + &quot;#&#123;password&#125; , #&#123;age&#125; ,#&#123;birthday&#125;)&quot;) void addUser(User user); /** * 查找所有的用户 */ @Select(&quot;select * from ksd_user&quot;) List&lt;User&gt; findUser();&#125; 3.6mapper.xml12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org/DTD Mapper 3.0&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;top.timous.mapper.UserMapper&quot;&gt;&lt;/mapper&gt; 3.7entity层123456789101112131415161718192021222324package top.timous.entity;import lombok.Data;import java.util.Date;/** * @author Timous * @create 2021-03-23 18:27 **/@Datapublic class User &#123; //id private Integer id; //昵称 private String nickname; //密码 private String password; //年龄 private Integer age; //出生日期 private Date birthday;&#125; 3.8数据库的表 3.9测试的结果 在读的时候是ds2和ds3轮询的规则 ， 在写的时候是写入ds1的。 4.分库分表4.1为什么分库分表单个的mysql在超过2k的时候就会出现问题 ， 最好是并发量控制在1k左右。 目的： 解决高并发，和数据量大的问题 4.2水平拆分和垂直拆分水平拆分： 同一个拆分为多个数据表 垂直拆分： 一般是针对各个服务进行拆分，也就是业务的模块 表的垂直拆分： 字段的使用频率不一，可以拆分为两个表 ShardingJDBC1.yum安装mysql1.1下载mysql的rpm地址http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64&#x2F; 1.2配置mysql扩展源1rpm -ivh http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql57-community-release-el7-10.noarch.rpm 1.3yum安装mysql1yum install mysql-community-server -y 1.4启动mysql设置开机自启动1234systemctl start mysqldsystemctl status mysqldsystemctl stop mysqldsystemctl enable mysqld 1.5使用mysql初始密码进行登录12345gerp &quot;password&quot; /var/log/mysqld.logmysql -uroot -p出来的密码或者是以下的做法mysql -uroot -p$(awk &#x27;/temporary password/&#123;print $NF&#125;&#x27; /var/log/mysqld.log) 1.6修改数据库的密码数据库的默认的规则是必须携带大小写字母、特殊符号，字符串长度大于8，否则会报错 因此设定较为简单的密码是首先要修改set gloable validate_password_policy和length 12set global validate_password_policy=0;set global validate_password_length=1; 1.7修改密码1234567set password for root@localhost = password(&#x27;123456&#x27;);# 或者alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;# 给用户授权grant all on *.* to root@&#x27;%&#x27; identified by &#x27;123456&#x27;;# 刷新flush privileges; 1.8登录测试 通过测试，能够进行登录 2主从复制的配置2.1Master节点的配置12345678910111213vim /etc/my.cnf[mysqld]## 同一局域网内，注意要唯一server-id=100### 开启二进制日志 可以随便取（关键）log-bin=mysql-bin### 复制过滤： 不需要备份的数据库不输出（mysql库一般不同步）binlog-ignore-db=mysql### 为每个session分配内存，在事务过程中用来存储二进制日志的缓存binlog_cache_size=1M### 主从复制的格式（mixed ， statement ， row 默认格式是statement）binlog_format=mixed 2.2slave节点的配置123456789101112131415161718192021222324252627282930313233vim /etc/my.cnf[mysqld]## 同一局域网内，注意要唯一server-id=102### 开启二进制日志功能 ， 已备份slave作为其他slave的Master时使用log-bin=mysql-slave-bin### relay_log配置中继日志relay_log=edu-mysql-relay-bin### 复制过滤： 不需要备份的数据库不输出（mysql库一般不同步）binlog-ignore-db=mysql### 如果需要同步函数或者是存储过程log_bin_trust_function_creators=true### 为每个session分配内存，在事务过程中用来存储二进制日志的缓存binlog_cache_size=1M### 主从复制的格式（mixed ， statement ， row 默认格式是statement）binlog_format=mixed[mysqld]## 同一局域网内，注意要唯一server-id=101### 开启二进制日志功能 ， 已备份slave作为其他slave的Master时使用log-bin=mysql-slave-bin### relay_log配置中继日志relay_log=edu-mysql-relay-bin### 复制过滤： 不需要备份的数据库不输出（mysql库一般不同步）binlog-ignore-db=mysql### 如果需要同步函数或者是存储过程log_bin_trust_function_creators=true### 为每个session分配内存，在事务过程中用来存储二进制日志的缓存binlog_cache_size=1M### 主从复制的格式（mixed ， statement ， row 默认格式是statement）binlog_format=mixed 2.3在master服务器上进行授权123456789## 登录数据库mysql -uroot -p123456## 进行授权grant replication slave , replication client on *.* to &#x27;root&#x27;@&#x27;47.105.129.77&#x27; identified by &#x27;123456&#x27;;## 刷新权限flush privileges;##查看mysql具有哪些用户及对应的IP权限（可以不执行，只是一个查看）select user , host from mysql.user; 2.4查看对应的binlog文件名和位置（master节点执行）1show master status; 2.5配置从服务器的连接1234## 连接对应的主数据库change master to master_host=&#x27;81.69.232.6&#x27; , master_user=&#x27;root&#x27; , master_password=&#x27;123456&#x27; , master_port=3306, master_log_file=&#x27;mysql-bin.000001&#x27; , master_log_pos=1247;## 启动 2.6经过测试，主从复制就会完成了3.读写分离的springboot实现3.1pom.xml文件配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;top.timous&lt;/groupId&gt; &lt;artifactId&gt;shadingjdbctest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;shadingjdbctest&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;shading-sphere.version&gt;4.0.0-RC1&lt;/shading-sphere.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--web的基本依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis的jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok简化实体类的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--测试的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--shardingjdbc 的starter包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;shading-sphere.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-core-common&lt;/artifactId&gt; &lt;version&gt;$&#123;shading-sphere.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;com.alibaba&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;druid&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;1.2.3&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;top.timous.ShadingjdbctestApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.2yml文件配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950server: port: 8080spring: main: allow-bean-definition-overriding: true shardingsphere: props: sql: show: true #配置数据源 datasource: # ds1 一个主的mysql ds2 和 ds3都是slave从库 names: ds1,ds2,ds3 # 配置数据源的具体的信息 ds1: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://81.69.232.6:3306/ksd_order_db?useUnicide=true&amp;characterEncoding=utf-8&amp;tinyIntlisBit=false&amp;useSSL=false&amp;serverTimeZone=GMT%2b8 username: root password: 123456 maxPoolSize: 100 minPoolSize: 5 ds2: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://121.4.161.181:3306/ksd_order_db?useUnicide=true&amp;characterEncoding=utf-8&amp;tinyIntlisBit=false&amp;useSSL=false&amp;serverTimeZone=GMT%2b8 username: root password: 123456 maxPoolSize: 100 minPoolSize: 5 ds3: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://47.105.129.77:3306/ksd_order_db?useUnicide=true&amp;characterEncoding=utf-8&amp;tinyIntlisBit=false&amp;useSSL=false&amp;serverTimezone=GMT%2b8 username: root password: 123456 maxPoolSize: 100 minPoolSize: 5 # 不配置下面的话写入的时候会出现问题 ， 会报错 下面才是读写分离的 sharding: default-data-source-name: ds1 # 之后下面配置的就是我们的策略等规则的东西 可以不用配置 masterslave: name: ms master-data-source-name: ds1 slave-data-source-names: ds2,ds3 load-balance-algorithm-type: round_robinmybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: top.timous.entity 3.3代码的基本结构 3.4controller层12345678910111213141516171819202122232425262728293031323334353637383940package top.timous.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import top.timous.entity.User;import top.timous.mapper.UserMapper;import java.util.Date;import java.util.List;/** * @author Timous * @create 2021-03-23 18:33 **/@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserMapper userMapper; @GetMapping(&quot;/save&quot;) public String insert()&#123; User user = new User(); user.setAge(12); user.setBirthday(new Date()); user.setNickname(&quot;timous1&quot;); user.setPassword(&quot;123456&quot;); userMapper.addUser(user); return &quot;success&quot;; &#125; @GetMapping(&quot;/listuser&quot;) public List&lt;User&gt; listUser()&#123; return userMapper.findUser(); &#125;&#125; 3.5mapper层123456789101112131415161718192021222324252627282930313233package top.timous.mapper;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import org.springframework.stereotype.Component;import top.timous.entity.User;import java.util.List;/** * @author Timous * @create 2021-03-23 18:29 **/@Mapperpublic interface UserMapper &#123; /** * 插入用户 */ @Insert(&quot;insert into ksd_user(nickname , password , age , birthday) values (#&#123;nickname&#125; , &quot; + &quot;#&#123;password&#125; , #&#123;age&#125; ,#&#123;birthday&#125;)&quot;) void addUser(User user); /** * 查找所有的用户 */ @Select(&quot;select * from ksd_user&quot;) List&lt;User&gt; findUser();&#125; 3.6mapper.xml12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org/DTD Mapper 3.0&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;top.timous.mapper.UserMapper&quot;&gt;&lt;/mapper&gt; 3.7entity层123456789101112131415161718192021222324package top.timous.entity;import lombok.Data;import java.util.Date;/** * @author Timous * @create 2021-03-23 18:27 **/@Datapublic class User &#123; //id private Integer id; //昵称 private String nickname; //密码 private String password; //年龄 private Integer age; //出生日期 private Date birthday;&#125; 3.8数据库的表 3.9测试的结果 在读的时候是ds2和ds3轮询的规则 ， 在写的时候是写入ds1的。 4.分库分表4.1为什么分库分表单个的mysql在超过2k的时候就会出现问题 ， 最好是并发量控制在1k左右。 目的： 解决高并发，和数据量大的问题 4.2水平拆分和垂直拆分水平拆分： 同一个拆分为多个数据表 垂直拆分： 一般是针对各个服务进行拆分，也就是业务的模块 表的垂直拆分： 字段的使用频率不一，可以拆分为两个表","tags":["数据库","mysql"]},{"title":"排序算法","path":"/2021/03/26/排序算法/","content":"排序算法项目结构 tools工具类简介Asserts：断言类，判断结果是不是正确如果正确不输出东西，否则抛出测试为通过的异常。 123456789public class Asserts &#123; public static void test(boolean value) &#123; try &#123; if (!value) throw new Exception(&quot;测试未通过&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; Integers整数类，能够生成不同个数的整数，便于后续的测试。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import java.util.Arrays;public class Integers &#123; //生成从min ， 到max的count个整数 public static Integer[] random(int count, int min, int max) &#123; if (count &lt;= 0 || min &gt; max) return null; Integer[] array = new Integer[count]; int delta = max - min + 1; for (int i = 0; i &lt; count; i++) &#123; array[i] = min + (int)(Math.random() * delta); &#125; return array; &#125; //合并两个数组返回一个大的数组 public static Integer[] combine(Integer[] array1, Integer[] array2) &#123; if (array1 == null || array2 == null) return null; Integer[] array = new Integer[array1.length + array2.length]; for (int i = 0; i &lt; array1.length; i++) &#123; array[i] = array1[i]; &#125; for (int i = 0; i &lt; array2.length; i++) &#123; array[i + array1.length] = array2[i]; &#125; return array; &#125; public static Integer[] same(int count, int unsameCount) &#123; if (count &lt;= 0 || unsameCount &gt; count) return null; Integer[] array = new Integer[count]; for (int i = 0; i &lt; unsameCount; i++) &#123; array[i] = unsameCount - i; &#125; for (int i = unsameCount; i &lt; count; i++) &#123; array[i] = unsameCount + 1; &#125; return array; &#125; public static Integer[] headTailAscOrder(int min, int max, int disorderCount) &#123; Integer[] array = ascOrder(min, max); if (disorderCount &gt; array.length) return array; int begin = (array.length - disorderCount) &gt;&gt; 1; reverse(array, begin, begin + disorderCount); return array; &#125; public static Integer[] centerAscOrder(int min, int max, int disorderCount) &#123; Integer[] array = ascOrder(min, max); if (disorderCount &gt; array.length) return array; int left = disorderCount &gt;&gt; 1; reverse(array, 0, left); int right = disorderCount - left; reverse(array, array.length - right, array.length); return array; &#125; public static Integer[] headAscOrder(int min, int max, int disorderCount) &#123; Integer[] array = ascOrder(min, max); if (disorderCount &gt; array.length) return array; reverse(array, array.length - disorderCount, array.length); return array; &#125; //尾部的数据是升序的 public static Integer[] tailAscOrder(int min, int max, int disorderCount) &#123; Integer[] array = ascOrder(min, max); if (disorderCount &gt; array.length) return array; reverse(array, 0, disorderCount); return array; &#125; //数据升序排列 public static Integer[] ascOrder(int min, int max) &#123; if (min &gt; max) return null; Integer[] array = new Integer[max - min + 1]; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = min++; &#125; return array; &#125; public static Integer[] descOrder(int min, int max) &#123; if (min &gt; max) return null; Integer[] array = new Integer[max - min + 1]; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = max--; &#125; return array; &#125; /** * 反转一个数组，索引范围是[begin, end) */ private static void reverse(Integer[] array, int begin, int end) &#123; int count = (end - begin) &gt;&gt; 1; int sum = begin + end - 1; for (int i = begin; i &lt; begin + count; i++) &#123; int j = sum - i; int tmp = array[i]; array[i] = array[j]; array[j] = tmp; &#125; &#125; //拷贝对应的数组 public static Integer[] copy(Integer[] array) &#123; return Arrays.copyOf(array, array.length); &#125; //判断一个数组是不是升序的 public static boolean isAscOrder(Integer[] array) &#123; if (array == null || array.length == 0) return false; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i - 1] &gt; array[i]) return false; &#125; return true; &#125; //打印对应的数组按照_+数字的格式 public static void println(Integer[] array) &#123; if (array == null) return; StringBuilder string = new StringBuilder(); for (int i = 0; i &lt; array.length; i++) &#123; if (i != 0) string.append(&quot;_&quot;); string.append(array[i]); &#125; System.out.println(string); &#125;&#125; Times计算时间类，便于比较排序算法的消耗时间的多少。 123456789101112131415161718192021222324import java.text.SimpleDateFormat;import java.util.Date;public class Times &#123; private static final SimpleDateFormat fmt = new SimpleDateFormat(&quot;HH:mm:ss.SSS&quot;); public interface Task &#123; void execute(); &#125; public static void test(String title, Task task) &#123; if (task == null) return; title = (title == null) ? &quot;&quot; : (&quot;【&quot; + title + &quot;】&quot;); System.out.println(title); System.out.println(&quot;开始：&quot; + fmt.format(new Date())); long begin = System.currentTimeMillis(); task.execute(); long end = System.currentTimeMillis(); System.out.println(&quot;结束：&quot; + fmt.format(new Date())); double delta = (end - begin) / 1000.0; System.out.println(&quot;耗时：&quot; + delta + &quot;秒&quot;); System.out.println(&quot;-------------------------------------&quot;); &#125;&#125; 下面的一些方法的解释12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package top.timous;import java.text.DecimalFormat;/** * @author Timous * @create 2021-03-26 18:28 **/public abstract class Sort implements Comparable&lt;Sort&gt;&#123; protected Integer[] array; private int cmpCount; // 查看算法比较了多少次 private int swapCount; // 查看算法交换了多少次 private long time; private DecimalFormat fmt = new DecimalFormat(&quot;#.00&quot;); public void sort(Integer[] array)&#123; if (array == null || array.length &lt; 2) return; this.array = array; long begin = System.currentTimeMillis(); sort(); time = System.currentTimeMillis() - begin; &#125; protected abstract void sort(); /** * @param i1 * @param i2 * @return 返回值等于0 代表array[i1] == array[i2] * @return 返回值大于0 代表array[i1] &gt; array[i2] * @return 返回值小于0 代表array[i1] &lt; array[i2] */ protected int cmp(int i1 ,int i2)&#123; cmpCount++; return array[i1] - array[i2]; &#125; /** * 传递数组的直接的值 * @param v1 * @param v2 * @return */ protected int cmpElements(Integer v1, Integer v2) &#123; cmpCount++; return v1 - v2; &#125; protected void swap(int i1 , int i2)&#123; swapCount++; int temp = array[i1]; array[i1] = array[i2]; array[i2] = temp; &#125; private String numberString(int number) &#123; if (number &lt; 10000) return &quot;&quot; + number; if (number &lt; 100000000) return fmt.format(number / 10000.0) + &quot;万&quot;; return fmt.format(number / 100000000.0) + &quot;亿&quot;; &#125; @Override public String toString() &#123; // 多少次比较 String timeStr = &quot;耗时：&quot; + (time / 1000.0) + &quot;s(&quot; + time + &quot;ms)&quot;; String compareCountStr = &quot;比较：&quot; + numberString(cmpCount); String swapCountStr = &quot;交换：&quot; + numberString(swapCount); return &quot;【&quot; + getClass().getSimpleName() + &quot;】 &quot; + timeStr + &quot; \\t&quot; + compareCountStr + &quot;\\t &quot; + swapCountStr + &quot; &quot; + &quot;------------------------------------------------------------------&quot;; &#125; //比较 @Override public int compareTo(Sort o) &#123; int result = (int) (time - o.time); if (result != 0)&#123; return result; &#125; result = cmpCount - o.cmpCount; if (result != 0)&#123; return result; &#125; return swapCount - o.swapCount; &#125;&#125; 冒泡排序排序的代码123456789101112131415161718192021222324public class BubbleSort extends Sort&#123; /** * 最坏时间复杂度 O（n^2） * 最好的时间复杂度 O（n） * 空间复杂度 O（1） * 这个方法是稳定的排序 */ @Override protected void sort() &#123; int temp; for (int end = array.length - 1; end &gt; 0 ; end--)&#123; for (int begin = 1; begin &lt;= end; begin++)&#123;// if (array[begin] &lt; array[begin - 1])&#123;//交换到后面是最大的// temp = array[begin];// array[begin] = array[begin - 1];// array[begin - 1] = temp;// &#125; if (cmp(begin , begin - 1) &lt; 0)&#123; swap(begin , begin - 1); &#125; &#125; &#125; &#125;&#125; 选择排序排序的代码123456789101112131415161718192021222324252627282930313233343536package top.timous;/** * @author Timous * @create 2021-03-26 18:28 **/public class SelectionSort extends Sort&#123; /** * 选择排序 从序列中找出最大的元素 ， 放置到最后面 也就是与最后面的元素进行交换 * 交换次数小于冒泡排序 ， 是优于冒泡排序的 * 时间复杂度最好最坏都是O（n^2） 空间复杂度为O（1） 属于稳定的排序 * 选择排序是够还有优化的空间 * 每一轮选最大的值 ， 选最值的优化 ， 选一个最值的复杂度O（n） 外面for循环 * 使用堆进行选最值的优化 堆挑出最值的时间复杂度是很低的时间复杂度就是O（nlogn） */ @Override protected void sort() &#123; //记录最大元素的位置 int temp; int maxIndex = 0; for (int end = array.length - 1; end &gt; 0 ; end--)&#123; maxIndex = 0; for (int begin = 1; begin &lt;= end; begin++)&#123;// if (array[maxIndex] &lt;= array[begin])&#123;// maxIndex = begin;// &#125; if (cmp(maxIndex , begin) &lt;= 0)&#123; maxIndex = begin; &#125; &#125; //元素的交换 swap(maxIndex , end); //10 10 9 8 &#125; &#125;&#125; 堆排序堆排序的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class HeapSort extends Sort&#123; /** * Heap Sort * 堆排序 对选择排序的优化 ，选择排序从头到尾选最大值 ， 放到最后 * 堆排序从数组中调最大的放在后面 在调最大的值的时候的时间复杂度是最低的 * 对序列进行原地建堆（heapify） O（n） * 一直到堆的元素为1 * 50 21 80 43 38 14 * 80 43 50 21 38 14 选择0号位置和末尾的元素进行交换即可 * 14 43 50 21 38 80 堆的size - 1 80 最大的元素到堆之外 如此进行循环 * sift down 进行元素的重置 * 50 43 14 21 38 ||| 80 然后进行元素交换 * 然后继续 直到堆中只剩下一个元素 * 时间复杂度 O（nlogn） 比之前的排序好 堆排序是不稳定的排序 空间复杂度是O（1） */ private int heapSize; @Override protected void sort() &#123; /*原地建堆*/ heapSize = array.length; for (int i = (heapSize &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123; siftDown(i); &#125; while (heapSize &gt; 1)&#123; /*交换堆顶元素和尾部元素，堆的元素--*/ swap(0 , --heapSize); siftDown(0); &#125; &#125; private void siftDown(int index) &#123; Integer element = array[index]; int half = heapSize &gt;&gt; 1; while (index &lt; half) &#123; // index必须是非叶子节点 // 默认是左边跟父节点比 int childIndex = (index &lt;&lt; 1) + 1; Integer child = array[childIndex]; int rightIndex = childIndex + 1; // 右子节点比左子节点大 if (rightIndex &lt; heapSize &amp;&amp; cmpElements(array[rightIndex], child) &gt; 0) &#123; child = array[childIndex = rightIndex]; &#125; // 大于等于子节点 if (cmpElements(element, child) &gt;= 0) break; array[index] = child; index = childIndex; &#125; array[index] = element; &#125;&#125; 测试测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package top.timous;import java.text.DecimalFormat;/** * @author Timous * @create 2021-03-26 18:28 **/public abstract class Sort implements Comparable&lt;Sort&gt;&#123; protected Integer[] array; private int cmpCount; // 查看算法比较了多少次 private int swapCount; // 查看算法交换了多少次 private long time; private DecimalFormat fmt = new DecimalFormat(&quot;#.00&quot;); public void sort(Integer[] array)&#123; if (array == null || array.length &lt; 2) return; this.array = array; long begin = System.currentTimeMillis(); sort(); time = System.currentTimeMillis() - begin; &#125; protected abstract void sort(); /** * @param i1 * @param i2 * @return 返回值等于0 代表array[i1] == array[i2] * @return 返回值大于0 代表array[i1] &gt; array[i2] * @return 返回值小于0 代表array[i1] &lt; array[i2] */ protected int cmp(int i1 ,int i2)&#123; cmpCount++; return array[i1] - array[i2]; &#125; /** * 传递数组的直接的值 * @param v1 * @param v2 * @return */ protected int cmpElements(Integer v1, Integer v2) &#123; cmpCount++; return v1 - v2; &#125; protected void swap(int i1 , int i2)&#123; swapCount++; int temp = array[i1]; array[i1] = array[i2]; array[i2] = temp; &#125; private String numberString(int number) &#123; if (number &lt; 10000) return &quot;&quot; + number; if (number &lt; 100000000) return fmt.format(number / 10000.0) + &quot;万&quot;; return fmt.format(number / 100000000.0) + &quot;亿&quot;; &#125; @Override public String toString() &#123; // 多少次比较 String timeStr = &quot;耗时：&quot; + (time / 1000.0) + &quot;s(&quot; + time + &quot;ms)&quot;; String compareCountStr = &quot;比较：&quot; + numberString(cmpCount); String swapCountStr = &quot;交换：&quot; + numberString(swapCount); return &quot;【&quot; + getClass().getSimpleName() + &quot;】 &quot; + timeStr + &quot; \\t&quot; + compareCountStr + &quot;\\t &quot; + swapCountStr + &quot; &quot; + &quot;------------------------------------------------------------------&quot;; &#125; @Override public int compareTo(Sort o) &#123; int result = (int) (time - o.time); if (result != 0)&#123; return result; &#125; result = cmpCount - o.cmpCount; if (result != 0)&#123; return result; &#125; return swapCount - o.swapCount; &#125;&#125; 测试结果 今天就到这里，后续还会有优化","tags":["算法"]}]