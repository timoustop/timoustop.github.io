[{"title":"Hexo博客搭建","path":"/2026/01/11/Hexo博客搭建/","content":"Hexo博客搭建下载nodejs并安装地址 :https://nodejs.org/zh-cn/download 一路下一步进行安装 全局安装hexo1npm install -g hexo-cli 初始化blog1hexo init blog 安装主题通过github等相关途径找到适合自己的主题进行安装，这里以hexo-theme-stellar-1.6.1为样例进行安装 1.从github下载相关的压缩包放至theme下 2.找到配置文件配置如下(_config.yaml) 1theme: hexo-theme-stellar-1.6.1 配置完成后即可得到一份博客啦 写完之后部署1npm install hexo-deployer-git --save","tags":["博客"]},{"title":"HashMap源码探究","path":"/2022/01/14/HashMap源码探究/","content":"HashMap核心理论： Hash也称为散列、哈希，对应的英文都是Hash。&#x3D;&#x3D;基本原理就是把任意长度的输入，通过Hash算法，变成固定长度的输出&#x3D;&#x3D;，这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制就是哈希值（可能会有冲突) Hash的特点 从hash值不可以反向推到出原始的数据 输入数据的微小变化会得到完全不用的hash值，相同的数据会得到相同的值 哈希算法的执行效率高效，长的文本也能快速的计算出哈希值 hash算法的冲突概率要小 由于hash的原理是将输入空间的值映射成hash空间内，而hash值的空间远小于输入的空间。 根据抽屉原理，一定存在不同的输入映射到相同的输出的情况。 抽屉原理：桌子上有10个苹果，放到9个抽屉里面，无论是怎样放的，我们会发现至少有一个抽屉里面放了不少于两个苹果。这一现象我们称之为“抽屉原理”。 Map继承体系图 内部类： 123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; //存储hash值 与 hashcode还是有区别的 this.key = key; // 就是put的key值 this.value = value;// 就是put的value值 this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; &#x3D;&#x3D;当链表的长度达到9并且表中的数据超过64个的时候，链表就会进行树化&#x3D;&#x3D; map的put的过程 map.put(“timous”,”chenliuhong”); 获取timous字符串的hash值 经过hash值&#x3D;&#x3D;扰动函数&#x3D;&#x3D;，使hash值更加散列 构造出Node对象 Hash—–》1122 Key—》timous value —-&gt; chenliuhong next—-&gt;null 路由算法，找出node应该存放的数组的位置 路由寻址公式 ： (table.length-1)&amp;node.hash (16-1) &amp; 1122 &#x3D;》 B0000 0000 1111 &amp; B0100 0110 0010 &#x3D;》B0010 &#x3D;》2 这就是下标 表的长度一定是2的多少次方 16 32 64 等 Hash碰撞在上面的时候再插入一个值可能也会得到2这个下标 ， 所以出现了两个值，在同一个位置，这个时候就会发生hash碰撞 ， next就会指向下一个值，如果一直碰撞的话就会使我们的链表很长，在get的时候，就会遍历一个链表，比较长，本来时间复杂度是O(1)，但是退化之后就变成O(n)了，为了解决链化问题，就会出现了树化 手撕源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783package java.util;import java.io.IOException;import java.io.InvalidObjectException;import java.io.Serializable;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.function.BiConsumer;import java.util.function.BiFunction;import java.util.function.Consumer;import java.util.function.Function;import sun.misc.SharedSecrets;public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; private static final long serialVersionUID = 362498820763181265L; // static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; static final float DEFAULT_LOAD_FACTOR = 0.75f; static final int TREEIFY_THRESHOLD = 8; static final int UNTREEIFY_THRESHOLD = 6; static final int MIN_TREEIFY_CAPACITY = 64; static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; static Class&lt;?&gt; comparableClassFor(Object x) &#123; if (x instanceof Comparable) &#123; Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p; if ((c = x.getClass()) == String.class) // bypass checks return c; if ((ts = c.getGenericInterfaces()) != null) &#123; for (int i = 0; i &lt; ts.length; ++i) &#123; if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp; ((p = (ParameterizedType)t).getRawType() == Comparable.class) &amp;&amp; (as = p.getActualTypeArguments()) != null &amp;&amp; as.length == 1 &amp;&amp; as[0] == c) // type arg is c return c; &#125; &#125; &#125; return null; &#125; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) // for cast to Comparable static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123; return (x == null || x.getClass() != kc ? 0 : ((Comparable)k).compareTo(x)); &#125; static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; transient Node&lt;K,V&gt;[] table; transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; transient int size; transient int modCount; int threshold; final float loadFactor; public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; public boolean containsKey(Object key) &#123; return getNode(hash(key), key) != null; &#125; public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125; &#125; public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; putMapEntries(m, true); &#125; public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; &#125; final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null; &#125; public void clear() &#123; Node&lt;K,V&gt;[] tab; modCount++; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; size = 0; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; &#125; &#125; public boolean containsValue(Object value) &#123; Node&lt;K,V&gt;[] tab; V v; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; if ((v = e.value) == value || (value != null &amp;&amp; value.equals(v))) return true; &#125; &#125; &#125; return false; &#125; public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; if (ks == null) &#123; ks = new KeySet(); keySet = ks; &#125; return ks; &#125; final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; if (vs == null) &#123; vs = new Values(); values = vs; &#125; return vs; &#125; final class Values extends AbstractCollection&lt;V&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(); &#125; public final boolean contains(Object o) &#123; return containsValue(o); &#125; public final Spliterator&lt;V&gt; spliterator() &#123; return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super V&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.value); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es; &#125; final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(); &#125; public final boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Node&lt;K,V&gt; candidate = getNode(hash(key), key); return candidate != null &amp;&amp; candidate.equals(e); &#125; public final boolean remove(Object o) &#123; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Object value = e.getValue(); return removeNode(hash(key), key, value, true, true) != null; &#125; return false; &#125; public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123; return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; // Overrides of JDK8 Map extension methods @Override public V getOrDefault(Object key, V defaultValue) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? defaultValue : e.value; &#125; @Override public V putIfAbsent(K key, V value) &#123; return putVal(hash(key), key, value, true, true); &#125; @Override public boolean remove(Object key, Object value) &#123; return removeNode(hash(key), key, value, true, true) != null; &#125; @Override public boolean replace(K key, V oldValue, V newValue) &#123; Node&lt;K,V&gt; e; V v; if ((e = getNode(hash(key), key)) != null &amp;&amp; ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) &#123; e.value = newValue; afterNodeAccess(e); return true; &#125; return false; &#125; @Override public V replace(K key, V value) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) != null) &#123; V oldValue = e.value; e.value = value; afterNodeAccess(e); return oldValue; &#125; return null; &#125; @Override public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) &#123; if (mappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; V oldValue; if (old != null &amp;&amp; (oldValue = old.value) != null) &#123; afterNodeAccess(old); return oldValue; &#125; &#125; V v = mappingFunction.apply(key); if (v == null) &#123; return null; &#125; else if (old != null) &#123; old.value = v; afterNodeAccess(old); return v; &#125; else if (t != null) t.putTreeVal(this, tab, hash, key, v); else &#123; tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); return v; &#125; public V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; if (remappingFunction == null) throw new NullPointerException(); Node&lt;K,V&gt; e; V oldValue; int hash = hash(key); if ((e = getNode(hash, key)) != null &amp;&amp; (oldValue = e.value) != null) &#123; V v = remappingFunction.apply(key, oldValue); if (v != null) &#123; e.value = v; afterNodeAccess(e); return v; &#125; else removeNode(hash, key, null, false, true); &#125; return null; &#125; @Override public V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; &#125; V oldValue = (old == null) ? null : old.value; V v = remappingFunction.apply(key, oldValue); if (old != null) &#123; if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; else removeNode(hash, key, null, false, true); &#125; else if (v != null) &#123; if (t != null) t.putTreeVal(this, tab, hash, key, v); else &#123; tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); &#125; return v; &#125; @Override public V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123; if (value == null) throw new NullPointerException(); if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; &#125; if (old != null) &#123; V v; if (old.value != null) v = remappingFunction.apply(old.value, value); else v = value; if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; else removeNode(hash, key, null, false, true); return v; &#125; if (value != null) &#123; if (t != null) t.putTreeVal(this, tab, hash, key, value); else &#123; tab[i] = newNode(hash, key, value, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); &#125; return value; &#125; @Override public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key, e.value); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; @Override public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) &#123; Node&lt;K,V&gt;[] tab; if (function == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; e.value = function.apply(e.key, e.value); &#125; &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; @SuppressWarnings(&quot;unchecked&quot;) @Override public Object clone() &#123; HashMap&lt;K,V&gt; result; try &#123; result = (HashMap&lt;K,V&gt;)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; // this shouldn&#x27;t happen, since we are Cloneable throw new InternalError(e); &#125; result.reinitialize(); result.putMapEntries(this, false); return result; &#125; // These methods are also used when serializing HashSets final float loadFactor() &#123; return loadFactor; &#125; final int capacity() &#123; return (table != null) ? table.length : (threshold &gt; 0) ? threshold : DEFAULT_INITIAL_CAPACITY; &#125; private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; int buckets = capacity(); // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); s.writeInt(buckets); s.writeInt(size); internalWriteEntries(s); &#125; private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it&#x27;s the nearest public type to // what we&#x27;re actually creating. SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125; &#125; /* ------------------------------------------------------------ */ // iterators abstract class HashIterator &#123; Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e; &#125; public final void remove() &#123; Node&lt;K,V&gt; p = current; if (p == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); current = null; K key = p.key; removeNode(hash(key), key, null, false, false); expectedModCount = modCount; &#125; &#125; final class KeyIterator extends HashIterator implements Iterator&lt;K&gt; &#123; public final K next() &#123; return nextNode().key; &#125; &#125; final class ValueIterator extends HashIterator implements Iterator&lt;V&gt; &#123; public final V next() &#123; return nextNode().value; &#125; &#125; final class EntryIterator extends HashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125; &#125; /* ------------------------------------------------------------ */ // spliterators static class HashMapSpliterator&lt;K,V&gt; &#123; final HashMap&lt;K,V&gt; map; Node&lt;K,V&gt; current; // current node int index; // current index, modified on advance/split int fence; // one past last index int est; // size estimate int expectedModCount; // for comodification checks HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; this.map = m; this.index = origin; this.fence = fence; this.est = est; this.expectedModCount = expectedModCount; &#125; final int getFence() &#123; // initialize fence and size on first use int hi; if ((hi = fence) &lt; 0) &#123; HashMap&lt;K,V&gt; m = map; est = m.size; expectedModCount = m.modCount; Node&lt;K,V&gt;[] tab = m.table; hi = fence = (tab == null) ? 0 : tab.length; &#125; return hi; &#125; public final long estimateSize() &#123; getFence(); // force init return (long) est; &#125; &#125; static final class KeySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;K&gt; &#123; KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public KeySpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super K&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p.key); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super K&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; K k = current.key; current = current.next; action.accept(k); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; &#125; &#125; static final class ValueSpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;V&gt; &#123; ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public ValueSpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super V&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p.value); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super V&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; V v = current.value; current = current.next; action.accept(v); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0); &#125; &#125; static final class EntrySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public EntrySpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; Node&lt;K,V&gt; e = current; current = current.next; action.accept(e); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; &#125; &#125; Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(hash, key, value, next); &#125; // For conversion from TreeNodes to plain nodes Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(p.hash, p.key, p.value, next); &#125; // Create a tree bin node TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(hash, key, value, next); &#125; // For treeifyBin TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next); &#125; /** * Reset to initial default state. Called by clone and readObject. */ void reinitialize() &#123; table = null; entrySet = null; keySet = null; values = null; modCount = 0; threshold = 0; size = 0; &#125; // Callbacks to allow LinkedHashMap post-actions void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125; void afterNodeInsertion(boolean evict) &#123; &#125; void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125; // Called only from writeObject, to ensure compatible ordering. void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException &#123; Node&lt;K,V&gt;[] tab; if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; s.writeObject(e.key); s.writeObject(e.value); &#125; &#125; &#125; &#125; static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; /** * Returns root of tree containing this node. */ final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; &#125; static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123; int n; if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) &#123; int index = (n - 1) &amp; root.hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; if (root != first) &#123; Node&lt;K,V&gt; rn; tab[index] = root; TreeNode&lt;K,V&gt; rp = root.prev; if ((rn = root.next) != null) ((TreeNode&lt;K,V&gt;)rn).prev = rp; if (rp != null) rp.next = rn; if (first != null) first.prev = root; root.next = first; root.prev = null; &#125; assert checkInvariants(root); &#125; &#125; final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; &#125; while (p != null); return null; &#125; final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; return ((parent != null) ? root() : this).find(h, k, null); &#125; static int tieBreakOrder(Object a, Object b) &#123; int d; if (a == null || b == null || (d = a.getClass().getName(). compareTo(b.getClass().getName())) == 0) d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -1 : 1); return d; &#125; final void treeify(Node&lt;K,V&gt;[] tab) &#123; TreeNode&lt;K,V&gt; root = null; for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123; next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; if (root == null) &#123; x.parent = null; x.red = false; root = x; &#125; else &#123; K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; root = balanceInsertion(root, x); break; &#125; &#125; &#125; &#125; moveRootToFront(tab, root); &#125; final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123; Node&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; q = this; q != null; q = q.next) &#123; Node&lt;K,V&gt; p = map.replacementNode(q, null); if (tl == null) hd = p; else tl.next = p; tl = p; &#125; return hd; &#125; final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) &#123; Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) &#123; if (!searched) &#123; TreeNode&lt;K,V&gt; q, ch; searched = true; if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; &#125; dir = tieBreakOrder(k, pk); &#125; TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; &#125; &#125; &#125; final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable) &#123; int n; if (tab == null || (n = tab.length) == 0) return; int index = (n - 1) &amp; hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; if (pred == null) tab[index] = first = succ; else pred.next = succ; if (succ != null) succ.prev = pred; if (first == null) return; if (root.parent != null) root = root.root(); if (root == null || (movable &amp;&amp; (root.right == null || (rl = root.left) == null || rl.left == null))) &#123; tab[index] = first.untreeify(map); // too small return; &#125; TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement; if (pl != null &amp;&amp; pr != null) &#123; TreeNode&lt;K,V&gt; s = pr, sl; while ((sl = s.left) != null) // find successor s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors TreeNode&lt;K,V&gt; sr = s.right; TreeNode&lt;K,V&gt; pp = p.parent; if (s == pr) &#123; // p was s&#x27;s direct parent p.parent = s; s.right = p; &#125; else &#123; TreeNode&lt;K,V&gt; sp = s.parent; if ((p.parent = sp) != null) &#123; if (s == sp.left) sp.left = p; else sp.right = p; &#125; if ((s.right = pr) != null) pr.parent = s; &#125; p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; &#125; else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; if (replacement != p) &#123; TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; &#125; TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); if (replacement == p) &#123; // detach TreeNode&lt;K,V&gt; pp = p.parent; p.parent = null; if (pp != null) &#123; if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; &#125; &#125; if (movable) moveRootToFront(tab, r); &#125; final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // Relink into lo and hi lists, preserving order TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; if ((e.hash &amp; bit) == 0) &#123; if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; &#125; else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; if (loHead != null) &#123; if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; r, pp, rl; if (p != null &amp;&amp; (r = p.right) != null) &#123; if ((rl = p.right = r.left) != null) rl.parent = p; if ((pp = r.parent = p.parent) == null) (root = r).red = false; else if (pp.left == p) pp.left = r; else pp.right = r; r.left = p; p.parent = r; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; l, pp, lr; if (p != null &amp;&amp; (l = p.left) != null) &#123; if ((lr = p.left = l.right) != null) lr.parent = p; if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; l.right = p; p.parent = l; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; x.red = true; for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123; if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (!xp.red || (xpp = xp.parent) == null) return root; if (xp == (xppl = xpp.left)) &#123; if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123; xppr.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.right) &#123; root = rotateLeft(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateRight(root, xpp); &#125; &#125; &#125; &#125; else &#123; if (xppl != null &amp;&amp; xppl.red) &#123; xppl.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.left) &#123; root = rotateRight(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateLeft(root, xpp); &#125; &#125; &#125; &#125; &#125; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123; if (x == null || x == root) return root; else if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (x.red) &#123; x.red = false; return root; &#125; else if ((xpl = xp.left) == x) &#123; if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123; xpr.red = false; xp.red = true; root = rotateLeft(root, xp); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right; if ((sr == null || !sr.red) &amp;&amp; (sl == null || !sl.red)) &#123; xpr.red = true; x = xp; &#125; else &#123; if (sr == null || !sr.red) &#123; if (sl != null) sl.red = false; xpr.red = true; root = rotateRight(root, xpr); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr != null) &#123; xpr.red = (xp == null) ? false : xp.red; if ((sr = xpr.right) != null) sr.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateLeft(root, xp); &#125; x = root; &#125; &#125; &#125; else &#123; // symmetric if (xpl != null &amp;&amp; xpl.red) &#123; xpl.red = false; xp.red = true; root = rotateRight(root, xp); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right; if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red)) &#123; xpl.red = true; x = xp; &#125; else &#123; if (sl == null || !sl.red) &#123; if (sr != null) sr.red = false; xpl.red = true; root = rotateLeft(root, xpl); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl != null) &#123; xpl.red = (xp == null) ? false : xp.red; if ((sl = xpl.left) != null) sl.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateRight(root, xp); &#125; x = root; &#125; &#125; &#125; &#125; &#125; /** * Recursive invariant check */ static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) &#123; TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right, tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next; if (tb != null &amp;&amp; tb.next != t) return false; if (tn != null &amp;&amp; tn.prev != t) return false; if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right) return false; if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash)) return false; if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash)) return false; if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red) return false; if (tl != null &amp;&amp; !checkInvariants(tl)) return false; if (tr != null &amp;&amp; !checkInvariants(tr)) return false; return true; &#125; &#125;&#125;","tags":["源码"]},{"title":"git学习","path":"/2022/01/11/git学习/","content":"GitGit： 十分简单！！！Github版本控制 版本控制（Revision control）是一种在开发中的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便于恢复以前的版本的软件工程技术 实现扩区域多人协同开发、 追踪和记录一个或者多个文件的历史记录 组织和保护你的源代码和文档 统计工作量 并行开发，提高开发效率 跟踪记录整个软件的开发过程 减轻开发人员的负担，节省时间同时降低人为错误 简单的说就是用于管理多人协同开发项目的技术 没有进行版本控制或者版本控制本身缺乏正确的流程管理，在开发软件的过程中会引入很多的问题，如软件代码的一致性，软件内容的冗余，软件过程的事物性，软件开发过程中的并发性，软件源代码的安全性，以及软件的整合等问题 解决方案1 解决方案2 解决方案3 解决方案4 最终方案1 最终方案2 最终方案3 最终方案4 ……. 无论是工作还是学习，都经过这样一个阶段！ 我们迫切需要一个版本控制工具 多人开发必须要使用版本控制，不然的话可能会花比较大的代价 常见的版本控制工具 我们学习的东西一般都是当下最流行的 主流的版本控制器，有一下的这些： Git SVN（Subversion） CVS（Concurrent Version System） VSS（Micorosoft Visual SourceSafe） TFS（Team Foundation Server） Visual Studio Online 版本控制的产品非常的多（Perforce）等 最大的好处就是分布式版本控制 GIt和SVN的区别git是分布式的版本控制 svn是集中式的版本控制 Git可以直接看到更新了那些代码和文件操作Git是目前最新进的版本控制 Git环境配置所有东西下载慢的话一般都可以去找镜像 下载地址：http://npm.taobao.org/mirrors/git-for-windows 卸载Git 1.直接反安装即可 清理环境变量 2.卸载 安装 无脑下一步即可 启动Git Git Bash：Unix与linux风格的命令行，使用最多推荐最多 Git CMD：windows风格的命令行 Git GUI：图形界面的Git 不建议初学者使用，尽量先熟悉常用的命令 Git基本的linux命令学习 平时一定要多使用这些基础的命令 cd ： 改变目录 cd .. :回退到上一级目录 pwd ： 显示当前所在的目录 ls（ll）：都是列出当前目录中的所有文件只不过后面的列出的内容更为详细 touch： 新建一个文件，如touch index.js 就会在当前目录下新建一个index.js文件 rm： 删除一个文件 如 rm index.js mkdir： 新建一个目录，就是新建一个文件夹 rm -r： 删除一个文件夹 mv： 移动文件 reset： 重新初始化终端 clear ： 清屏 history： 查看历史命令 help：帮助 exit： 退出 # 表示注释 rm -rf &#x2F; 切勿在linux里面尝试 删除电脑的全部文件 Git配置 环境变量只是为了全局使用而已 默认会帮你配置所有的配置文件其实都保存在本地 查看配置git config -l 系统的配置git config --system --list 查看本地的配置git config --global --list 配置邮箱 必须要配置的 12git config --global user.name &quot;Timous&quot;git config --global user.email &quot;1844736251@qq.com&quot; Git理论（所有的时间都要源于这个理论） 工作区域 Git本地有三个工作区域： 工作目录， 暂存区，资源库。如果在加上远程的Git仓库，就可以分为四个工作区域，文件在这四个区域之间的转换关系如下： 工作路径： 写代码的空间 暂存区： 就是一些文件，基本看不到 Repository： 本地的代码库 Remote： 远程仓库 github gitee .git隐藏文件夹 Git项目搭建 创建工作目录与常用的指令 工作目录一般就是你希望Git帮助你管理的文件夹，可以是你的项目的目录，也可以是一个空的目录，建议不要有中文，日常只需要记住以下的6个命令 本地仓库搭建 创建本地仓库的方法有两种，一种是创建全新的仓库，另一种是克隆远程仓库 1.创建全新的仓库，需要Git管理的根目录执行 1234# 在当前目录创建一个新的Git代码库$ git initInitialized empty Git repository in D:/environment/gitcode/.git/ 2.克隆一个远程的仓库到本地 123456789git clone [url] # 克隆一个远程的地址的Cloning into &#x27;openclass&#x27;...remote: Enumerating objects: 272, done.remote: Counting objects: 100% (272/272), done.remote: Compressing objects: 100% (182/182), done.remote: Total 272 (delta 98), reused 119 (delta 68), pack-reused 0Receiving objects: 100% (272/272), 13.41 MiB | 1.54 MiB/s, done.Resolving deltas: 100% (98/98), done. 这个文件夹就是我们的远程的仓库克隆下来的地址 查看文件的状态 文件有四种状态，通过下面的命令可以有 123git add . # 添加所以文件到暂存区git status [filename] # 查看文件的状态git commit -m &quot;要备注的信息&quot; # 提交暂存区的内容到本地仓库 -m 提交信息 忽略文件 前端项目的总npm_moudels 有些时候我们不想把某些文件纳入版本控制中，如数据库文件，临时文件，设计文件等 在主目录下建立.gitignore文件，此文件有如下的规则： 忽略文件中的空行或者以#开始的行会被忽略 使用linux通配符，例如*代表任意多个字符 ？代表一个字符 []代表可选字符范围{} 代表可选字符串范围 如果名称的最前面有一个！，表示例外规则，将不被忽略 如果名称前面是一个&#x2F;表示要忽略的文件在此目录下，而子目录中的文件不被忽略 如果名称的后面是一个&#x2F;表示忽略的是此目录下该名称的子目录，而非文件 123456# 为注释*.txt # 忽略所有.txt结尾的文件！lib.txt # 但lib.txt除外/temp # 仅忽略项目根目录下的TODO文件，不包括其他的tempbuild/ # 忽略build/目录下的所有文件doc/*.txt # 会忽略 doc/*.txt 但是不包括 doc/server/arch.txt .gitignore文件1234567891011121314151617181920212223242526272829303132333435363738*.class*.log*.lock# Package Files #*.jar*.war*.eartarget/#idea.idea/*.iml*velocity.log*### STS ###.apt_generated.factorypath.springBeans### Intellij IDEA ###*.iml*.ipr*.iws*.idea.classpath.project.settings/bin/*.logtmp/#rebel*rebel.xml* 使用码云 github是有墙的，比较慢，在国内的话一般使用gitee gitlab 未来找工作的个人东西 设置本机绑定ssh公钥，实现免密登录 进入 ssh-keygen -t rsa 使用码云创建自己的仓库 许可证开源是否可以随意转载 ，开源不能商业使用，不能转载，限制 git clone https://gitee.com/timou_top/java-project.git克隆到本地 使用IDEA集成Git1.新建项目，绑定git 将我们的远程git文件目录拷贝到项目中即可 2.修改文件使用idea操作git 添加到暂存区 commit提交 push到远程仓库 3.提交测试 上面都是单个人的操作 说明：Git分支123456789101112131415161718# 查看所有的分支git branch# 查看远程所有的分支git branch -r# 新建一个分支，但是依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 合并指定分支到当前分支git merge [branch]# 删除远程仓库分支git push origin --delete [branch-name]git branch -dr [remote/branch] 我们多个分支如果并行执行，会导致我们代码不冲突，也就是同时存在多个版本！！！！ web-api A（Restful.xxxx（）） web-admin B 可能调用A 修改了A的代码 web-app C 可能会调用B和A的代码 冲突了协商即可 如果在同一个文件在合并分支的时候都被修改了，则会引起冲突：解决的办法就是我们可以修改冲突文件后重新提交！ master主分支应该非常稳定，用来发布新的版本，一般情况下不允许直接在上面工作，工作上的一般建立在dev上面，工作完之后，比如要发布，，或者说dev分支代码稳定之后可以合并到master上面来。 &#x3D;&#x3D;注意：找人一起搭建一个远程仓库，联系git，两个人或者是三个人都可以练习&#x3D;&#x3D; 团队很重要 寻找小伙伴","tags":["git"]},{"title":"docker学习","path":"/2022/01/08/docker学习/","content":"Docker？ 2020年，docker必备的 Devops Docker 学习 Docker 运行 Docker概述 Docker安装 Docker命令 镜像命令 容器命令 操作命令 。。。 Docker镜像 容器数据卷 DockerFile 做镜像 Docker网络原理 IDEA整合Docker 到这就是单机版的docker 集群 Docker Compose 集群的编排管理 Docker Swarm 相当于简化版的k8s CI&#x2F;CD jenkins Docker概述Docker为什么会出现一款产品： 开发-》上线 两套环境！ 应用环境，应用配置 开发人员 运维人员 会产生问题 我在我的电脑上可以运行，你那不能运行 版本更新导致服务不可用 这些问题对于运维考验是十分大的 开发即运维！ 环境配置是比较麻烦的，每个机器都要部署环境（集群 redis hadoop ES 费时费力） 从根本上上解决问题 发布一个项目 jar war redis mysql jdk es 可能你部署环境的时候部署好久都不能部署完 我们可以带着环境去运行 项目能不能带着环境打包安装 Docker就是干这个事的 配置是十分麻烦的 不能跨平台的 环境是不能跨平台的，环境是天壤指别的 传统的给一个jar就行了，所有的东西交给运维就行了，现在的思想是我们把一套流程做完！ java—–》apk—-》发布 应用商店 软件会有人用 张三使用apk 下载安装即可用！ 我们现在就是这个逻辑，把环境和代码全部打包就可以 Docker仓库 类似一个商店 下载运行即可 Docker给以上的问题提出了解决方案！！！！ Docker的思想就来源于集装箱！ jre —– 多个应用 （端口冲突 配置错误，连接错误） —- 原来可能是交叉的 隔离：Docker的思想 打包装箱，每个箱子是互相隔离的，我们之后就不用担心端口或者是其他的环境出问题了 一个箱子装水果，一个箱子装生化武器 ，现在我们为了让这些东西放在一个环境，我们通过容器进行隔离，我们通过这个就直接可以使用隔离机制保护的很好 Docker通过隔离的机制，可以把服务器运行到极致 Tomcat 集群 或者是redis集群，我们通过docker一键就可以安装了 本质：所有的技术都是因为出现了问题，我们才会去学习，才会出现新的东西 Docker的历史2010年，几个搞it的年轻人，在美国成立了一家公司dotcloud 做一些pass的云计算服务 linux虚拟机 有关的容器技术 将自己的技术（容器化技术）进行统一的简化命名，Docker Docker刚刚诞生的时候，没有引起行业的注意，由于经济问题，dotcloud，经营不下去，开源开放源代码，让所有的人一起研发，2013年，Docker创始人将docker开源，很多人觉得技术可以，现在很多的人发现了docker的优点，所以就火了。几乎每个月就会更新一个版本。到了2014年4月9日docker1.0发布！6年几乎成为开发人员所必须的技术。 Docker为什么会这么火？ 十分轻巧 在容器出来之前，我们都使用的是虚拟机技术 虚拟机：在window装一个虚拟机软件wmware，通过这个软件我们可以虚拟一台或者是多台电脑，十分笨重的是基本的是十几个G的，笨重，好处是每个虚拟的电脑都相当于是一个真实的电脑。虚拟机是虚拟化技术，Docker容器技术也是一种容器化技术！ 例子： 12wm: linux centos 原生镜像（一整个电脑） 隔离需要开启多个虚拟机 一般都要几分钟docker容器： 隔离 镜像机制 只是一个最核心的环境 4m+jdk+mysql 直接运行镜像就可以了，这个东西是十分小巧的 容器是秒级的启动 聊聊DockerDocker是基于GO语言开发的开源项目 官网：https://www.docker.com/ 文档地址：https://docs.docker.com/get-docker/ Docker的文档是十分详细的！！！ 仓库地址：https://hub.docker.com/ pull push 发布到远程仓库也可以 Docker百度百科Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 Docker能干啥？ 之前的虚拟机技术 缺点: 资源占用十分多 冗余步骤多 启动十分的慢 容器化技术 &#x3D;&#x3D;容器化技术不是模拟的一个完整的操作系统，比如安装centos只需要一个核心&#x3D;&#x3D; 比较Docker和虚拟机技术的不同： 传统虚拟机虚拟出一套硬件，运行一个完整的操作系统，在这个系统安装软件运行 容器化技术是直接应用在宿主机的内容，容器是没有内核的，实现公用的内核，也没有虚拟我们的硬件，所有就轻便了 每个容器间是互相隔离的，每个容器都有一个自己的文件系统，互不硬性 Docker 3 30 利用这个linux的环境 DevOps 开发 运维 初级程序员 运维也一定要会 更快速的交付和部署 传统： 帮助文档 安装程序 部署 Docker： 打包镜像，发布测试，一键运行 更便捷的升级和扩缩容 使用了docker我们部署应用就和搭积木一样！！ springboot 1.5 redis 5 tomcat 8 现在我们通过docker就可以直接进行运行了 项目打包一个镜像，服务器A，可以直接在服务器B直接运行 更简单的系统运维 在容器化之后，我们的开发，运行测试基本环境都是高度一直的 更高小的资源利用 1核2G 可以几十个tomcat Docker 是内核级别的虚拟化，可以再咱们的一个物理机上可以运行很多的容器实例！！！服务器的性能可以被压榨到极致 Docker安装Docker基本组成 镜像 image: 就好比一个模板，可以通过模板来创建容器服务，tomcat镜像—-》run——》tomcat容器（提供服务），通过这个镜像可以创建多个容器（最终的服务或者是项目运行就是在这个容器中的） 容器 container：Docker利用容器技术，独立运行一个或者是一组应用，通过镜像来创建的，启动，停止，删除，基本命令！目前就可以把这个容器理解为一个简易的linux系统 仓库 repository：就是存储镜像的地方！！仓库分为公有仓库和私有仓库。Docker Hub（默认是国外的） 阿里云…都有容器服务器（我们可以配置镜像加速） 安装Docker环境准备 会一点的linux基础 Centos 7 我们使用xshell连接远程服务器进行操作 环境查看1234567891011121314151617181920# 系统的内核是3.10版本以上的[root@izbp169pmuqqu68q0mhkfaz /]# uname -r3.10.0-514.26.2.el7.x86_64# 系统版本[root@izbp169pmuqqu68q0mhkfaz /]# cat /etc/os-releaseNAME=&quot;CentOS Linux&quot;VERSION=&quot;7 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;7&quot;PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR=&quot;0;31&quot;CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;HOME_URL=&quot;https://www.centos.org/&quot;BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot; 安装1234567891011121314151617181920212223242526272829303132# 1.卸载旧的版本yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 2. 需要的安装包yum install -y yum-utils# 3. 设置镜像的仓库yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 这个是阿里云的 推荐使用，不然的话十分的慢 https://download.docker.com/linux/centos/docker-ce.repo # 默认的是国外的，我们使用国内的# 更新索引yum makecache fast# 4.安装docker最新的 docker-ce是社区版的 ee是企业版的 官方也使用ceyum install docker-ce docker-ce-cli containerd.io# 5.启动dockersystemctl start docker# 6.安装成功下图所示 12# 7.运行hello-worlddocker run hello-world 运行成功： 12# 8.查看hello-world镜像在不在docker images 卸载docker1234# 移除镜像yum remove docker-ce docker-ce-cli containerd.io# 删除工作目录rm -rf /var/lib/docker 设置阿里云加速 登录阿里云找到容器镜像服务 找到镜像加速 配置使用 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://5q2uftpp.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 回顾hello-world流程运行流程图 有些没有会找不到，报错 底层原理Docker是如何工作的 Docker是一个client-server结构的系统，Docker的守护运行在我们的主机上（宿主机），通过Socker从客户端访问 DockerServer接受DockerClient的指令，就会执行这个指令 Docker为什么比虚拟机快： 左边是虚拟机，右边是docker docker有着比虚拟机更少的抽象层 docker利用的是宿主机的内核，vm需要的是Guest OS 所以说，新建一个容器的时候，docker并不需要像虚拟机一样重新加载一个操作系统的内核，避免引导。虚拟机加载的是Guest OS，分钟级别的，而docker利用的是宿主机的操作系统，省略了这个复杂的过程 之后学习完毕所有的命令，在回过头来看这段理论就会十分清晰的 Docker的常用命令帮助命令123docker version # 显示docker的版本信息docker info # 显示更加详细的信息 镜像和容器的数量的等docker 命令 --help # 帮助 命令文档：https://docs.docker.com/reference/ 镜像的命令12345678910111213141516171819docker images # 查看所有本地主机上面的镜像[root@izbp169pmuqqu68q0mhkfaz /]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest bf756fb1ae65 9 months ago 13.3kBREPOSITORY # 镜像的仓库源TAG # 镜像的标签IMAGE ID # 镜像的idCREATED # 镜像的创建时间SIZE # 镜像的大小# 可选项 -a # 列出所有的镜像 -q # 只显示镜像的id -aq # 显示所有镜像的id docker search 可以直接去这个地址搜索镜像：https://registry.hub.docker.com/ 镜像搜索123456789101112131415docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10015 [OK] mariadb MariaDB is a community-developed fork of MyS… 3669 [OK] # 可选项 -f, --filter filter Filter output based on conditions provided # 过滤 --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don&#x27;t truncate output [root@izbp169pmuqqu68q0mhkfaz /]# docker search mysql --filter=STARS=3000NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10015 [OK] mariadb MariaDB is a community-developed fork of MyS… 3669 [OK] 下载镜像123456789101112131415161718192021222324252627282930313233343536373839404142docker pull mysql # 下载镜像 默认使用最新版[root@izbp169pmuqqu68q0mhkfaz /]# docker pull mysqlUsing default tag: latest # 如果不写tag默认是罪行的latest: Pulling from library/mysqld121f8d1c412: Pull complete # 分层下载 docker image的核心f3cebc0b4691: Pull complete 1862755a0b37: Pull complete 489b44f3dbb4: Pull complete 690874f836db: Pull complete baa8be383ffb: Pull complete 55356608b4ac: Pull complete dd35ceccb6eb: Pull complete 429b35712b19: Pull complete 162d8291095c: Pull complete 5e500ef7181b: Pull complete af7528e958b6: Pull complete Digest: sha256:e1bfe11693ed2052cb3b4e5fa356c65381129e87e38551c6cd6ec532ebe0e808 #签名Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest # 真实地址# 下面的这两个命令是等价的docker pull mysqldocker pull docker.io/library/mysql:latest# 指定版本下载[root@izbp169pmuqqu68q0mhkfaz /]# docker pull mysql:5.75.7: Pulling from library/mysql d121f8d1c412: Already exists # 之前下载过了，可以使用以前的东西f3cebc0b4691: Already exists 1862755a0b37: Already exists 489b44f3dbb4: Already exists 690874f836db: Already exists baa8be383ffb: Already exists 55356608b4ac: Already exists 277d8f888368: Pull complete 21f2da6feb67: Pull complete 2c98f818bcb9: Pull complete 031b0a770162: Pull complete Digest: sha256:14fd47ec8724954b63d1a236d2299b8da25c9bbb8eacc739bb88038d82da4919Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 docker rim删除镜像 没有全部删除，只删除了属于5.7版本的层次的东西 123docker rmi -f ef08065b0a30 # 删除指定id 的镜像docker rmi -f id [id] # 删除多个镜像docker rmi -f $(docker images -aq) #删除所有的镜像 容器命令说明： 我们有了镜像才会有容器，我们下载一个centos来测试学习 1docker pull centos 新建容器并且启动12345678910111213141516171819202122232425262728293031323334353637383940docker run [可选参数] image# 参数说明--name # 容器名字 tomcat01 用来区分容器-d # 后台运行-it # 使用交互模式运行-p # 指定的容器的端口 8080:8080 -p ip：主机端口：容器端口 -p 主机端口：容器端口 （常用） -p 容器端口 容器端口-P # 随机指定端口# 测试[root@izbp169pmuqqu68q0mhkfaz /]# docker run -it centos /bin/bash # 启动并且进入容器[root@42dde16a4b41 /]# # 此时已经在容器的内部了[root@42dde16a4b41 /]# lsbin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var# 上面的就是一个小型的服务器 跟外部的没有啥关系# 从容器中推到主机[root@42dde16a4b41 /]# exitexit[root@izbp169pmuqqu68q0mhkfaz /]# lsbin boot data dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var# 列出所有的运行的容器[root@izbp169pmuqqu68q0mhkfaz /]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42dde16a4b41 centos &quot;/bin/bash&quot; 4 minutes ago Exited (0) About a minute ago strange_hoover30aaa7b43000 bf756fb1ae65 &quot;/hello&quot; 2 hours ago Exited (0) 2 hours ago busy_ptolemy # 列出当前正在运行的容器-a # 列出当前正在运行的容器，还有历史运行的容器-n=? # 显示最近创建的容器-q # 只显示容器的编号 退出容器123exit # 容器停止退出ctrl+p+q # 容器停止不退出 删除容器1234docker rm 容器id # 删除指定的容器docker rm $(docker ps -aq) # 删除所有的容器# 不能删除正在运行的容器docker ps -a -qxargs docker rm # 删除所有的容器 启动和停止容器12345docker start 容器id # 启动启动容器docker stop 容器id # 停止当前正在运行容器docker restart 容器id # 重启容器docker kill 容器id # 强制停止当前容器 常用的其他命令123456789101112131415# 后台启动# docker run -d 镜像名docker run -d centos# 问题 ： docker ps 发现centos停止了# 常见的坑，容器使用后台运行，就必须要有一个前台进程，docker发现没有应用就会自动停止# nginx，容器启动之后，发现自己没有服务会立刻停止 发现没有程序了，最后就停止了# 查看日志 docker logsdocker logs -f -t --tail 19 26534cd836dc 没有日志，自己编写一段shell脚本--tail num # 要显示的日志条数-f # 带上时间戳&quot;while true:do echo timous;sleep 2;&quot; 查看容器中的进程信息 1234567891011[root@izbp169pmuqqu68q0mhkfaz /]# docker top --helpUsage:\tdocker top CONTAINER [ps OPTIONS]Display the running processes of a containerdocker top 容器id[root@izbp169pmuqqu68q0mhkfaz /]# docker top ee55e34eb941UID PID PPID C STIME TTY TIME CMDroot 17647 17626 0 16:06 ? 00:00:00 /bin/bash -c while true;do echo timous;sleep 1;doneroot 17987 17647 0 16:09 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1 查看镜像的元数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210docker inspect ee55e34eb941[root@izbp169pmuqqu68q0mhkfaz /]# docker inspect ee55e34eb941[ &#123; &quot;Id&quot;: &quot;ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3&quot;, &quot;Created&quot;: &quot;2020-10-04T08:06:10.003607393Z&quot;, &quot;Path&quot;: &quot;/bin/bash&quot;, &quot;Args&quot;: [ &quot;-c&quot;, &quot;while true;do echo timous;sleep 1;done&quot; ], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 17647, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2020-10-04T08:06:10.379247101Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125;, &quot;Image&quot;: &quot;sha256:0d120b6ccaa8c5e149176798b3501d4dd1885f961922497cd0abef155c869566&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3/ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3-json.log&quot;, &quot;Name&quot;: &quot;/charming_gates&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: &#123; &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: &#123; &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: &#123;&#125; &#125;, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: &#123;&#125;, &quot;RestartPolicy&quot;: &#123; &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 &#125;, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;Capabilities&quot;: null, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: false, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] &#125;, &quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/e9f1b7ac4782a1ff47ebd0ac9a25147a64006cc8b0ba8fdb86d31980438a3850-init/diff:/var/lib/docker/overlay2/2f1f2c9feada01705f5f971d6cbf9f5cdb6d64de3a48556ed7fada3f8252ac9d/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/e9f1b7ac4782a1ff47ebd0ac9a25147a64006cc8b0ba8fdb86d31980438a3850/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/e9f1b7ac4782a1ff47ebd0ac9a25147a64006cc8b0ba8fdb86d31980438a3850/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/e9f1b7ac4782a1ff47ebd0ac9a25147a64006cc8b0ba8fdb86d31980438a3850/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;, &quot;Mounts&quot;: [], &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;ee55e34eb941&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;while true;do echo timous;sleep 1;done&quot; ], &quot;Image&quot;: &quot;centos&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123; &quot;org.label-schema.build-date&quot;: &quot;20200809&quot;, &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;, &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;, &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;, &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot; &#125; &#125;, &quot;NetworkSettings&quot;: &#123; &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;9a08423b1508ec7922699865f0f5482ee7c6dc9a0b37451201e89a6a604cbc86&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: &#123;&#125;, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/9a08423b1508&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;86c2383afa0dc2f44b00f5d8ac8bc939a9b5080d01378021adbed863652bcd5d&quot;, &quot;Gateway&quot;: &quot;172.18.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.18.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;, &quot;Networks&quot;: &#123; &quot;bridge&quot;: &#123; &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;30b06d957b64f677ac44cc752d240e535850bb5bacc643d96dcf2ea976880c80&quot;, &quot;EndpointID&quot;: &quot;86c2383afa0dc2f44b00f5d8ac8bc939a9b5080d01378021adbed863652bcd5d&quot;, &quot;Gateway&quot;: &quot;172.18.0.1&quot;, &quot;IPAddress&quot;: &quot;172.18.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;, &quot;DriverOpts&quot;: null &#125; &#125; &#125; &#125;] 进入当前正在运行的容器 12345678910111213141516171819# 我们通常都是使用后台管理的方式进行运行的，我们需要进入容器，修改一些配置#命令docker exec -it 容器id /bin/bash[root@izbp169pmuqqu68q0mhkfaz /]# docker exec -it ee55e34eb941 /bin/bash[root@ee55e34eb941 /]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 08:06 ? 00:00:00 /bin/bash -c while true;do echo timous;sleep 1;doneroot 2075 0 0 08:40 pts/0 00:00:00 /bin/bashroot 2099 1 0 08:40 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1root 2100 2075 0 08:40 pts/0 00:00:00 ps -ef# 方式二docker attach 容器id# 测试[root@izbp169pmuqqu68q0mhkfaz /]# docker attach ee55e34eb941正在执行当前的代码exec 进入容器之后开启一个新的终端，可以在里面操作attach 进入容器正在执行的终端，不会启动新的进程 从容器拷贝文件到主机内 12345678910111213141516docker cp 容器id：容器内路径 目的主机路径[root@izbp169pmuqqu68q0mhkfaz home]# docker attach c6a9acaf91e5 [root@c6a9acaf91e5 /]# cd /home[root@c6a9acaf91e5 home]# ls[root@c6a9acaf91e5 home]# touch test.java[root@c6a9acaf91e5 home]# exit exit[root@izbp169pmuqqu68q0mhkfaz home]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc6a9acaf91e5 centos &quot;/bin/bash&quot; 2 minutes ago Exited (0) 4 seconds ago romantic_almeida[root@izbp169pmuqqu68q0mhkfaz home]# docker cp c6a9acaf91e5:/home/test.java /home[root@izbp169pmuqqu68q0mhkfaz home]# lsadmin staragent test.java timous.java www# 拷贝是一个手动过程 未来我们可以使用卷技术来进行实现 小结 123456789101112131415161718192021222324252627282930313233343536373839404142434445attach Attach to a running container # 当前 shell 下 attach 连接指定运行镜像build Build an image from a Dockerfile # 通过 Dockerfile 定制镜像commit Create a new image from a container changes # 提交当前容器为新的镜像cp Copy files/folders from the containers filesystem to the host path#从容器中拷贝指定文件或者目录到宿主机中create Create a new container # 创建一个新的容器，同run，但不启动容器diff Inspect changes on a container&#x27;s filesystem # 查看 docker 容器变化events Get real time events from the server # 从 docker 服务获取容器实时事件exec Run a command in an existing container # 在已存在的容器上运行命令export Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ]history Show the history of an image # 展示一个镜像形成历史images List images import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]info Display system-wide information # 显示系统相关信息inspect Return low-level information on a container # 查看容器详细信息kill Kill a running container # kill 指定 docker 容器load Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save]login Register or Login to the docker registry server # 注册或者登陆一个docker 源服务器logout Log out from a Docker registry server # 从当前 Dockerregistry 退出logs Fetch the logs of a container # 输出当前容器日志信息port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT #查看映射端口对应的容器内部源端口pause Pause all processes within a container # 暂停容器ps List containers # 列出容器列表pull Pull an image or a repository from the docker registry server #从docker镜像源服务器拉取指定镜像或者库镜像push Push an image or a repository to the docker registry server #推送指定镜像或者库镜像至docker源服务器restart Restart a running container # 重启运行的容器rm Remove one or more containers # 移除一个或者多个容器rmi Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]run Run a command in a new container # 创建一个新的容器并运行一个命令save Save an image to a tar archive # 保存一个镜像为一个tar 包[对应 load]search Search for an image on the Docker Hub # 在 docker hub 中搜索镜像start Start a stopped containers # 启动容器stop Stop a running containers # 停止容器tag Tag an image into a repository # 给源中镜像打标签top Lookup the running processes of a container # 查看容器中运行的进程信息unpause Unpause a paused container # 取消暂停容器version Show the docker version information # 查看 docker 版本号wait Block until a container stops, then print its exit code # 截取容器停止时的退出状态值 docker上面学的知识最基本的命令，还有很多的命令需要学习 作业练习Docker安装Nginx12345678910111213141516171819202122232425262728293031323334353637383940414243# 1. 搜索镜像 dockerhub上去搜索# 2. 下载镜像# 3. 运行下载的Nginx-d # 后台启动 --name 给容器起名字 -p 宿主机端口：容器内端口docker run -d --name nginx01 -p 3344:80 nginx# 本地测试 curlcurl localhost:3344# 测试结果&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;root@09646f289814:/# whereis nginxnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginxroot@09646f289814:/# cd /etc root@09646f289814:/etc# cd nginxroot@09646f289814:/etc/nginx# lsconf.d\tfastcgi_params\tkoi-utf koi-win mime.types modules nginx.conf scgi_params\tuwsgi_params win-utf **注意：**如果端口或者不能启动的话就直接重启docker 1[root@izbp169pmuqqu68q0mhkfaz home]# systemctl restart docker # 重启docker 端口暴露：、 思考问题： 我们每次改动nginx配置文件都需要进入容器的内部，我要是能够在容器外部提供一个映射路径，达到在容器外部修改文件，容器内部就可以自动修改？ -v 数据卷的技术 Docker安装Tomcat&#x3D;&#x3D;注意：&#x3D;&#x3D;这里的容器内部的和容器外部的端口都要打开的 123456789101112131415# 官方的使用docker run -it --rm tomcat:9.0# 我们之前都是启动的后台，停止容器之后还是可以找到的，上面的是用完就会删除的 但是不会删除镜像#下载启动# 测试访问没问题，但是没有出现tomcat页面 这是因为这是个不完整的版本的docker exec -it tomcat01 /bin/bash# 进入之后发现 没有webapps和ll命令 阿里云镜像的原因，默认是最小的镜像，所有的不必要的都剔除掉，保证最小可运行的环境cp -r webapps.dist/* webappsroot@5d448aeddfff:/usr/local/tomcat/webapps# lsROOT docs examples host-manager manager 思考问题： 我们以后部署项目，每次都进去是十分麻烦的，我们如果可以在容器外部提供一个映射路径，webapps，使得我们在外部放置的项目自动同步到我们的内部就好了。 部署es+kibana12345678910111213141516171819# es 暴露的端口很多# es 十分消耗内存# es的数据一般要放置到安全文件夹# --net somenetwork这是一个网络配置docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:tag# 下载启动docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2# 启动完之后发现自己的服务器都是很卡的 docker status 查看cpu的状态# 启动完之后发现自动关了# 测试es是否成功了# 开始测试的时候发现他自动停止了# 可以修改配置文件 -e 环境配置修改docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2 12345678910111213141516171819[root@izbp169pmuqqu68q0mhkfaz /]# clear[root@izbp169pmuqqu68q0mhkfaz /]# curl localhost:9200&#123; &quot;name&quot; : &quot;bf3f2cba9661&quot;, &quot;cluster_name&quot; : &quot;docker-cluster&quot;, &quot;cluster_uuid&quot; : &quot;6SNBo33YSSaOLNBJ8IN_SQ&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;7.6.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;docker&quot;, &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;, &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.4.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 作业：使用kibana连接 可视化 portainer 1docker run -d -p 8088:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true pontainer/pontainer Ranch （持续集成和部署） 什么是portainer？ Docker的图形化界面管理工具！提供一个后台模板供我们操作 1234567docker run -d -p 8088:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true pontainer/pontainer# 这个是我们的官方给的东西 上面的经过试验，不能使用$ docker volume create portainer_data$ docker run -d -p 8088:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainerhttp://localhost:8088/ 运行之后的截图 选择本地的 进入之后的面板 我们所有的信息都可以看到 我们平时不会使用，我们测试一下就可以了。 Docker镜像讲解镜像是什么镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件的所有内容，包括代码，运行时，库，环境变量和配置文件 所有的应用直接打包成为一个Docker镜像部署 如何得到镜像： 远程仓库下载 朋友拷贝给你 自己制作一个镜像Dockerfile Docker加载原理 UnionFS 联合文件系统 我们下载的时候看到的一层一层的就是这个 UnionFS（联合文件系统）： Union文件系统时一种分层、轻量级并且高性能的文件系统，它支持对文件系统的的修改，作为一次提交来一层一层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite severral directions into single virtual filesystem）.Union文件系统时Docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 特性： 一次同时加载多个文件系统，但是从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有的底层的文件和目录 类似于git 的版本控制 ， 每一次都会直接记录下来 比如tomcat和mysql都是在centos下面执行的，我们下载一个就够了（这只是一个说法） Docker镜像加载原理 docker的镜像实际上是由一层一层的文件系统组成，这种层级的文件系统UnionFS（联合文件系统） boorfs（boot file system）主要包含bootloader和kernel，bootloader主要用于引导加载kernel，linux刚启动的时候会加载bootfs文件系统，早Docker镜像的最底层bootfs，这一层和我们典型的linux&#x2F;unix系统是一样的，包含boot加载器和内核。当boot加载完成之后，整个内核就在内存中了，此时内存的使用权由bootfs转交给内核，此时系统也会卸载bootfs rootfs（root file system），在bootfs之上，包含的就是典型linux系统中的。&#x2F;dev, &#x2F;proc ,&#x2F;bin ,&#x2F;etc等标准文件和目录。rootfs就是各种不同的操作系统发行版本，比如ubuntu ，centos等等 平时我们安装的centos是需要好几个G的，为什么这里的centos才200M？ 对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令和程序库就可以了，因为底层都是直接用的Host的kernel，自己只需要提供rootfs就可以了，由此可见，对于不同的linux发行的版本，bootfs基本上是一致的，因此不同的发行版本可以使用一个bootfs。 分层理解 分层的镜像 我们可以去下载一个镜像，发现观察下载的日志输出，可以看到是一层一层的在下载 这里的每一层就是一个文件级的记录 理解： 所有的Docker镜像都是起始于一个基础的镜像层，当进行修改或增加新的内容的时候，就会在当前的镜像之上，创建新的镜像，举一个简单的例子，假如基于Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果该镜像中添加了python包，就会在基础的镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层 该镜像相当于已经包含了三个镜像层，如下图所示（这是一个用于演示的很简单的例子） 在添加额外的镜像的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要，下图举了一个简单的例子，每个镜像包含三个文件，而镜像包含了来自两个镜像层的六个文件 上图中的镜像层跟之前的图中略有区别，主要目的是便于展示文件 下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为上层的文件7是文件5的一个更新版本 这种情况下，上层镜像层中的文件覆盖了底层镜像中的文件。这样就使得文件的更新版本作为一个新的镜像层添加到镜像当中。Docker可以通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示同一的文件系统。Linux上可用存储的引擎有： AUFS、Overlay2、Device Mapper、Btrfs以及zfs。顾名思义，每种存储引擎都基于Linux中对应文件系统或者块设备技术，并且每种存储引擎都有独特的性能特点。 Docker在Windows上仅支持windowfilter一种存储引擎，该存储引擎基于NTFS文件系统之上实现了分层和COW[1]. 下图展示了与系统显示相同的三层镜像，所有镜像层堆叠合并，对外提供统一的视图 特点 Docker默认都是只读的，容器启动时，一个新的可写层被加载到镜像的顶部！ 这一层就是我们通常所说的容器层，容器层之下的都叫镜像层 也就是说原来的你是没有动，只是在上面添加了新的东西 如何提交一个自己的镜像 Commit镜像123docker commit # 提交容器成为一个新的副本# 命令和git类似docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器 id 目标镜像名：[TAG] 实战测试： 1234567# 启动一个默认的tomcat# 发现这个默认的tomcat是没有webapps应用的，镜像的原因，官方的镜像是默认没有webapps的文件的# 自己拷贝了应该有的文件# 将操作过的容器通过commit提交为一个镜像，我们以后就使用这个修改多的镜像就可以了，这就是我们自己修改过的一个镜像 学习方式说明： 概念 ，一定要实践，实践和理论像结合，一次搞定 如果你想保存当前容器的状态，，就可以通过commit来进行提交，获得一个镜像，就好比虚拟机的快照 现在就是入门 容器数据卷什么是容器数据卷docker的理念： ​\t将环境和应用打包成为一个镜像！！ 如果数据放在容器中，那么我们删除容器的时候，数据就会丢： 需要数据持久化 MySQL，容器删了，MySQL的数据可以保存在本地 容器之间可以有一个数据共享的技术！！Docker容器中产生的数据可以同步到本地，容器删除，数据不会丢失，这就是我们的卷技术！ 也就是目录的挂载，将我们的容器的目录挂在在linux上。 就是为了容器的持久化和同步操作，容器间的数据也是可以共享的 使用数据卷 使用命令来进行挂载 1docker run -it -p 主机端口：容器端口 -v 容器内的目录：主机目录 运行的容器的： 主机上面的： 从这里可以看出，我们的数据时挂载过来了 这也就类似于双向绑定，这样即使把容器删除之后也会保留数据的，缺点是数据会有两份的 即使容器停止之后，在宿主机修改文件，容器也是会更改的 实战： 安装mysqlmysql的数据持久化问题 data 123456789101112131415161718# 1. 获取镜像docker search mysql# 2. 运行容器 做数据挂载 # 安装启动mysql的时候需要配置密码的# 官方测试$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag# 启动mysql-d 后台运行-p 端口映射-v 路径挂载-- name 名字-e 配置环境# /home/mysql/conf:/etc/mysql/conf.d /home/mysql/conf 这个时候在5.7版本的是没有数据的，8.0以上的版本可能会有docker run -d -p 3344:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysqldev mysql# 此时的mysql的最新版本和旧的版本可能是不一样的 mysql5.7成功连接 但是最新的mysql用sqlyog或者是navcat都无法成功docker run -d -p 3355:3306 -v /home/mysql01/conf:/etc/mysql -v /home/mysql01/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 经过查看之后发现是因为加密规则发生了变化， 123456789101112131415# 进入mysql8.0版本的docker exec -it acd145dcb29d /bin/bash# 进入我们的mysqlroot@acd145dcb29d:/# mysql -uroot -pEnter password: Welcome to the MySQL monitor# 修改加密规则mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27; PASSWORD EXPIRE NEVER;Query OK, 0 rows affected (0.24 sec)mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;Query OK, 0 rows affected (0.02 sec)# 修改加密规则之后修改密码mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;Query OK, 0 rows affected (0.01 sec) 此时我们再通过连接发现已经可以连接上去了： 在本地创建数据库，查看映射的路径也是没有问题的，经过测试在干掉mysql容器之后，服务器本地依然书没有数据的丢失的 具名挂载和匿名挂载12345678910111213141516# 匿名挂载-v 容器内路径docker run -d -p --name nginx01 -v /etc/nginx nginx# 查看所有的卷的情况# -v 卷名:容器内路径docker volume lsDRIVER VOLUME NAMElocal edfe864135f1168478f3f213897a44bd3fa637309aad854a37a4ea02ba2fa736 # 这个时候匿名挂载local portainer_data local 47b671908d5e1b9b7abe1b3e07ea090e1a45061f0cc6f98000c3d7e07c0d1c6elocal edfe864135f1168478f3f213897a44bd3fa637309aad854a37a4ea02ba2fa736local nginxtest # 这个是具名挂在local portainer_data 所有docker容器内的卷，没有指定目录的情况下，都是在/var/lib/docker/volumes/nginxtest/_data 我们通过具名挂载可以方便的找到我们的一个卷，大多数情况下使用具名挂载 如何确定是具名挂载还是匿名挂载，还是指定路径挂载 123456-v 容器内路径 # 匿名挂载-v 卷名：容器内路径 # 具名挂载-v /宿主机路径：容器内路径 # 指定路径挂载ro/rw # 这个是指定读写权限的 ro read only rw read write# 一旦设定了 ro 我们就改动不了了 ro意思是只能从外部改变，不能从内部改变 也就是宿主机可以改变，但是容器内不能改变docker run -d -P --name nginx05 -v nginxtest:/etc/nginx：ro/rw nginx 初识DockerFiledockerfile就是用来构建docker镜像文件的构建文件！！命令脚本 方式二 123456789101112# 通过这个脚本可以生成镜像 ， 镜像是一层一层的，脚本是一个一个命令，每个命令就是一层# 指令和参数FROM centos VOLUME [&quot;volumn01&quot;,&quot;volumn02&quot;]CMD echo &quot;---end------&quot;CMD /bin/bash# 这里的每个命令就是一层 -f 文件所在的位置 -t 生成的镜像的名字和版本 # 注意这里的后面有一个点是必须加上的docker build -f dockerfile1 -t timouscentos:1.0 . 启动自己生成的容器 上面的两个是我们在生成镜像的时候所挂载的，这个卷和外部肯定有一个同步的目录，这个是匿名挂载，找的时候是乱码 从我们的Mounts，可以看到为止 这种方式我们使用的十分多，通常我们会构建自己的镜像 假设构架你的时候没有挂载卷，要手动进行镜像挂载 -v 卷名：容器内路径 数据卷容器是多个容器之间共享数据 ， 如多个mysql数据同步 contos01就是数据卷容器，两个或者是多个容器实现数据共享 12# 通过自己写的镜像启动docker run -it --name docker03 --volumes-from docker01 5d8055e306ce docker01 docker02 docker01创建文件 docker02 docker01创建的东西，docker02也能接收到，docker run -it --name docker03 --volumes-from docker01 5d8055e306ce，只要通过这种进行挂载的，都会成功进行共用。此时就算docker01容器没有的时候，我们的02和03依然是可以访问之前创建的文件的。 最主要的还是他们都挂载在相同的目录了 mysql数据共享多个mysql实现数据共享，redis实现数据共享 123456# docker run -d -p 3355:3306 -v /home/mysqltest1/conf:/etc/mysql -v /home/mysqltest1/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7docker run -d -p 3344:3306 -e MYSQL_ROOT_PASSWORD=123456 --volumes-from mysql01 --name mysql02 mysql:5.7# 这个时候就会实现数据的共享 结论： 容器之间配置信息的传递，容器数据卷的生命周期会一直持续到没有容器使用为止 但是一旦持久化到了本地，这个时候本地的数据是不会删除的 但是这种挂载启动的时候发现mysql是无法同时登陆两个的，可能是因为二者公用的是一个数据，所以一个连接的时候另外一个不能连接 DockerFiledockerfile是用来构建docker镜像的文件命令参数脚本 构建步骤： 编写一个dockerfile文件 docker build 构建一个镜像 docker run 运行镜像 docker push 发布镜像 DockerHub 阿里云镜像仓库等 查看官方是怎么做的 这就是一个基本的命令脚本。 123456789101112131415FROM scratch # 这是一个最基础的ADD centos-7-x86_64-docker.tar.xz / #添加一个centos的镜像LABEL \\ org.label-schema.schema-version=&quot;1.0&quot; \\ org.label-schema.name=&quot;CentOS Base Image&quot; \\ org.label-schema.vendor=&quot;CentOS&quot; \\ org.label-schema.license=&quot;GPLv2&quot; \\ org.label-schema.build-date=&quot;20200809&quot; \\ org.opencontainers.image.title=&quot;CentOS Base Image&quot; \\ org.opencontainers.image.vendor=&quot;CentOS&quot; \\ org.opencontainers.image.licenses=&quot;GPL-2.0-only&quot; \\ org.opencontainers.image.created=&quot;2020-08-09 00:00:00+01:00&quot;CMD [&quot;/bin/bash&quot;] 很多官方的镜像都是基础包，很多的功能是没有的，我们通常会自己搭建自己的镜像 官方可以制作镜像，我们也可以制作自己的镜像 DockerFile构建过程 基础知识： 保留的关键字都必须是大写字母 执行顺序从上到下 #表示注释 每一条命令都是一层 DockerFile是面向开发的，我们以后要发布项目做镜像，我们就要编写dockerfile文件，这个文件十分简单 Docker镜像已经逐渐成为企业交付的标准，必须掌握 步骤 开发 部署 上限 运维 DockerFile： 构建文件，定义了一切的步骤，好比一个源代码 DockerIamages ： 通过DockerFile构建成的镜像，最终发布和运行的产品 Docker容器: 容器就是镜像运行起来提供服务的 DockerFile的指令12345678910111213141516# 上面我们都是使用别人的，现在我们就可以自己写一个镜像了FROM # 基础镜像， 一切从这里开始构建MAINTAINER # 镜像是谁写的 姓名+邮箱RUN # docker镜像运行时需要构建的路径ADD # 步骤 ， 搭建一个有tomcat 的 要加一个tomcat的压缩包，添加内容WORKDIR # 镜像的等工作目录 /或者是哪个路径VOLUME # 挂载卷EXPOSE # 指定暴露端口 在这里暴露 外面就不需要暴露了ls -a -l前者不显示，后者显示CMD # 指定这个容器启动的时候要运行的命令 只有最后一个会生效，可被替代ENTRYPOINT # 可以直接追加命令ONBUILD # 当构建一个被继承DockerFile 这个时候就会运行ONBUILD指令 触发指令COPY # 类似ADD ， 将我们的文件拷贝到镜像中ENV # 构建的时候设置环境变量 实战测试DockerHub大多数的镜像都是从基础镜像中获取的 FROM scratch 创建一个自己的centos 123456789101112131415161718192021222324252627282930# 1.编写dockerfile文件FROM centosMAINTAINER timous&lt;1844736251@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;---end-----&quot;CMD /bin/bash# 2. 通过这个文件构建镜像-f dockerfile文件路径-t 镜像名和标签docker build -f mydockerfile -t mycentos:0.1 .Successfully built 4ab9930f53eeSuccessfully tagged mycentos:0.1# 3. 测试运行 直接进入了工作路径，而不是根目录 对比之前原生的，我们多了自己添加的功能。 我们可以列出本地镜像的变更历史 CMD 和ENTRYPOINT 的区别1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889CMD # 指定这个容器启动的时候要运行的命令 只有最后一个会生效，可被替代ENTRYPOINT # 可以直接追加命令FROM centosCMD [&quot;ls&quot;,&quot;-a&quot;]# 构建镜像[root@izbp169pmuqqu68q0mhkfaz dockerfile]# docker build -f dockercmd -t cmd:0.1 .Sending build context to Docker daemon 3.072kBStep 1/2 : FROM centos ---&gt; 0d120b6ccaa8Step 2/2 : CMD [&quot;ls&quot;,&quot;-a&quot;] ---&gt; Running in 252ebc591da5Removing intermediate container 252ebc591da5 ---&gt; 48c2615d874aSuccessfully built 48c2615d874aSuccessfully tagged cmd:0.1# 运行[root@izbp169pmuqqu68q0mhkfaz dockerfile]# docker run cmd:0.1....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar# 发现我们的命令生效了# 想追加一个命令 发现错误了 它会替换 docker run cmd:0.1 ls -al[root@izbp169pmuqqu68q0mhkfaz dockerfile]# docker run cmd:0.1 -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused &quot;exec: \\&quot;-l\\&quot;: executable file not found in $PATH&quot;: unknown.# ENTRYPOINT 不需要进行替换FROM centosENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;][root@izbp169pmuqqu68q0mhkfaz dockerfile]# docker run 2b16d27edab1....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar[root@izbp169pmuqqu68q0mhkfaz dockerfile]# docker run 2b16d27edab1 -ltotal 56drwxr-xr-x 1 root root 4096 Oct 5 09:13 .drwxr-xr-x 1 root root 4096 Oct 5 09:13 ..-rwxr-xr-x 1 root root 0 Oct 5 09:13 .dockerenvlrwxrwxrwx 1 root root 7 May 11 2019 bin -&gt; usr/bindrwxr-xr-x 5 root root 340 Oct 5 09:13 devdrwxr-xr-x 1 root root 4096 Oct 5 09:13 etc# 从结果可以看出我们的ENTRYPOINT 不会替换，是直接在后面追加命令的 并没有被替换 ，而是追加了docker存在很多这样的命令的 Docker‘中很多的命令都十分的相似，我们需要去了解他们的区别。我们最好就是对比练习。 实战：Tomcat 准备镜像文件，tomcat压缩包和jdk压缩包 编写Docker文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Dockerfile 是官方的命名，我们之后启动的时候不用加-f 了，就会去找这个文件FROM centosMAINTAINER timous&lt;1844736251@qq.com&gt;COPY read.txt /usr/local/readme.txtADD jdk-8u231-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.38.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_231ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.38ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.38ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME:lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.38/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.38/bin/logs/catalina.out# JDKFROM centosMAINTAINER timous&lt;1844736251@qq.com&gt;ADD jdk-8u231-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.38.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_231ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV PATH $PATH:$JAVA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.38/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.38/bin/logs/catalina.out# 构建镜像 docker build -t mytomcat .# 启动镜像docker run -d -p 8001:8080 --name mytomcat00 -v /home/tomcat/test:/usr/local/apache-tomcat-9.0.38/webapps -v /home/tomcat/tomcatlogs:/usr/local/apache-tomcat-9.0.38/logs mytomcat# 直接在本地发布项目就可以了，在挂载的目录下就可以了 &#x3D;&#x3D;注意：这里解压之后的webapps里面也是没有东西的，相当于是阉割版的，我们需要在里面添加东西再启动才能访问8080端口，这里只需要把webapps里面的东西考进去就行了，经过测试8.x和9.x是一样的，都是阉割版的，没有webapps下面的东西&#x3D;&#x3D; 经过测试，这个就可以直接发布项目了，之后需要掌握DockerFile的编写以及命令，之后我们就可以自己写项目发布应用了。 发布自己的镜像 DockerHub 1.地址：https://hub.docker.com/ 2.确定和这个账号能够登录就行了 3.在我们本地的linux登录我们的dockerhub账户 1234567891011[root@izbp169pmuqqu68q0mhkfaz ~]# docker login --helpUsage:\tdocker login [OPTIONS] [SERVER]Log in to a Docker registry.If no server is specified, the default is defined by the daemon.Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username 4.登录完毕之后我们自己docker push就可以了 1234567[root@izbp169pmuqqu68q0mhkfaz ~]# docker login -u timousPassword: WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded 5.提交镜像 12345678910111213The push refers to repository [docker.io/library/mytomcat]c67968a0b49c: Preparing 974165b6465d: Preparing 4aa18435b87c: Preparing 19a87c01b4dd: Preparing 291f6e44771a: Preparing denied: requested access to the resource is denied # 这个时候回被拒绝 可能不是因为本地的# 尽量带上自己的版本号# 增加一个tag就可以了 还有就是也要带上自己的版本号和名字 一般的话没有名字是提交不上去的[root@izbp169pmuqqu68q0mhkfaz ~]# docker tag 6c4d4c60d337 timous/tomcat:1.0[root@izbp169pmuqqu68q0mhkfaz ~]# docker push timous/tomcat:1.0 提交的时候还是按照层级来进行发布的。 阿里云镜像服务上面也可以发布 1.创建命名空间 2.创建容器镜像 3.浏览阿里云的信息 &#x3D;&#x3D;注意：这里要按照阿里云上的名字命名，不然的话会被拒绝的&#x3D;&#x3D; 也就是参考官方文档，下面就是我们的发布的image 阿里云操作1. 登录阿里云Docker Registry1$ sudo docker login --username=我命由我不由天0000-1dgpcx registry.cn-hangzhou.aliyuncs.com 用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。 您可以在访问凭证页面修改凭证密码。 2. 从Registry中拉取镜像1$ sudo docker pull registry.cn-hangzhou.aliyuncs.com/timous/timousdocker:[镜像版本号] 3. 将镜像推送到Registry1$ sudo docker login --username=我命由我不由天0000-1dgpcx registry.cn-hangzhou.aliyuncs.com$ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/timous/timousdocker:[镜像版本号]$ sudo docker push registry.cn-hangzhou.aliyuncs.com/timous/timousdocker:[镜像版本号] 请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。 4. 选择合适的镜像仓库地址从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。 如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-hangzhou.aliyuncs.com 作为Registry的域名登录。 5. 示例使用”docker tag”命令重命名镜像，并将它通过专有网络地址推送至Registry。 1$ sudo docker imagesREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEregistry.aliyuncs.com/acs/agent 0.7-dfb6816 37bb9c63c8b2 7 days ago 37.89 MB$ sudo docker tag 37bb9c63c8b2 registry-vpc.cn-hangzhou.aliyuncs.com/acs/agent:0.7-dfb6816 使用 “docker push” 命令将该镜像推送至远程。 1$ sudo docker push registry-vpc.cn-hangzhou.aliyuncs.com/acs/agent:0.7-dfb6816 小结 还有save和load，分别是保存，可以使一个压缩包 Docker网络理解网络：docker0清空所有的环境 ip addr 三个网络，分别代表了三种不同的环境 1234567891011121314151617181920# docker 如何处理容器网络的访问 下面的该如何连接docker run -d -P --name tomcat01 tomcat# 查看容器的网络地址 # 会得到一个eth0@if201这个地址[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat01 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever206: eth0@if207: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0 valid_lft forever preferred_lft forever# 我们的linux服务器能不能ping容器的内部 从下面的结果能够看出我们可以ping通我们的docker容器的内部[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# ping 172.18.0.2PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.084 ms64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.073 ms64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.087 ms 原理 我们每启动一个docker，docker就会给docker容器分配一个ip，我们只要安装docker，就会有一个网卡docker0，桥接模式，使用的技术是evth-pair技术 再次测试ip addr的时候发现多了一个 我们在启动一个tomcat02 经过观察发现，都是一对一对出现的，这个技术就是evth-pair，就是虚拟设备的接口，都是成对出现的，一端连接协议，一边连接端口，正因为这个技术，evth-pair充当一个桥梁，连接各种虚拟设备 Openstac、Docker等都是使用的这个技术 tomcat01和tomcat02是不是能直接ping同呢？ 12345[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat02 ping 172.18.0.2PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.134 ms64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.090 ms# 经过测试，是可以ping通的 结论： tomcat01和tomcat02是一个公用的路由器，docker0 所有的容器在不指定网络的情况下，都是docker0的路由，docker会给我们分配一个可用的ip地址 小结 Docker使用的是linux的桥接 Docker中的所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件都是10M等），只要容器删除，对应的一对地址就没有了 思考，编写了一个服务，database&#x3D;ip….. springcloud feign …. 我们能不能通过名字来ping，我们希望可以通过名字来进行访问，如果能够做到这一点我们就可以进行高可用了。 –link123456789101112131415[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat02 ping tomcat01ping: tomcat01: Name or service not known# 我们无法直接ping tomcat ping通 我们该如何解决[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker run -d -P --name tomcat03 --link tomcat02 tomcat13c7e106aab64631cc484b2057292bf0b6f8e1ce3923ea3e7a3de1eb80c8bb99[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat03 ping tomcat02PING tomcat02 (172.18.0.3) 56(84) bytes of data.64 bytes from tomcat02 (172.18.0.3): icmp_seq=1 ttl=64 time=0.127 ms64 bytes from tomcat02 (172.18.0.3): icmp_seq=2 ttl=64 time=0.092 ms64 bytes from tomcat02 (172.18.0.3): icmp_seq=3 ttl=64 time=0.098 ms64 bytes from tomcat02 (172.18.0.3): icmp_seq=4 ttl=64 time=0.097 ms# 发现通过这个之后，我们可以解决这个网络的连通问题[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat02 ping tomcat03ping: tomcat03: Name or service not known# 经过测试，发现不能连接 探究inspect 123456789[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat03 cat /etc/hosts127.0.0.1\tlocalhost::1\tlocalhost ip6-localhost ip6-loopbackfe00::0\tip6-localnetff00::0\tip6-mcastprefixff02::1\tip6-allnodesff02::2\tip6-allrouters172.18.0.3\ttomcat02 d63422c29b92 # 我们看到直接在hosts的配置中直接配置了一个配置172.18.0.4\t13c7e106aab6 –link就是在hosts里面添加了一个tomcat02的地址的配置，此处的就能够直接看出来本质了，但是这个已经不推荐了 我们现在玩docker已经不建议使用了，我们需要更高级的网络，我们需要自定义网络 docker0不支持容器名字的访问 自定义网络容器互联 查看所有的docker网络， 网络模式 桥接模式 bridge docker上面大桥 01 02 0 这个是默认的 自己创建也使用这个模式 不配置网络 none 主机模式 host 和宿主机共享网络 container： 容器内网络连通（用得少， 局限很大） 测试1234567891011121314151617# 我们直接启动的默认有--net bridge 这个就是docker0docker run -d -P --name tomcat01 tomcatdocker run -d -P --name tomcat01 --net bridge tomcat# docker0 是默认的 域名是不能访问的 --link可以打通连接 我们可以自定义网络来进行部署项目--driver 桥接--subnet 子网--gateway 网关[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet88d5d361b0539b4461d073b040bbe14f0fe8bf21c6a2242bba42467aea983a51[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker network lsNETWORK ID NAME DRIVER SCOPE6e908f0c98ad bridge bridge local9fa20911f238 host host local88d5d361b053 mynet bridge localbfb5c7518713 none null local 我们自己的网络就配置好了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker network inspect mynet[ &#123; &quot;Name&quot;: &quot;mynet&quot;, &quot;Id&quot;: &quot;88d5d361b0539b4461d073b040bbe14f0fe8bf21c6a2242bba42467aea983a51&quot;, &quot;Created&quot;: &quot;2020-10-07T22:28:14.670138277+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;, &quot;Gateway&quot;: &quot;192.168.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123; &quot;b103628af5e9cf31882dda4daad6ddc9050a929e3cabcd5cf14450112f53dc7d&quot;: &#123; &quot;Name&quot;: &quot;tomcat02&quot;, &quot;EndpointID&quot;: &quot;0723ecfc892ff755a3cd6ac46e3b0b1e27d9388223e5c0ab61a589973985ac39&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;e0bfc05259b497257357904fc7be88f5ae26846f2afa3510172a5dee51eca601&quot;: &#123; &quot;Name&quot;: &quot;tomcat03&quot;, &quot;EndpointID&quot;: &quot;b53ad2db79b00c3eae4ab2a2d852f2b99cf0044eb121ef17bbc68ad3b27d9cc0&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123;&#125;, &quot;Labels&quot;: &#123;&#125; &#125;]# 再次测试ping连接，不使用--link，我们也可以直接使用名字ping通[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat02 ping 192.168.0.3PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.137 ms64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.100 ms^C--- 192.168.0.3 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1000msrtt min/avg/max/mdev = 0.100/0.118/0.137/0.021 ms[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat02 ping tomcat03PING tomcat03 (192.168.0.3) 56(84) bytes of data.64 bytes from tomcat03.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.066 ms64 bytes from tomcat03.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.110 ms64 bytes from tomcat03.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.124 ms# 我们自定义的网络，docker都帮我们维护了关系 推荐我们平时这么使用网络 好处 redis集群 不同的集群在不同的网络，，保证网络是安全的 mysql集群 网络连通的操作测试连通tomcat-01到mynet docker network inspect mynet &#x3D;&#x3D;连通之后就相当于把tomcat-01直接放进mynet里面，一个容器两个地址&#x3D;&#x3D; 这里能够看出02不能够连接，但是01能够连接。 假设要跨网络去操作别人就需要使用docker connect来进行连通 实战： 部署redis集群 在r-m-3没了的时候，我们的r-s-3就会顶上去 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# shell脚本直接创建6个redisfor port in $(seq 1 6); \\do \\mkdir -p /mydata/redis/node-$&#123;port&#125;/conftouch /mydata/redis/node-$&#123;port&#125;/conf/redis.confcat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1$&#123;port&#125;cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdone# 运行容器docker run -p 6371:6379 -p 16371:16379 --name redis-1 \\-v /mydata/redis/node-1/data:/data \\-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6372:6379 -p 16372:16379 --name redis-2 \\-v /mydata/redis/node-2/data:/data \\-v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6373:6379 -p 16373:16379 --name redis-3 \\-v /mydata/redis/node-3/data:/data \\-v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6374:6379 -p 16374:16379 --name redis-4 \\-v /mydata/redis/node-4/data:/data \\-v /mydata/redis/node-4/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6375:6379 -p 16375:16379 --name redis-5 \\-v /mydata/redis/node-5/data:/data \\-v /mydata/redis/node-5/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6376:6379 -p 16376:16379 --name redis-6 \\-v /mydata/redis/node-6/data:/data \\-v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf# 创建集群redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1[root@izbp169pmuqqu68q0mhkfaz /]# docker exec -it redis-1 /bin/sh/data # lsappendonly.aof nodes.conf/data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1# 进去测试/data # redis-cli -c 127.0.0.1:6379&gt; cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:1cluster_stats_messages_ping_sent:143cluster_stats_messages_pong_sent:145cluster_stats_messages_sent:288cluster_stats_messages_ping_received:140cluster_stats_messages_pong_received:143cluster_stats_messages_meet_received:5cluster_stats_messages_received:288127.0.0.1:6379&gt; cluster nodescdc72565a6fbbc78d4173303abb899159768f7a3 172.38.0.11:6379@16379 myself,master - 0 1602084842000 1 connected 0-546091f6e56ca65c2345de0bd30a921124a9c62dd860 172.38.0.13:6379@16379 master - 0 1602084842876 3 connected 10923-16383130eefbca879a19e897ee3b94d1a751727fc1f0f 172.38.0.14:6379@16379 slave 91f6e56ca65c2345de0bd30a921124a9c62dd860 0 1602084841000 4 connectedea144f07a760b383c79d0cb6684fad6b1451b391 172.38.0.15:6379@16379 slave cdc72565a6fbbc78d4173303abb899159768f7a3 0 1602084842575 5 connectedadb8733c26c78112f07d4c5f8b463290f8b90314 172.38.0.16:6379@16379 slave 2a4a261302515c19fbb92734fee8993b2d1f5c74 0 1602084842575 6 connected2a4a261302515c19fbb92734fee8993b2d1f5c74 172.38.0.12:6379@16379 master - 0 1602084841874 2 connected 5461-10922127.0.0.1:6379&gt; set a b-&gt; Redirected to slot [15495] located at 172.38.0.13:6379OK docker redis集群搭建成功 我们使用docker之后，所有的技术都会慢慢变得简单起来 SpringBoot微服务打包docker镜像 构建springboot项目 打包应用 编写dockerfie 构建镜像 发布运行 运行成功 我自己的项目已经部署到服务器上面了 Docker ComposeDocker Swarm","tags":["运维"]},{"title":"hexo的写作问题","path":"/2021/12/27/hexo的写作问题/","content":"关于hexo的使用的基本的命令问题在经历了考研之后的第一天，开始重新进行代码的学习，不知道考不考的上，好多的编程知识也忘记了很多，今天开始进行一步一步的回忆，进行慢慢的学习，也只能慢慢学习，年后可能直接要找工作了，希望能够上岸，关于考研这个事情，能考就考，我身边一个快手的朋友，在快手干了半年之后，重新把工作辞了进行考研，这是贴身的经历。希望能够上岸。 创建hexo的博客在创建的时候是有选择的，可以进行三种方式的创建，post、page和draft，存储的路径如下面的图所示。 创建命令 12hexo new [layout] &lt;title&gt; ## layout就是上面的三种方式的布局，我们在进行的时候 ## 这里不知道为啥，我的直接全部都出现在了第一个也就是默认的里面了 下面的就是我创建好的本篇博客的题目 创建完成之后可以用任何你本地的软件打开，形成自己独特的风格，这里我比较喜欢的是typora，现在可能会进行收费了，但是之前是不进行收费的，我的还是之前的版本，你也可以下载以前的版本进行使用，打开这些md的文件进行自己的编写。从下面也可以看到以前写的博客题目，具体的如下图所示。 生成并上传对应的博客生成hexo对应的文件并上传到gitee上面可以通过具体的域名进行访问。 123hexo g ## 这个是对应的生成文件的代码 generate 生成 hexo d ## 这个是上传到gitee上的命令 delivery 传送 更新gitee并访问博客在经过上面的命令之后，每次需要进行手动的更新之后，才能够进行访问。如下图，进行强制的更新。 在更新之后就可以进行访问了。输入自己的对应gitee的域名就可以进行访问了，这个所有的都是不需要进行收费的。 发表一下我现在的感受就是，冷，由于家里没有暖气，今天就写到这了，没有办法，家在乡下。","tags":["hexo"]},{"title":"axios的params和data的区别","path":"/2021/05/13/axios的params和data的区别/","content":"params和data的区别就是你后端接受参数是的状态，是requestbody还是实体类的方式，如果是实体类，那么就是params参数的形式，不然的话就是data的格式 下面的是参数params 下面的是参数data","tags":["小技巧"]},{"title":"ArrayList底层源码详解","path":"/2021/04/06/ArrayList底层源码详解/","content":"ArrayList底层源码详解ArrayList底层的数据结构List解耦的可调整大小的数组实现 数组的特点是一旦初始化，长度就不可以发生改变，这个时候又是一个可以调整的数组 数组特点： 增加元素 删除元素 修改元素 查找元素 数组结构介绍特点： 在增删的时候比较慢： 每次增加元素和删除元素，都需要修改数组的长度，拷贝以及移动元素的位置 查找和修改的时候比较快： 由于数组是存储在一块连续的地址空间，所以可以根据地址+索引的方式快速获取对应位置的元素 类图简介 ArrayList的继承关系Serializable标记性接口介绍类的序列化是由实现java.io.Serializable接口的类启动。不实现接口的类将不会使任何状态的序列或反序列化。可序列化的类的所有子类都是可序列化的。序列化接口没有方法或者是字段，仅用来标识可串行化的语义。 序列化： 将对象的数据写到文件中（写对象） 反序列化： 将文件中的对象的数据读出来（读对象） Serializable源码介绍这种接口在我们的java中还是很多的，就是标记性接口 12public interface serializable&#123;&#125; 案例： 通过序列化或者是反序列化集合 Exception in thread &quot;main&quot; java.io.NotSerializableException: com.domain.Student Cloneable标记性接口介绍 一个类实现了Cloneable接口知识Object.clone（）方法，该方法对于类的实例进行字段的复制是合法的，在不实现Cloneable接口的实例上面调用克隆方法会导致异常ClassNotSupportedException被抛出，简而言之就是克隆根据你已有的数据，创建一份完全一样的拷贝数据 Cloneable源码介绍： 12public interface Cloneable&#123;&#125; 克隆的前提条件： 克隆的对象所在的类必须实现Cloneable接口 必须重写clone方法 克隆的基本使用 已知A对象的姓名为陈留红，年龄23岁，技能为写代码（技能为一个skill），由于项目的特殊要求，需要将该对象复制到另外一个对象中，并且A和B两个对象互不影响 方式一： 创建两个对象模拟 1234567891011121314151617181920212223package com.domain;import java.util.ArrayList;public class ArrayList_clone &#123; public static void main(String[] args) &#123; //创建ArrayList集合 ArrayList&lt;String&gt; arrayList = new ArrayList(); arrayList.add(&quot;陈留红&quot;); arrayList.add(&quot;刘佳金&quot;); arrayList.add(&quot;米金龙&quot;); arrayList.add(&quot;叶剑&quot;); //调用方法进行克隆 Object clone = arrayList.clone(); System.out.println(clone == arrayList); //两个地址是不同的，对象里面的内容跟集合里面的内容是一样的 System.out.println(clone); System.out.println(arrayList); &#125;&#125; 案例：已知对象A的姓名为豹子头林冲，年龄30.由于项目的特殊要求，需要将该对象的数据复制到另一个对象B中去，并且A和B两个对象的数据不会相互影响 传统的方式： 123456789101112131415161718192021222324252627package com.domain;public class ArrayList_Clone_Case &#123; /** * 案例：已知对象A的姓名为豹子头林冲，年龄30.由于项目的特殊要求， * 需要将该对象的数据复制到另一个对象B中去， * 并且A和B两个对象的数据不会相互影响 */ public static void main(String[] args) &#123; //传统方式 //创建学生对象 Student student = new Student(&quot;豹子头林冲&quot;,30); //再创建一个新的对象 Student student1 = new Student(); student1.setUsername(student.getUsername()); student1.setAge(student.getAge()); System.out.println(student == student1); System.out.println(student); System.out.println(student1); System.out.println(&quot;此时不管修改那个的值，两者不会受到影响&quot;); student.setAge(20); System.out.println(student); System.out.println(student1); &#125;&#125; clone的方法： 浅拷贝： 123456789101112131415161718192021222324252627package com.domain;public class ArrayList_Clone_Case1 &#123; /** * 案例：已知对象A的姓名为豹子头林冲，年龄30.由于项目的特殊要求， * 需要将该对象的数据复制到另一个对象B中去， * 并且A和B两个对象的数据不会相互影响 * * 浅拷贝 */ public static void main(String[] args) throws CloneNotSupportedException &#123; //传统方式 //创建学生对象 Student student = new Student(&quot;豹子头林冲&quot;,30); //调用克隆的方法进行数据的拷贝 Object clone = student.clone(); System.out.println(clone == student); System.out.println(student); System.out.println(clone); System.out.println(&quot;修改数据&quot;); student.setAge(50); System.out.println(student); System.out.println(clone); &#125;&#125; 浅拷贝的局限性： 123456789101112131415161718192021222324252627282930313233package com.domain;public class ArrayList_Clone_Case2 &#123; /** * 案例：已知对象A的姓名为豹子头林冲，年龄30.由于项目的特殊要求， * 需要将该对象的数据复制到另一个对象B中去， * 并且A和B两个对象的数据不会相互影响 * * 浅拷贝 * * 浅拷贝的局限性 */ public static void main(String[] args) throws CloneNotSupportedException &#123; //传统方式 //创建技能对象 Skill skill = new Skill(&quot;倒拔垂杨柳&quot;); //创建学生对象 Student student = new Student(&quot;鲁智深&quot;,30 , skill); //调用克隆的方法进行数据的拷贝 Object clone = student.clone(); System.out.println(clone == student); System.out.println(student); System.out.println(clone); System.out.println(&quot;修改数据&quot;); student.setAge(50); skill.setSkillName(&quot;拳打镇关西&quot;); System.out.println(student); System.out.println(clone); &#125;&#125; 经验总结： 浅拷贝在的基本数据类型是可以完全拷贝的，但是关于引用类型的是拷贝的地址 深拷贝： 所有类型的数据都是不会受到影响的 skill类 123456789101112131415161718192021222324252627282930313233package com.domain;public class Skill implements Cloneable&#123; private String skillName; public String getSkillName() &#123; return skillName; &#125; public Skill(String skillName) &#123; this.skillName = skillName; &#125; public Skill() &#123; &#125; public void setSkillName(String skillName) &#123; this.skillName = skillName; &#125; @Override public String toString() &#123; return &quot;Skill&#123;&quot; + &quot;skillName=&#x27;&quot; + skillName + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; student类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.domain;import java.io.Serializable;public class Student implements Serializable , Cloneable&#123; //姓名 private String username; //年龄 private Integer age; private Skill skill; public Student() &#123; &#125; public Student(String username, Integer age) &#123; this.username = username; this.age = age; &#125; public Student(String username, Integer age, Skill skill) &#123; this.username = username; this.age = age; this.skill = skill; &#125; public Skill getSkill() &#123; return skill; &#125; public void setSkill(Skill skill) &#123; this.skill = skill; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; /** * 分析: 创建StringBuild对象 * 先追加一个当前类的类名，以及大括号、成员变量的名字以及=‘ * 再追加成员变量对应的值就是数据 * 再追加’， 后面在跟一个成员变量的名字以及= * 再追加成员变量的值和大括号 * * @return */ @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(&quot;Student[username=&#x27;&quot;); sb.append(this.username); sb.append(&quot;&#x27;, age=&quot;); sb.append(this.age); sb.append(&quot;&#x27;, skill=&quot;); sb.append(skill.getSkillName()); sb.append(&quot;]&quot;); return sb.toString(); &#125; //字符串拼接的时候回有很多的垃圾，我们可以优化 所以有字符串缓冲区等/* @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;*/ /** * 方法的权限修饰符需要修改 public * 方法的返回值是要克隆的对象，可以改为当前类的类名 * @return * @throws CloneNotSupportedException */ @Override public Object clone() throws CloneNotSupportedException &#123; //深拷贝不能简单的调用父类的方法 //先克隆出来一个学生对象 Student stu = (Student)super.clone(); //调用skill类中的克隆方法，克隆出来一个skill对象 Skill skill = (Skill) this.skill.clone(); //技能克隆出来的技能赋值 stu.setSkill(skill); return stu; //return super.clone(); &#125;&#125; 测试代码： 12345678910111213141516171819202122232425262728293031package com.domain;public class ArrayList_Clone_Case4 &#123; /** * 案例：已知对象A的姓名为豹子头林冲，年龄30.由于项目的特殊要求， * 需要将该对象的数据复制到另一个对象B中去， * 并且A和B两个对象的数据不会相互影响 * * 深拷贝 */ public static void main(String[] args) throws CloneNotSupportedException &#123; //传统方式 //创建技能对象 Skill skill = new Skill(&quot;倒拔垂杨柳&quot;); //创建学生对象 Student student = new Student(&quot;鲁智深&quot;,30 , skill); //调用克隆的方法进行数据的拷贝 Object clone = student.clone(); System.out.println(clone == student); System.out.println(student); System.out.println(clone); System.out.println(&quot;修改数据&quot;); student.setAge(50); skill.setSkillName(&quot;拳打镇关西&quot;); System.out.println(student); System.out.println(clone); &#125;&#125; RandomAccess标记接口介绍标记接口由List实现使用，以表明他们支持快速（通常为恒定时间）随机访问。此接口主要目的是允许通用算法更改其行为，以便应用于随机访问或顺序访问列表时提供良好的性能。用于操作随机访问列表的最佳算法（例如ArrayList）可以在应用于顺序访问列表时产生二次行为（如LinkedList）。鼓励通用列表算法在应用如果将其应用于顺序访问列表之前提供较差性能的算法时，检查给定列表是否为instanceof，并在必要的时候更改其行为以保证可接受的性能。人们认识到，随机访问和顺序访问之间的区别通常是模糊的。例如，一些List实现提供渐进的线性访问时间，如果它们在实践中获得巨大但是恒定的访问时间。这样一个List实现应该通常实现这个接口。根据经验，List实现应实现此接口，如果对于类的典型实例，此循环： 12for(int i = 0 , n=list.size() ; i++) list.get(i); //随机访问 比这个循环运行更快 12for( Iterator i = list.iterator() ; i.hasNext();) i.next(); //顺序访问 源码： 12public interface RandomAccess &#123;&#125; 案例演示1 12345678910111213141516171819202122232425262728293031323334353637package com.domain;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class Arraylist_RandomAccess &#123; public static void main(String[] args) &#123; //创建arraylist集合 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加十万条数据 for (int i = 0; i &lt; 100000; i++) &#123; list.add(i+&quot;a&quot;); &#125; //测试随机访问 long start = System.currentTimeMillis(); for (int i = 0; i &lt; list.size(); i++) &#123; // 取出集合的每一个元素 list.get(i); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;随机访问用时：&quot;+(end-start)); //测试顺序访问 long start1 = System.currentTimeMillis(); Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext())&#123; it.next(); &#125; long end1 = System.currentTimeMillis(); System.out.println(&quot;顺讯访问用时：&quot;+(end1-start1)); &#125;&#125; 通过测试我们知道，随机访问比顺序访问用的时间要短，由于ArrayList实现了RandomAccess这个接口，所以，他的随机访问的效率是比较高的 我们再看LinkedList 1234567891011121314151617181920212223242526272829303132333435package com.domain;import java.util.Iterator;import java.util.LinkedList;import java.util.List;public class Arraylist_RandomAccess_LinkedList &#123; public static void main(String[] args) &#123; //创建linkedlist集合 List&lt;String&gt; list = new LinkedList&lt;&gt;(); //添加十万条数据 for (int i = 0; i &lt; 100000; i++) &#123; list.add(i+&quot;a&quot;); &#125; //测试随机访问 long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; list.get(i); &#125; long endTime = System.currentTimeMillis(); System.out.println(&quot;随机访问时间：&quot;+(endTime-startTime)); //测试顺序访问. long startTime1 = System.currentTimeMillis(); Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext())&#123; it.next(); &#125; long endTime1 = System.currentTimeMillis(); System.out.println(&quot;顺序访问时间：&quot;+(endTime1-startTime1)); &#125;&#125; 从结果可以看出来，我们的顺序访问的时间比随机访问的时间短，这个时候我们的LinkedList是没有实现RandomAccess接口的 在企业中进行循环输出的时候判断查询返回的结果是否实现了RandomAccess这个接口，如果实现了这个接口，就推荐使用随机遍历的方式迭代结合，否则就推荐使用顺序的方式迭代集合 如何判断是够实现了RandomAccess这个接口，通过instanceof来判断是否实现这个接口 12345678/*这个是对海量数据的优化*/if(list instanceof RandomAccess)&#123; //推荐使用随机访问&#125;else&#123; //使用顺序访问&#125; AbstractList抽象类 此类提供的骨干实现的List接口以最小化来实现该接口由一个“随机访问”数据存储备份所需的工作（如阵列）。 对于顺序存取的数据（如链接列表）， AbstractSequentialList应优先使用此类。 要实现一个不可修改的列表，程序员只需要扩展这个类并提供get(int)和size()方法的实现。 要实现可修改的列表，程序员必须另外覆盖set(int, E)方法（否则会抛出一个UnsupportedOperationException ）。如果列表是可变大小，则程序员必须另外覆盖add(int, E)和remove(int)方法。 123public E set(int index, E element) &#123; throw new UnsupportedOperationException();&#125; 通过这些源码的解读，我们可以看到，要求他的子类必须实现这些方法，如果不实现就会报错，可以看出，我们必须实现这些方法。 ArrayList的源码分析构造方法 Constructor Constructor描述 ArrayList( ) 构造一个初始容量为10的空列表 ArrayList(int initialCapacity) 构造一个有指定容量的列表 ArrayList(Collection&lt;? extends E&gt; c) 构造一个包含指定集合的元素的列表，按照他们由集合的迭代器返回的顺序 案例演示空参构造1234567891011121314public class ArrayList&lt;E&gt;&#123; //默认的空容量的数组 里面啥都没有，也就是说长度是为0的 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; //集合真正存储数据的容器 transient Object[] elementData; //空参构造 public ArrayList() &#123; //赋值 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125;&#125; 有参的构造1234567891011121314151617181920//有参的构造public class ArrayList&lt;E&gt;&#123; //创建一个空的Object数组， 容量为0 private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //根据我们传递进来的值来进行判断 public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; //如果传过来的变量是大于0的话，就创建一个Object数组，容量为initialCapacity this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; //如果传递进来的参数为0 则 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; //如果不是0或者不大于0的话就会抛出异常 throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125; &#125;&#125; ArrayList(Collection&lt;? extends E&gt; c)这个构造123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//ArrayList(Collection&lt;? extends E&gt; c)public class ArrayList&lt;E&gt;&#123; private int size; private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; public ArrayList(Collection&lt;? extends E&gt; c) &#123; // 将构造方法中的参数转成数组 elementData = c.toArray(); //将数组的长度给size 看是不是等于0 if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) //再次进行判断 if (elementData.getClass() != Object[].class) //数组的创建和拷贝 elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. //如果是0 就把空数组的地址给集合存元素的数组 this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; //将集合转为数组的方法 public Object[] toArray() &#123; //调用数组工具类的方法 return Arrays.copyOf(elementData, size); &#125;&#125;class Arrays&#123; public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; //再次调用一个方法，返回一个数组 return (T[]) copyOf(original, newLength, original.getClass()); &#125; public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(&quot;unchecked&quot;) //三元运算符的运算 不管运算符的结果为啥 都会创建一个新的数组 新的数组的长度都和集合的size一样 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); //数组的拷贝 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); //返回新的数组 return copy; &#125;&#125; 添加方法 方法名 描述 public boolean add(E e) 将指定的元素追加到此列表的末尾。 public void add(int index, E element) 在此列表中的指定位置插入指定的元素。 public boolean addAll(Collection&lt;? extends E&gt; c) 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) 将指定集合中的所有元素插入到此列表中，从指定的位置开始。 public boolean add(E e)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//添加方法public class ArrayList&lt;E&gt;&#123; //默认的容量 private static final int DEFAULT_CAPACITY = 10; //默认容量为空的数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; private int size; private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit * 也就是说，创建数组的时候也会浪费一些空间，所以不是 2 的 31次方，需要减一个 8 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //1.0 先执行 public boolean add(E e) &#123; // 限制性size+1 ensureCapacityInternal(size + 1); // Increments modCount!! //0的时候是e ，size变成1 后面在遍历的时候比较容易遍历 elementData[size++] = e; //给元素赋值 return true; &#125; //执行ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); // elementData是空的 minCapcity = 1 这个是最小容量 private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; //1.0 传入一个 minCapacity = 1 private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; //判断elementData 是不是空的元素集 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //如果容量不超过10 就把10作为容量给返回 return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //如果minCapacity 超过10就返回minCapacity 这里返回的是DEFAULT_CAPACITY return minCapacity; &#125; //minCapacity 10 modCount 0 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; //modCount 1 // overflow-conscious code //判断minCapacity 容量和元素长度的大小 如果minCapacity 比较大 执行 grow(minCapacity); if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; //minCapacity 10 private void grow(int minCapacity) &#123; // overflow-conscious code //定义oldCapacity 为元素的长度，这里还是0 int oldCapacity = elementData.length; // &gt;&gt;右移 &lt;&lt; 左移 就相当于除以2的几次方 左移几位就相当于乘以2的几次方 //扩容的核心算法： 原容量的1.5倍 //newCapacity 新容量是就容量的1.5倍 ， 也就是0 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //判断新容量和 minCapacity 10 之间的关系 if (newCapacity - minCapacity &lt; 0) // newCapacity新的容量为 10 newCapacity = minCapacity; //判断是不是超过了最大的容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //如果是超过最大的容量， 就会采用更大的地址空间 newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: //调用copy数组复制 elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; //传递进来 minCapacity 超过了容量 if (minCapacity &lt; 0) // overflow //如果是直接小于 0 超过的比较多 他这个由于前面是 -8 所以添加的比较少的话不会是负数 不然的话就直接报错 throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? //后面的这段说明也就是仅仅限制在int的最大的数据类型 不会再进行扩容了 Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125;&#125; public void add(int index, E element)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//添加方法// 在指定的位置进行插入元素public void add(int index, E element)&#123; //默认的容量 private static final int DEFAULT_CAPACITY = 10; //默认容量为空的数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; private int size; private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; public void add(int index, E element) &#123; //校验索引 rangeCheckForAdd(index); //和之前的一样 ensureCapacityInternal(size + 1); // Increments modCount!! //开始拷贝元素 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 把添加的元素给我们的element elementData[index] = element; size++; &#125; //只有容量不够的时候才会调用核心扩容的方法 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; //判断所以是不是在集合范围之内 0 &lt; index &lt; size //如果不在这个范围之内会抛出一个数组越界异常 IndexOutOfBoundsException private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125;&#125; public boolean addAll(Collection&lt;? extends E&gt; c)123456789101112131415161718192021//添加方法// 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。public class ArrayList&lt;E&gt;&#123; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; //把 c 转化为数组 Object[] a = c.toArray(); //numNew 为数组的长度 int numNew = a.length; //依然调用我们的扩容的方法 ensureCapacityInternal(size + numNew); // Increments modCount //进行拷贝 System.arraycopy(a, 0, elementData, size, numNew); //重新计算size的值 ， 就是numNew的长度 size += numNew; //返回 值 return numNew != 0; &#125;&#125;//底层还是使用了System 的拷贝方法 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 public boolean addAll(int index, Collection&lt;? extends E&gt; c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ArrayList&lt;E&gt;&#123; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //校验索引是不是超过范围 rangeCheckForAdd(index); //将参数集合转换为数组 Object[] a = c.toArray(); //记录数据源的长度 int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount //numMoved 代表要移动元素的个数 数据目的（集合）的长度-调用addAll的第一个参数，就是那个索引 int numMoved = size - index; // 判断需要移动的个数是不是大于0 if (numMoved &gt; 0) //使用System中的方法arraycopy System.arraycopy(elementData, index, elementData, index + numNew, numMoved); //这个是拷贝数据源中的所有数据 System.arraycopy(a, 0, elementData, index, numNew); //更新size的值 size += numNew; //返回成功 return numNew != 0; &#125; //校验索引是不是超过范围的方法 private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; //总的来讲下面的这三个方法就是为了进行扩容 private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125;&#125; 修改方法public E set(int index, E element)123456789101112131415161718192021public class ArrayList&lt;E&gt;&#123; public E set(int index, E element) &#123; //检查索引 判断是不是越界 rangeCheck(index); //根据索引取出元素 E oldValue = elementData(index); //修改之后的元素存入到我们的elementData数组中 elementData[index] = element; //返回被替换的元素 return oldValue; &#125; private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; E elementData(int index) &#123; return (E) elementData[index]; &#125;&#125; 获取方法 public E get(int index)1234567891011121314151617public class ArrayList&lt;E&gt;&#123; public E get(int index) &#123; //判断索引是不是越界了 rangeCheck(index); //返回集合中索引对应的元素的值 return elementData(index); &#125; private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; E elementData(int index) &#123; return (E) elementData[index]; &#125;&#125; 转换方法toString（）将集合中的所有的元素转换为字符串，它是通过他的亲爷爷来进行调用的。 123456789101112131415161718192021222324252627public abstract class AbstractCollection&lt;E&gt;&#123; public String toString() &#123; //顺序遍历的迭代器 Iterator&lt;E&gt; it = iterator(); // 判断迭代器是不是有元素，如果没有 it.hasNext()是一个boolean类型的 if (! it.hasNext()) return &quot;[]&quot;; //创建一个StringBuilder（字符串的缓冲区） StringBuilder sb = new StringBuilder(); //追加了[ sb.append(&#x27;[&#x27;); // 无限循环 for (;;) &#123; //调用迭代器的方法取出元素且将光标向下移动 E e = it.next(); //三元判断 sb.append(e == this ? &quot;(this Collection)&quot; : e); if (! it.hasNext()) //没有元素 ，在最后面添加]，然后调用toString()把缓冲区的字符转换为字符串 return sb.append(&#x27;]&#x27;).toString(); //有元素就直接追加 sb.append(&#x27;,&#x27;).append(&#x27; &#x27;); &#125; &#125;&#125; 迭代器public interface Iterator 普通迭代器 源码同上（在讲toString方法的时候已经讲过基本操作，通过下面的两个案例分析源码） 案例一： 已知集合： List list &#x3D; new ArrayList&lt;&gt;();里面有三个元素：“hello”，“java”，“php”，使用迭代器遍历获取集合的每一个元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//迭代器public class ArrayList&lt;E&gt;&#123; //获取迭代器的方法 public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; //判断光标的值是不是size 也就是说是不是后面没有元素了 public boolean hasNext() &#123; return cursor != size; &#125; //一个实现了Iterator接口的内部类 不同迭代器的底层的源码是不一样的 private class Itr implements Iterator&lt;E&gt; &#123; //光标 默认值是 0 int cursor; // index of next element to return //记录 -1 int lastRet = -1; // index of last element returned; -1 if no such //将集合实际修改次数赋值给预期修改次数 int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; // @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; // 校验预期修改集合次数和实际修改集合次数是不是一致 checkForComodification(); //将光标赋值给 i int i = cursor; //判断光标的值是不是大于size 判断是不是没有元素了 if (i &gt;= size) throw new NoSuchElementException(); // 把集合存储数据的数组的地址赋值给该方法的局部变量 elementData Object[] elementData = ArrayList.this.elementData; //判断i是不是elementData的长度，如果条件满足，就会产生并发修改异常 if (i &gt;= elementData.length) throw new ConcurrentModificationException(); //光标向下移动 cursor = i + 1; //返回刚才存储的元素 return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; // final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;&#125; 案例二：List list &#x3D; new ArrayList&lt;&gt;();里面有三个元素：“hello”，“java”，“php”，使用迭代器遍历看看有没有php这个元素，如果有，就使用集合对象删除该元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148//迭代器22public class ArrayList&lt;E&gt;&#123; //查看add方法的目的就是为了查看记录集合修改次数的数据 public boolean add(E e) &#123; //这些之前都看过了 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; //真正删除元素的方法 private void fastRemove(int index) &#123; //集合的实际修改的次数会自增 //集合实际修改的次数为4 但是预期的修改次数为 3 modCount++; //计算集合要移动元素的个数 int numMoved = size - index - 1; if (numMoved &gt; 0) //移动元素的核心代码 System.arraycopy(elementData, index+1, elementData, index, numMoved); //让删除的元素位置为null，就是尽快让垃圾回收机制回收，避免占用内存 elementData[--size] = null; // clear to let GC do its work &#125; //集合删除元素的方法 public boolean remove(Object o) &#123; //判断要删除的元素是不是为null if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; //走else &#125; else &#123; //遍历集合 for (int index = 0; index &lt; size; index++) //要删除的元素和集合的每一个元素进行比较 如果是相等 if (o.equals(elementData[index])) &#123; //调用方法进行删除 fastRemove(index); return true; &#125; &#125; return false; &#125; public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such //将集合的实际修改次数赋值给预期修改次数 //获取迭代器的时候，expectedModCount也是3 int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; //判断集合的预期修改次数和实际的修改次数是不是一样 ， 如果一样的话就不会抛出异常 //删除之后，以为实际修改的次数和我们的预期修改次数是不一样的 if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;&#125;结论： 1. 集合每次调用add方法的时候，实际修改变量的次数都会自增12. 在获取迭代器的时候集合只会执行一次，将实际修改集合的次数赋值给预期的修改次数3. 集合在删除元素的时候也会针对实际修改次数的变量进行自增的操作，当我们再次调用next的时候就会产生并发的修改异常 案例三：已知集合List list &#x3D; new ArrayList&lt;&gt;();里面有三个元素： “hello”，“php”，“javase”，使用迭代器遍历集合看看有没有php这个元素，如果有，就使用集合对象删除该元素 123结论： 当要删除的元素在倒数第二个位置的时候 ， 不会产生并发修改异常原因： 因为在调用hasNext方法的时候 ， 光标的值和集合的长度一样 ， 那么就会返回false 因此就不会再去调用next方法获取集合的元素，既然不会调用next ， 也就意味着底层不会产生并发修改异常的问题 相当与在size的时候停止了，不会去比较预期修改次数和实际的修改次数 当要删除的元素在集合的倒数第二个位置的时候不会产生并发的修改异常，原因是因为在调用hasNext方法的时候，光标的值和集合的长度是一样的，就返回false，因此就不会调用下面的方法了，自然就不会产生并发修改异常了（是一个巧合）。 default void remove（） 心情随记，毕业设计没搞，啥都没做，好慌啊！！！","tags":["源码","面试题"]},{"title":"equals和异常","path":"/2021/03/26/equals和异常/","content":"equals和异常equals详解两个对象的值相等，但却可能有不同的hashcode，这句话对不对？两个对象x , y如果满足x.equals（y）&#x3D;&#x3D; true , 它们的哈希码（hashcode）应当相同。Java对于equals方法和hashcode是这样规定的： 如果两个对象相同（equals方法返回true），那么它们的hashcode值一定相同。 如果两个对象的hashcode值相同，它们并不一定相同。当然，你未必按照要求去做，但是如果你违背了上述的原则就会发现使用容器的时候，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希频繁的冲突会造成存取性能几句下降） 异常处理Java异常的分类按照异常处理的时机分类的话有 编译时异常（强制性异常）也叫CheckedException 运行时异常（非强制异常）也叫RunTimeException 异常处理 当前方法知道如何处理该异常，则用 try…catch 块来处理该异常。 当前方法不知道如何处理，则在定义该方法是声明抛出该异常。 测试12345678910public int getNum()&#123; try&#123; int a = 1/0; return 1; &#125;catch(Exception e)&#123; return 2; &#125;finally&#123; return 3; &#125;&#125; 测试 结果为3，代码在遇到第三行的时候遇到异常，会到catch语句中，执行第六行，但是异常机制有这么一个原则，在catch中遇到return的或者异常能够使该函数终止的话，finally就必须先执行完，所以第六行不会返回值，返回的是第八行的值。真正返回的值是3。 常见的RuntimeException java.lang.NullPointerException空指针异常；出现原因是：调用了未经初始化的对象或者是不存在的对象 java.lang.ClassNotFoundException指定的类找不到；出现原因是：类的名称和路径加载错误，通常都是程序试图通过字符串来加载某个类时所发生的异常。 java.lang.NumberFormatException字符串转化为数字异常；出现原因： 字符型数据中包含非数字型字符。 java.langIndexOutOfBoundsException数组角标越界异常，常见于操作数组对象是发生。 java.lang.IllegalArgumentException方法传递参数错误。 java.lang.ClassCastException数据类型转换异常。 java.lang.NoClassDefFoundException未找到类定义错误。 SQLException异常，常见于操作数据库是的SQL语句错误。 java.lang.InstantiationException实例化异常 java.lang.NoSuchMerthodException方法不存在异常。","tags":["面试题"]}]