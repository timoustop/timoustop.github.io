[{"title":"Hexo博客搭建","path":"/2026/01/11/Hexo博客搭建/","content":"Hexo博客搭建下载nodejs并安装地址 :https://nodejs.org/zh-cn/download 一路下一步进行安装 全局安装hexo1npm install -g hexo-cli 初始化blog1hexo init blog 安装主题通过github等相关途径找到适合自己的主题进行安装，这里以hexo-theme-stellar-1.6.1为样例进行安装 1.从github下载相关的压缩包放至theme下 2.找到配置文件配置如下(_config.yaml) 1theme: hexo-theme-stellar-1.6.1 配置完成后即可得到一份博客啦 写完之后部署1npm install hexo-deployer-git --save","tags":["博客"]},{"title":"java面试题进阶","path":"/2022/02/27/java面试题进阶/","content":"java面试题进阶1.HashMap底层实现原理详解123456public static void main(String[] args) HashMap&lt;String , String&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(&quot;timous&quot; , &quot;2&quot;); String result = hashMap.put(&quot;timous&quot; , &quot;3&quot;); System.out.println(result);&#125; 此处返回的值是2 ， 不是3，返回的是覆盖的值 hashmap在1.7中是使用的数组+链表实现的 当前put的放在那里？ 是根据key对应的来确定需要放置的位置的 通过 key.hashCode来获取hashcode，如下图所示是获取到的hashCode 不会使用这个作为数组的下标 ， 根据一定的格式（区取余 ， 根据数组的长度进行取余 ， 这里拿长度为8的数组来举例子），转化为对应的0 - 7 的对应的值 ， hashcode是没有很大的规律的 1.7考虑的是尾插法的话需要进行遍历完所有的元素之后才能找到对应的位置，头插法则不需要。一开始初始化的时候并没有去定义大小，而是在进行put的时候才进行初始化，初始化是通过对应大于等于2的幂的次数，通过左移和右移来确定对应的数组的大小，最后通过与操作来确定应该放在数组的那个位置上面。 2.为什么HashMap要用数组+链表实现？key不一样的时候hashCode可能也不一样，但是最后结果的范围是对应数组的大小，如果数据多的话，可能会出现hash冲突，在这里不是指hash值出现冲突，这里指的是对应的位置出现了冲突，解决这个方法就是对应的位置放置一个链表。","tags":["面试题"]},{"title":"Java面试题","path":"/2022/02/24/Java面试题/","content":"Java基础面试题1.什么是面向对象？谈谈你对面向对象的理解洗衣服 面向过程： 打开洗衣机–》 放衣服—》 放洗衣粉—》 清洗—》 烘干 面向对象 人： 打开洗衣机 放衣服 放洗衣粉 洗衣机： 清洗 烘干 面向过程比较直接 ， 面向对象更容易进行复用 面向对象的三大特性： 继承 ， 封装 ， 多态 封装明确标识出外部函数能够使用的所有成员函数和数据项 javaBean属性私有 orm框架 ，不需要关心内部如何实现 ， 只需要调用方法即可 继承继承基类的方法 ， 并作出自己的扩展和改变 ， 共性全部定义在父类·· 多态基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。 继承、方法重写、父类引用指向子类对象 12父类类型 变量名 = new 子类对象变量名.方法名（）； //调用的是子类的方法名 无法调用子类的特有功能 2.JDK、JRE、JVM三者的区别和练习JDK ： Java Development Kit java开发工具 JRE : Java Runtime Environment java运行时环境 JVM ： java virtual machine java虚拟机 3.&#x3D;&#x3D;和equals&#x3D;&#x3D;对比的是栈中的值 ， 基本数据类型是变量值 ， 引用类型是堆中内存对象的地址 equals： object中默认也是&#x3D;&#x3D;比较 ， 通常会进行重写 String中重新写了equals这个方法，这个时候二者是相等的 4.简述final的作用最终的 修饰类： 表示类不可以被继承 修饰方法： 表示方法不可能被子类覆盖，但是可以重载 修饰变量： 表示变量一旦被赋值就不可以更改它的值 （1）修饰成员变量 如果修饰的是成员变量，可以在非静态初始化块声明该变量或者构造器中执行初始值 如果修饰的是类变量 ， 只能在静态初始化块中指定初始值或者声明类变量时指定初始值 （2）修饰局部变量 系统不会为局部变量进行初始化，局部变量必须有程序员初始化显示。一次使用final修饰局部变量的时候，即可以在定义时指定默认值，也可以不指定默认值，在后面的代码中对final变量赋初值一次 （3）修饰基本数据类型和引用数据类型 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能进行更改 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象，但是引用的值是可变的 5.为什么局部内部类和匿名内部类只能访问final变量？编译之后会生成两个class文件，Test.class Test1.class 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; &#125;// 局部final变量a , b public void test(final int b)&#123; final int a = 10; //匿名内部类 new Thread()&#123; public void run()&#123; System.out.println(a); System.out.println(b); &#125; &#125;.start(); &#125;&#125;class OutClass&#123; private int age = 12; public void outPrint(final int x)&#123; class InClass&#123; public void InPrint()&#123; system.out.println(x); System.out.println(age); &#125; &#125; new InClass().InPrint(); &#125;&#125; 首先需要知道的一点是： 内部类和外部类是出于同一个级别的，内部类不会因为定义在方法中就会随着方法执行的完毕就被销毁。 这就会产生问题： 当外部类的方法结束时，局部的变量就会被销毁，但是内部类对象可能还存在（只有没有人在引用它的时候才会死亡）。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量付之一份作为内部类的成员变量，这样局部变量死亡之后，内部类仍然可以进行访问，实际访问的是局部变量重新拷贝的。这样就好像延长了局部变量的生命周期。 将局部变量复制为内部类的成员变量时必须保证 这两个变量时一样的，也就是如果我们在内部类修改了成员变量，方法中的局部变量也得随着改变，怎么解决问题呢？ 就将局部变量设置为final，对它初始化后，就不需要你再去修改这个变量，就保证了内部类的成员变量和方法的局部变量的一致性。这实际上也是种妥协。使得局部变量与内部类建立的拷贝保持一致。 顺便说一下关于考研成绩的事，自己大概率是没有考上的希望了，我也很希望能够考上，但是成绩出来之后，我觉得是考不上了，所以开始准备参加工作，搞面试题啥的，希望自己能够找到一家好的公司，能够不让父母担心自己，希望一切都慢慢变的好起来。 2月25号更新的内容 6.String 、 StringBuffer、StringBuilder区别以及使用场景String是final修饰的，不可变，每次操作都会产生新的String对象 StringBuffer和StringBuilder都是在原来的对象上进行操作 StringBuffer是线程安全的，StringBuilder不是线程安全的 StringBuffer方法都是sychronized修饰的 性能： StringBuilder &gt; StringBuffer &gt; String 场景： 经常需要改变字符内容时使用后面两个 优先使用StringBuilder ， 多线程使用共享变量的时候使用的是StringBuffer 7.重载和重写的区别重载： 发生在同一个类中，方法名相同，参数类型不同、个数不同、顺序不同，方法的返回值和修饰符可以不同，发生在编译的时候。 重写： 发生在父子类之中，方法名、参数列表必须相同，返回值小于父类，抛出的异常小于父类，访问修饰符大于父类；如果父类方法访问修饰符是private的话，子类就不能重写该方法。 123public int add(int a , String b);public String add(int a , String b);//编译报错 8.接口和抽象类的区别 抽象类中可以存在普通成员函数，而接口中只能存在public abstract方法 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final 类型的。 抽象类只能继承一个，接口可以实现多个。 接口的设计目的，是对类的行为进行约束（更准确的说是一种“有”的约束，因为接口不能规定类不可以有什么行为），也是提供一种机制，可以强制要求不同的类有相同的行为。它只是约束了行为的有无，但不对如何实现进行限制。 而抽象类的设计，是代码的复用。当不同的类具有某些相同行为（记为集合A），且其中一部分的行为实现方式一致时（A的非真子集 ， 记为B），可以让这些类都派生于一个抽象类，在这个抽象类中实现了B，避免让所有的子类来实现B，这样就达到了代码的复用。而A减B的部分，留给各个子类自己实现。正是因为A减B在这里没有实现，所以抽象类不允许被实例化出来（否则当调用A减B时 ，无法执行）。 抽象类是对类本质的抽象，表达的是is a 的关系，比如B is a car。 抽象类包含并实现了子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。 而接口是对行为的抽象，表达的是 like a 的关系。接口的核心是定义行为，即实现类可以做什么，至于实现类主题是谁，是如何实现的，接口并不关心。 使用场景： 当你关注一个事物的本质的时候，用抽象类，当你关注一个操作的时候，使用接口。 抽象了的功能要远超过接口，但是定义抽象类的代价高，因为高级语言来说（从实际设计上说也是）每个类只能继承一个类，在这个类中，你必须继承或编写其子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中实现多个接口，这在设计阶段会降低难度。 9.List和Set的区别 list有序，按照对象进入的顺序保存对象，可以重复，允许有多个NULL元素，可以使用iterator取出所有的元素，在逐一进行遍历，还可以进行get（index）获取制定下标的元素 set无序，不可重复，且最多有一个NULL元素，取元素的时候只能使用iterator接口取得所有的元素，再逐一遍历各个元素 10.hashCode与equals equals提供个程序员对比两个对象是不是相同的，定义对比对象的规则，如果不进行重写，采用的是Object的对比，跟&#x3D;&#x3D;是一样的，一般都是会进行重写equals的。 hashCode介绍hashCode（）的作用就是获取哈希码，也称为散列码，它实际上是一个int类型的整数，这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode（）定义在JDK中的Object.java中，Java中的任何类都包含有hashCode()函数。散列表存储的是键值对（key-value），它的特点是：能根据键快速的索引出对应的值。这其中就利用到了散列码！（）可以快速找到所需要的对象 为什么要有hashCode以HashSet如何检查重复为例子来说明为什么要有hashCode： ​\t对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有值，如果没有，HashSet会假设对象没有出现，但是如果发现有值，这时会调用equals（）方法来检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他的位置上，这样就大大减少了equals的次数，就相应大大提高了执行的速度。 如果两个对象是相等的，则hashcode也是相同的 两个对象相等，对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，他们不一定是相等的 因此，equals方法被覆盖过，则hashcode也必须被覆盖 hashCode（）的默认行为是对堆上的对象产生独特值，如果没有重写hashCode（），则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 11.ArrayList和LinkedList的区别ArrayList： 基于动态数组，连续内存存储，适合下标访问（随机访问），扩容机制： 因数组长度固定，超出长度存数据时需要新建数组，然后将老的数组的数据拷贝到新的数组，如果不是尾部插入数据还会涉及到元素的移动（往后复制一份，插入新的元素），使用尾插法并制指定初始容量可以极大的提升性能，甚至超过LinkedList（需要创建大量的node对象） LinkedList： 基于链表，可以存储在分散的内存之中，适合做数据插入以及删除操作，不适合查询，需要逐一遍历，遍历LInkedList需要采用iterator，不能使用for循环进行遍历，因为每次for循环体内通过get（）获取某一元素的时候都需要对list进行遍历，性能消耗极大。 另外不要试图使用indexOf等来返回元素索引，并利用其遍历，使用idnexOf对list进行遍历，当结果为空时，会遍历整个列表。 12.谈谈你对Java的注解的理解注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包，类，接口，字段，方法，参数，局部变量等进行注解。 生成文档，通过代码里标识的元数据生成javadoc文档 编译检查，通过代码里的元数据让编译器在编译期间进行检查 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例 13.mysql如何去重1234567891011121314151617181920create table student (\tid int(4) primary key, name varchar(10) );insert into student(id , name) value(1 , &#x27;tus&#x27;);insert into student(id , name) value(2 , &#x27;tus3&#x27;);insert into student(id , name) value(3 , &#x27;tus3&#x27;);insert into student(id , name) value(4 , &#x27;tus3&#x27;);insert into student(id , name) value(5 , &#x27;tus1&#x27;);insert into student(id , name) value(6 , &#x27;tus1&#x27;);insert into student(id , name) value(7 , &#x27;tus2&#x27;);insert into student(id , name) value(8 , &#x27;tus2&#x27;);查询语句select name from student;明显可以看出来，是有重复的字段的，如果没有重复的字段，需要添加distinctselect distinct name from student; 查询的结果 去重之后的查询结果","tags":["面试"]},{"title":"HashMap源码探究","path":"/2022/01/14/HashMap源码探究/","content":"HashMap核心理论： Hash也称为散列、哈希，对应的英文都是Hash。&#x3D;&#x3D;基本原理就是把任意长度的输入，通过Hash算法，变成固定长度的输出&#x3D;&#x3D;，这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制就是哈希值（可能会有冲突) Hash的特点 从hash值不可以反向推到出原始的数据 输入数据的微小变化会得到完全不用的hash值，相同的数据会得到相同的值 哈希算法的执行效率高效，长的文本也能快速的计算出哈希值 hash算法的冲突概率要小 由于hash的原理是将输入空间的值映射成hash空间内，而hash值的空间远小于输入的空间。 根据抽屉原理，一定存在不同的输入映射到相同的输出的情况。 抽屉原理：桌子上有10个苹果，放到9个抽屉里面，无论是怎样放的，我们会发现至少有一个抽屉里面放了不少于两个苹果。这一现象我们称之为“抽屉原理”。 Map继承体系图 内部类： 123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; //存储hash值 与 hashcode还是有区别的 this.key = key; // 就是put的key值 this.value = value;// 就是put的value值 this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; &#x3D;&#x3D;当链表的长度达到9并且表中的数据超过64个的时候，链表就会进行树化&#x3D;&#x3D; map的put的过程 map.put(“timous”,”chenliuhong”); 获取timous字符串的hash值 经过hash值&#x3D;&#x3D;扰动函数&#x3D;&#x3D;，使hash值更加散列 构造出Node对象 Hash—–》1122 Key—》timous value —-&gt; chenliuhong next—-&gt;null 路由算法，找出node应该存放的数组的位置 路由寻址公式 ： (table.length-1)&amp;node.hash (16-1) &amp; 1122 &#x3D;》 B0000 0000 1111 &amp; B0100 0110 0010 &#x3D;》B0010 &#x3D;》2 这就是下标 表的长度一定是2的多少次方 16 32 64 等 Hash碰撞在上面的时候再插入一个值可能也会得到2这个下标 ， 所以出现了两个值，在同一个位置，这个时候就会发生hash碰撞 ， next就会指向下一个值，如果一直碰撞的话就会使我们的链表很长，在get的时候，就会遍历一个链表，比较长，本来时间复杂度是O(1)，但是退化之后就变成O(n)了，为了解决链化问题，就会出现了树化 手撕源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783package java.util;import java.io.IOException;import java.io.InvalidObjectException;import java.io.Serializable;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.function.BiConsumer;import java.util.function.BiFunction;import java.util.function.Consumer;import java.util.function.Function;import sun.misc.SharedSecrets;public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; private static final long serialVersionUID = 362498820763181265L; // static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; static final float DEFAULT_LOAD_FACTOR = 0.75f; static final int TREEIFY_THRESHOLD = 8; static final int UNTREEIFY_THRESHOLD = 6; static final int MIN_TREEIFY_CAPACITY = 64; static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; static Class&lt;?&gt; comparableClassFor(Object x) &#123; if (x instanceof Comparable) &#123; Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p; if ((c = x.getClass()) == String.class) // bypass checks return c; if ((ts = c.getGenericInterfaces()) != null) &#123; for (int i = 0; i &lt; ts.length; ++i) &#123; if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp; ((p = (ParameterizedType)t).getRawType() == Comparable.class) &amp;&amp; (as = p.getActualTypeArguments()) != null &amp;&amp; as.length == 1 &amp;&amp; as[0] == c) // type arg is c return c; &#125; &#125; &#125; return null; &#125; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) // for cast to Comparable static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123; return (x == null || x.getClass() != kc ? 0 : ((Comparable)k).compareTo(x)); &#125; static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; transient Node&lt;K,V&gt;[] table; transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; transient int size; transient int modCount; int threshold; final float loadFactor; public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; public boolean containsKey(Object key) &#123; return getNode(hash(key), key) != null; &#125; public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125; &#125; public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; putMapEntries(m, true); &#125; public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; &#125; final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null; &#125; public void clear() &#123; Node&lt;K,V&gt;[] tab; modCount++; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; size = 0; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; &#125; &#125; public boolean containsValue(Object value) &#123; Node&lt;K,V&gt;[] tab; V v; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; if ((v = e.value) == value || (value != null &amp;&amp; value.equals(v))) return true; &#125; &#125; &#125; return false; &#125; public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; if (ks == null) &#123; ks = new KeySet(); keySet = ks; &#125; return ks; &#125; final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; if (vs == null) &#123; vs = new Values(); values = vs; &#125; return vs; &#125; final class Values extends AbstractCollection&lt;V&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(); &#125; public final boolean contains(Object o) &#123; return containsValue(o); &#125; public final Spliterator&lt;V&gt; spliterator() &#123; return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super V&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.value); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es; &#125; final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(); &#125; public final boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Node&lt;K,V&gt; candidate = getNode(hash(key), key); return candidate != null &amp;&amp; candidate.equals(e); &#125; public final boolean remove(Object o) &#123; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Object value = e.getValue(); return removeNode(hash(key), key, value, true, true) != null; &#125; return false; &#125; public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123; return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; // Overrides of JDK8 Map extension methods @Override public V getOrDefault(Object key, V defaultValue) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? defaultValue : e.value; &#125; @Override public V putIfAbsent(K key, V value) &#123; return putVal(hash(key), key, value, true, true); &#125; @Override public boolean remove(Object key, Object value) &#123; return removeNode(hash(key), key, value, true, true) != null; &#125; @Override public boolean replace(K key, V oldValue, V newValue) &#123; Node&lt;K,V&gt; e; V v; if ((e = getNode(hash(key), key)) != null &amp;&amp; ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) &#123; e.value = newValue; afterNodeAccess(e); return true; &#125; return false; &#125; @Override public V replace(K key, V value) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) != null) &#123; V oldValue = e.value; e.value = value; afterNodeAccess(e); return oldValue; &#125; return null; &#125; @Override public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) &#123; if (mappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; V oldValue; if (old != null &amp;&amp; (oldValue = old.value) != null) &#123; afterNodeAccess(old); return oldValue; &#125; &#125; V v = mappingFunction.apply(key); if (v == null) &#123; return null; &#125; else if (old != null) &#123; old.value = v; afterNodeAccess(old); return v; &#125; else if (t != null) t.putTreeVal(this, tab, hash, key, v); else &#123; tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); return v; &#125; public V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; if (remappingFunction == null) throw new NullPointerException(); Node&lt;K,V&gt; e; V oldValue; int hash = hash(key); if ((e = getNode(hash, key)) != null &amp;&amp; (oldValue = e.value) != null) &#123; V v = remappingFunction.apply(key, oldValue); if (v != null) &#123; e.value = v; afterNodeAccess(e); return v; &#125; else removeNode(hash, key, null, false, true); &#125; return null; &#125; @Override public V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; &#125; V oldValue = (old == null) ? null : old.value; V v = remappingFunction.apply(key, oldValue); if (old != null) &#123; if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; else removeNode(hash, key, null, false, true); &#125; else if (v != null) &#123; if (t != null) t.putTreeVal(this, tab, hash, key, v); else &#123; tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); &#125; return v; &#125; @Override public V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123; if (value == null) throw new NullPointerException(); if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; &#125; if (old != null) &#123; V v; if (old.value != null) v = remappingFunction.apply(old.value, value); else v = value; if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; else removeNode(hash, key, null, false, true); return v; &#125; if (value != null) &#123; if (t != null) t.putTreeVal(this, tab, hash, key, value); else &#123; tab[i] = newNode(hash, key, value, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); &#125; return value; &#125; @Override public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key, e.value); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; @Override public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) &#123; Node&lt;K,V&gt;[] tab; if (function == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; e.value = function.apply(e.key, e.value); &#125; &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; @SuppressWarnings(&quot;unchecked&quot;) @Override public Object clone() &#123; HashMap&lt;K,V&gt; result; try &#123; result = (HashMap&lt;K,V&gt;)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; // this shouldn&#x27;t happen, since we are Cloneable throw new InternalError(e); &#125; result.reinitialize(); result.putMapEntries(this, false); return result; &#125; // These methods are also used when serializing HashSets final float loadFactor() &#123; return loadFactor; &#125; final int capacity() &#123; return (table != null) ? table.length : (threshold &gt; 0) ? threshold : DEFAULT_INITIAL_CAPACITY; &#125; private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; int buckets = capacity(); // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); s.writeInt(buckets); s.writeInt(size); internalWriteEntries(s); &#125; private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it&#x27;s the nearest public type to // what we&#x27;re actually creating. SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125; &#125; /* ------------------------------------------------------------ */ // iterators abstract class HashIterator &#123; Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e; &#125; public final void remove() &#123; Node&lt;K,V&gt; p = current; if (p == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); current = null; K key = p.key; removeNode(hash(key), key, null, false, false); expectedModCount = modCount; &#125; &#125; final class KeyIterator extends HashIterator implements Iterator&lt;K&gt; &#123; public final K next() &#123; return nextNode().key; &#125; &#125; final class ValueIterator extends HashIterator implements Iterator&lt;V&gt; &#123; public final V next() &#123; return nextNode().value; &#125; &#125; final class EntryIterator extends HashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125; &#125; /* ------------------------------------------------------------ */ // spliterators static class HashMapSpliterator&lt;K,V&gt; &#123; final HashMap&lt;K,V&gt; map; Node&lt;K,V&gt; current; // current node int index; // current index, modified on advance/split int fence; // one past last index int est; // size estimate int expectedModCount; // for comodification checks HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; this.map = m; this.index = origin; this.fence = fence; this.est = est; this.expectedModCount = expectedModCount; &#125; final int getFence() &#123; // initialize fence and size on first use int hi; if ((hi = fence) &lt; 0) &#123; HashMap&lt;K,V&gt; m = map; est = m.size; expectedModCount = m.modCount; Node&lt;K,V&gt;[] tab = m.table; hi = fence = (tab == null) ? 0 : tab.length; &#125; return hi; &#125; public final long estimateSize() &#123; getFence(); // force init return (long) est; &#125; &#125; static final class KeySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;K&gt; &#123; KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public KeySpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super K&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p.key); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super K&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; K k = current.key; current = current.next; action.accept(k); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; &#125; &#125; static final class ValueSpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;V&gt; &#123; ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public ValueSpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super V&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p.value); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super V&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; V v = current.value; current = current.next; action.accept(v); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0); &#125; &#125; static final class EntrySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public EntrySpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; Node&lt;K,V&gt; e = current; current = current.next; action.accept(e); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; &#125; &#125; Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(hash, key, value, next); &#125; // For conversion from TreeNodes to plain nodes Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(p.hash, p.key, p.value, next); &#125; // Create a tree bin node TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(hash, key, value, next); &#125; // For treeifyBin TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next); &#125; /** * Reset to initial default state. Called by clone and readObject. */ void reinitialize() &#123; table = null; entrySet = null; keySet = null; values = null; modCount = 0; threshold = 0; size = 0; &#125; // Callbacks to allow LinkedHashMap post-actions void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125; void afterNodeInsertion(boolean evict) &#123; &#125; void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125; // Called only from writeObject, to ensure compatible ordering. void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException &#123; Node&lt;K,V&gt;[] tab; if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; s.writeObject(e.key); s.writeObject(e.value); &#125; &#125; &#125; &#125; static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; /** * Returns root of tree containing this node. */ final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; &#125; static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123; int n; if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) &#123; int index = (n - 1) &amp; root.hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; if (root != first) &#123; Node&lt;K,V&gt; rn; tab[index] = root; TreeNode&lt;K,V&gt; rp = root.prev; if ((rn = root.next) != null) ((TreeNode&lt;K,V&gt;)rn).prev = rp; if (rp != null) rp.next = rn; if (first != null) first.prev = root; root.next = first; root.prev = null; &#125; assert checkInvariants(root); &#125; &#125; final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; &#125; while (p != null); return null; &#125; final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; return ((parent != null) ? root() : this).find(h, k, null); &#125; static int tieBreakOrder(Object a, Object b) &#123; int d; if (a == null || b == null || (d = a.getClass().getName(). compareTo(b.getClass().getName())) == 0) d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -1 : 1); return d; &#125; final void treeify(Node&lt;K,V&gt;[] tab) &#123; TreeNode&lt;K,V&gt; root = null; for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123; next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; if (root == null) &#123; x.parent = null; x.red = false; root = x; &#125; else &#123; K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; root = balanceInsertion(root, x); break; &#125; &#125; &#125; &#125; moveRootToFront(tab, root); &#125; final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123; Node&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; q = this; q != null; q = q.next) &#123; Node&lt;K,V&gt; p = map.replacementNode(q, null); if (tl == null) hd = p; else tl.next = p; tl = p; &#125; return hd; &#125; final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) &#123; Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) &#123; if (!searched) &#123; TreeNode&lt;K,V&gt; q, ch; searched = true; if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; &#125; dir = tieBreakOrder(k, pk); &#125; TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; &#125; &#125; &#125; final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable) &#123; int n; if (tab == null || (n = tab.length) == 0) return; int index = (n - 1) &amp; hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; if (pred == null) tab[index] = first = succ; else pred.next = succ; if (succ != null) succ.prev = pred; if (first == null) return; if (root.parent != null) root = root.root(); if (root == null || (movable &amp;&amp; (root.right == null || (rl = root.left) == null || rl.left == null))) &#123; tab[index] = first.untreeify(map); // too small return; &#125; TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement; if (pl != null &amp;&amp; pr != null) &#123; TreeNode&lt;K,V&gt; s = pr, sl; while ((sl = s.left) != null) // find successor s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors TreeNode&lt;K,V&gt; sr = s.right; TreeNode&lt;K,V&gt; pp = p.parent; if (s == pr) &#123; // p was s&#x27;s direct parent p.parent = s; s.right = p; &#125; else &#123; TreeNode&lt;K,V&gt; sp = s.parent; if ((p.parent = sp) != null) &#123; if (s == sp.left) sp.left = p; else sp.right = p; &#125; if ((s.right = pr) != null) pr.parent = s; &#125; p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; &#125; else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; if (replacement != p) &#123; TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; &#125; TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); if (replacement == p) &#123; // detach TreeNode&lt;K,V&gt; pp = p.parent; p.parent = null; if (pp != null) &#123; if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; &#125; &#125; if (movable) moveRootToFront(tab, r); &#125; final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // Relink into lo and hi lists, preserving order TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; if ((e.hash &amp; bit) == 0) &#123; if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; &#125; else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; if (loHead != null) &#123; if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; r, pp, rl; if (p != null &amp;&amp; (r = p.right) != null) &#123; if ((rl = p.right = r.left) != null) rl.parent = p; if ((pp = r.parent = p.parent) == null) (root = r).red = false; else if (pp.left == p) pp.left = r; else pp.right = r; r.left = p; p.parent = r; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; l, pp, lr; if (p != null &amp;&amp; (l = p.left) != null) &#123; if ((lr = p.left = l.right) != null) lr.parent = p; if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; l.right = p; p.parent = l; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; x.red = true; for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123; if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (!xp.red || (xpp = xp.parent) == null) return root; if (xp == (xppl = xpp.left)) &#123; if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123; xppr.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.right) &#123; root = rotateLeft(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateRight(root, xpp); &#125; &#125; &#125; &#125; else &#123; if (xppl != null &amp;&amp; xppl.red) &#123; xppl.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.left) &#123; root = rotateRight(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateLeft(root, xpp); &#125; &#125; &#125; &#125; &#125; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123; if (x == null || x == root) return root; else if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (x.red) &#123; x.red = false; return root; &#125; else if ((xpl = xp.left) == x) &#123; if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123; xpr.red = false; xp.red = true; root = rotateLeft(root, xp); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right; if ((sr == null || !sr.red) &amp;&amp; (sl == null || !sl.red)) &#123; xpr.red = true; x = xp; &#125; else &#123; if (sr == null || !sr.red) &#123; if (sl != null) sl.red = false; xpr.red = true; root = rotateRight(root, xpr); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr != null) &#123; xpr.red = (xp == null) ? false : xp.red; if ((sr = xpr.right) != null) sr.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateLeft(root, xp); &#125; x = root; &#125; &#125; &#125; else &#123; // symmetric if (xpl != null &amp;&amp; xpl.red) &#123; xpl.red = false; xp.red = true; root = rotateRight(root, xp); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right; if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red)) &#123; xpl.red = true; x = xp; &#125; else &#123; if (sl == null || !sl.red) &#123; if (sr != null) sr.red = false; xpl.red = true; root = rotateLeft(root, xpl); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl != null) &#123; xpl.red = (xp == null) ? false : xp.red; if ((sl = xpl.left) != null) sl.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateRight(root, xp); &#125; x = root; &#125; &#125; &#125; &#125; &#125; /** * Recursive invariant check */ static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) &#123; TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right, tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next; if (tb != null &amp;&amp; tb.next != t) return false; if (tn != null &amp;&amp; tn.prev != t) return false; if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right) return false; if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash)) return false; if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash)) return false; if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red) return false; if (tl != null &amp;&amp; !checkInvariants(tl)) return false; if (tr != null &amp;&amp; !checkInvariants(tr)) return false; return true; &#125; &#125;&#125;","tags":["源码"]},{"title":"linux安装mysql8","path":"/2022/01/14/linux安装mysql8/","content":"linux安装mysql81234567891011121314151617181920212223242526272829303132333435363738394041# 创建文件夹mkdir environment# 进入文件夹并且下载mysql8wget https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpmrpm -ivh mysql80-community-release-el7-1.noarch.rpm# 需要添加新的命令gpg --export -a 3a79bd29 &gt; 3a79bd29.ascrpm --import 3a79bd29.ascrpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022# 安装mysqlyum install -y mysql-community-server# 在这行这个命令之前先执行yum module disable mysql# 启动并且开机自启动systemctl start mysqldsystemctl enable mysqld# 查看mysql版本信息mysql -V# 查看mysql的临时密码grep &quot;A temporary password&quot; /var/log/mysqld.log# 进入mysql并且重新设置密码mysql -uroot -pALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;自己的mysql的密码&#x27;;# 下面是我自己设置的密码 ， 之后你还可以进行修改 一般这里必须进行修改密码之后再进行策略的修改mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;MYsql123.&#x27;;Query OK, 0 rows affected (0.01 sec)# 查看策略SHOW VARIABLES LIKE &#x27;validate_password%&#x27;;# 这里可能会因为你的密码过于简单有策略的问题，我们可以进行修改ERROR 1819 (HY000): Your password does not satisfy the current policy requirements# 修改策略set global validate_password.policy=0; //里面有很多策略，这里我设置了最简单的策略，学习的时候是可以使用的# 还要修改长度set global validate_password.length=6;# 必须重新进入才能进行mysql密码的简单设定ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;# 开启mysql的端口，默认是3306firewall-cmd --add-port=3306/tcp --permanentfirewall-cmd --reload mysql8下载成功 查看临时密码成功 进入mysql成功 密码策略查看的结果 修改策略成功 本地测试数据库的连接本地数据库需要mysql的授权1234use mysql;select host from user where user=&#x27;root&#x27;;update user set host = &#x27;%&#x27; where user =&#x27;root&#x27;;ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;; 连接成功","tags":["数据库"]},{"title":"leetcode笔试题","path":"/2022/01/12/leetcode笔试题/","content":"151. 翻转字符串里的单词https://leetcode-cn.com/problems/reverse-words-in-a-string/ 1.消除字符串中的多余的空格 0 1 2 3 4 5 6 7 8 9 10 11 12 13 a r e y o u o k 需要变成下面的： 0 1 2 3 4 5 6 7 8 9 10 11 12 13 a r e r y o u o k 将这个序列进行逆序 得到下面的序列 0 1 2 3 4 5 6 7 8 9 10 11 12 13 k o u o y e r a 将我们的每个单词进行逆序[0 , 2) , 然后就可以了 消除空格 ，得到有效字符串的长度 编写一个方法 ， 将字符串进行逆序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.timous.others;import com.sun.org.apache.regexp.internal.RE;/** * https://leetcode-cn.com/problems/reverse-words-in-a-string/ * 输入：&quot;the sky is blue&quot; * 输出：&quot;blue is sky the&quot; * * 输入：&quot; hello world! &quot; * 输出：&quot;world! hello&quot; * 解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 * * 输入：&quot;a good example&quot; * 输出：&quot;example good a&quot; * 解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 * * 输入：s = &quot; Bob Loves Alice &quot; * 输出：&quot;Alice Loves Bob&quot; * * 输入：s = &quot;Alice does not even like bob&quot; * 输出：&quot;bob like even not does Alice&quot; * * 1 &lt;= s.length &lt;= 104 * s 包含英文大小写字母、数字和空格 &#x27; &#x27; * s 中 至少存在一个 单词 * * 请尝试使用 O(1) 额外空间复杂度的原地解法。 * * 中间可能有多个字符 中间没有空格是一个单词 */public class _151_翻转字符串里的单词 &#123; public static void main(String[] args) &#123; String s = &quot;are you ok&quot;; System.out.println(reverseWords(s)); &#125; public static String reverseWords(String s) &#123; if (s == null) return null; char[] chars = s.toCharArray(); // 消除多余的空格 直接挪动我们的元素 ， 从前往后 //字符串最终的有效长度 int len = 0; int cur = 0; //前一个字符是不是为空格字符 一开始遇到的字符是空格的话就需要跳过 ， // 就需要为true 不然的话 一开始有空格的话就会增加长度 ， 前面的空格是我们不需要的 boolean space = true; for (int i = 0; i &lt; chars.length; i++) &#123; if (chars[i] != &#x27; &#x27;)&#123;//非空格字符 chars[cur++] = chars[i]; space = false; &#125;else if (space == false)&#123; //chars[i] 是空格字符 chars[i-1] 是非空格 chars[cur++] = &#x27; &#x27;; space = true; &#125; &#125; len = space ? cur-1:cur; System.out.println(len); //反转操作 写一个函数 reverseSingleWord(chars , 0 , len); cur = 0; // for (int i = 0; i &lt; len; i++) &#123; if (chars[i] == &#x27; &#x27;)&#123; reverseSingleWord(chars , cur , i); cur = i+1; &#125; &#125; reverseSingleWord(chars , cur , len); return new String(chars , 0 , len); &#125; //反转[l , r) 范围内的字符串逆转 也就是把第一个跟最后一个进行交换 private static void reverseSingleWord(char[] chars , int l , int r)&#123; r--; // l 跟 r进行交换 while (l &lt; r)&#123; char temp = chars[l]; chars[l] = chars[r]; chars[r] = temp; r--; l++; &#125; &#125;&#125; 3. 无重复字符的最长子串 pi li i-1 i D D 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.timous.others;import java.util.HashMap;import java.util.Map;/** * https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ */public class _3_无重复字符的最长子串 &#123; public static void main(String[] args) &#123; String s = &quot;abcabcbb&quot;; System.out.println(lengthOfLongestSubstring(s)); &#125; public static int lengthOfLongestSubstring(String s) &#123; if (s == null) return 0; char[] chars = s.toCharArray(); if (chars.length == 0) return 0; int[] array = new int[128]; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = -1; &#125; array[chars[0]] = 0; //扫描我们的字符串 int li = 0; int max = 1; for (int i = 1; i &lt; chars.length; i++) &#123; // chars[i] 上次出现的位置 int pi = array[chars[i]]; if (li &lt;= pi)&#123; li = pi + 1; &#125; max = Math.max(max , i - li + 1); //每次都要添加字符最新位置 array[chars[i]] = i; &#125; return max; &#125; public static int lengthOfLongestSubstring3(String s) &#123; if (s == null) return 0; char[] chars = s.toCharArray(); if (chars.length == 0) return 0; int[] array = new int[26]; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = -1; &#125; array[0] = 0; //扫描我们的字符串 int li = 0; int max = 1; for (int i = 1; i &lt; chars.length; i++) &#123; // chars[i] 上次出现的位置 int pi = array[chars[i] - 97]; if (li &lt;= pi)&#123; li = pi + 1; &#125; max = Math.max(max , i - li + 1); //每次都要添加字符最新位置 array[chars[i] - 97] = i; &#125; return max; &#125; public static int lengthOfLongestSubstring2(String s) &#123; if (s == null) return 0; char[] chars = s.toCharArray(); if (chars.length == 0) return 0; Map&lt;Character , Integer&gt; pre = new HashMap&lt;&gt;(); pre.put(chars[0] , 0); //扫描我们的字符串 int li = 0; int max = 1; for (int i = 1; i &lt; chars.length; i++) &#123; // chars[i] 上次出现的位置 int pi = pre.getOrDefault(chars[i], -1); if (li &lt;= pi)&#123; li = pi + 1; &#125; max = Math.max(max , i - li + 1); pre.put(chars[i] , i); &#125; return max; &#125;&#125; 剑指 Offer 47. 礼物的最大价值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364javapackage com.timous.动态规划;/** * https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/ */public class _剑指Offer47_礼物的最大价值 &#123; /** * 二位数组 * @param grid * @return */ public int maxValue(int[][] grid) &#123; if (grid == null) return 0; int rows = grid.length; int cols = grid[0].length; int[][] dp = new int[rows][cols]; dp[0][0] = grid[0][0]; // 初始化0行 for (int i = 1; i &lt; cols; i++) &#123; dp[0][i] = dp[0][i-1] + grid[0][i]; &#125; //初始化0列 for (int i = 1; i &lt; rows; i++) &#123; dp[i][0] = dp[i-1][0] + grid[i][0]; &#125; for (int row = 1; row &lt; rows; row++) &#123; for (int col = 1; col &lt; cols; col++) &#123; dp[row][col] = Math.max(dp[row-1][col] , dp[row][col-1]) + grid[row][col]; &#125; &#125; return dp[rows-1][cols-1]; &#125; /** * 一维数组 * @param grid * @return */ public int maxValue1(int[][] grid) &#123; if (grid == null) return 0; int rows = grid.length; int cols = grid[0].length; int[] dp = new int[cols]; int count = 0; //循环的次数 dp[0] = grid[0][0]; for (int i = 1; i &lt; cols; i++) &#123; dp[i] = dp[i-1] + grid[0][i]; &#125; for (int row = 1; row &lt; rows; row++) &#123; for (int col = 1; col &lt; cols; col++) &#123; if (col - 1 == 0)&#123; dp[0] = dp[0] + grid[row][0]; &#125; // 比较左边和上面值的大小 ， 如果是上面值是比较大的就选上面的 ， 反之选择最下面的 dp[col] = Math.max(dp[col-1] , dp[col]) + grid[row][col];// dp[col] = dp[col-1] + grid[row][col]; &#125; &#125; return dp[cols - 1]; &#125;&#125;","tags":["笔试"]},{"title":"git学习","path":"/2022/01/11/git学习/","content":"GitGit： 十分简单！！！Github版本控制 版本控制（Revision control）是一种在开发中的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便于恢复以前的版本的软件工程技术 实现扩区域多人协同开发、 追踪和记录一个或者多个文件的历史记录 组织和保护你的源代码和文档 统计工作量 并行开发，提高开发效率 跟踪记录整个软件的开发过程 减轻开发人员的负担，节省时间同时降低人为错误 简单的说就是用于管理多人协同开发项目的技术 没有进行版本控制或者版本控制本身缺乏正确的流程管理，在开发软件的过程中会引入很多的问题，如软件代码的一致性，软件内容的冗余，软件过程的事物性，软件开发过程中的并发性，软件源代码的安全性，以及软件的整合等问题 解决方案1 解决方案2 解决方案3 解决方案4 最终方案1 最终方案2 最终方案3 最终方案4 ……. 无论是工作还是学习，都经过这样一个阶段！ 我们迫切需要一个版本控制工具 多人开发必须要使用版本控制，不然的话可能会花比较大的代价 常见的版本控制工具 我们学习的东西一般都是当下最流行的 主流的版本控制器，有一下的这些： Git SVN（Subversion） CVS（Concurrent Version System） VSS（Micorosoft Visual SourceSafe） TFS（Team Foundation Server） Visual Studio Online 版本控制的产品非常的多（Perforce）等 最大的好处就是分布式版本控制 GIt和SVN的区别git是分布式的版本控制 svn是集中式的版本控制 Git可以直接看到更新了那些代码和文件操作Git是目前最新进的版本控制 Git环境配置所有东西下载慢的话一般都可以去找镜像 下载地址：http://npm.taobao.org/mirrors/git-for-windows 卸载Git 1.直接反安装即可 清理环境变量 2.卸载 安装 无脑下一步即可 启动Git Git Bash：Unix与linux风格的命令行，使用最多推荐最多 Git CMD：windows风格的命令行 Git GUI：图形界面的Git 不建议初学者使用，尽量先熟悉常用的命令 Git基本的linux命令学习 平时一定要多使用这些基础的命令 cd ： 改变目录 cd .. :回退到上一级目录 pwd ： 显示当前所在的目录 ls（ll）：都是列出当前目录中的所有文件只不过后面的列出的内容更为详细 touch： 新建一个文件，如touch index.js 就会在当前目录下新建一个index.js文件 rm： 删除一个文件 如 rm index.js mkdir： 新建一个目录，就是新建一个文件夹 rm -r： 删除一个文件夹 mv： 移动文件 reset： 重新初始化终端 clear ： 清屏 history： 查看历史命令 help：帮助 exit： 退出 # 表示注释 rm -rf &#x2F; 切勿在linux里面尝试 删除电脑的全部文件 Git配置 环境变量只是为了全局使用而已 默认会帮你配置所有的配置文件其实都保存在本地 查看配置git config -l 系统的配置git config --system --list 查看本地的配置git config --global --list 配置邮箱 必须要配置的 12git config --global user.name &quot;Timous&quot;git config --global user.email &quot;1844736251@qq.com&quot; Git理论（所有的时间都要源于这个理论） 工作区域 Git本地有三个工作区域： 工作目录， 暂存区，资源库。如果在加上远程的Git仓库，就可以分为四个工作区域，文件在这四个区域之间的转换关系如下： 工作路径： 写代码的空间 暂存区： 就是一些文件，基本看不到 Repository： 本地的代码库 Remote： 远程仓库 github gitee .git隐藏文件夹 Git项目搭建 创建工作目录与常用的指令 工作目录一般就是你希望Git帮助你管理的文件夹，可以是你的项目的目录，也可以是一个空的目录，建议不要有中文，日常只需要记住以下的6个命令 本地仓库搭建 创建本地仓库的方法有两种，一种是创建全新的仓库，另一种是克隆远程仓库 1.创建全新的仓库，需要Git管理的根目录执行 1234# 在当前目录创建一个新的Git代码库$ git initInitialized empty Git repository in D:/environment/gitcode/.git/ 2.克隆一个远程的仓库到本地 123456789git clone [url] # 克隆一个远程的地址的Cloning into &#x27;openclass&#x27;...remote: Enumerating objects: 272, done.remote: Counting objects: 100% (272/272), done.remote: Compressing objects: 100% (182/182), done.remote: Total 272 (delta 98), reused 119 (delta 68), pack-reused 0Receiving objects: 100% (272/272), 13.41 MiB | 1.54 MiB/s, done.Resolving deltas: 100% (98/98), done. 这个文件夹就是我们的远程的仓库克隆下来的地址 查看文件的状态 文件有四种状态，通过下面的命令可以有 123git add . # 添加所以文件到暂存区git status [filename] # 查看文件的状态git commit -m &quot;要备注的信息&quot; # 提交暂存区的内容到本地仓库 -m 提交信息 忽略文件 前端项目的总npm_moudels 有些时候我们不想把某些文件纳入版本控制中，如数据库文件，临时文件，设计文件等 在主目录下建立.gitignore文件，此文件有如下的规则： 忽略文件中的空行或者以#开始的行会被忽略 使用linux通配符，例如*代表任意多个字符 ？代表一个字符 []代表可选字符范围{} 代表可选字符串范围 如果名称的最前面有一个！，表示例外规则，将不被忽略 如果名称前面是一个&#x2F;表示要忽略的文件在此目录下，而子目录中的文件不被忽略 如果名称的后面是一个&#x2F;表示忽略的是此目录下该名称的子目录，而非文件 123456# 为注释*.txt # 忽略所有.txt结尾的文件！lib.txt # 但lib.txt除外/temp # 仅忽略项目根目录下的TODO文件，不包括其他的tempbuild/ # 忽略build/目录下的所有文件doc/*.txt # 会忽略 doc/*.txt 但是不包括 doc/server/arch.txt .gitignore文件1234567891011121314151617181920212223242526272829303132333435363738*.class*.log*.lock# Package Files #*.jar*.war*.eartarget/#idea.idea/*.iml*velocity.log*### STS ###.apt_generated.factorypath.springBeans### Intellij IDEA ###*.iml*.ipr*.iws*.idea.classpath.project.settings/bin/*.logtmp/#rebel*rebel.xml* 使用码云 github是有墙的，比较慢，在国内的话一般使用gitee gitlab 未来找工作的个人东西 设置本机绑定ssh公钥，实现免密登录 进入 ssh-keygen -t rsa 使用码云创建自己的仓库 许可证开源是否可以随意转载 ，开源不能商业使用，不能转载，限制 git clone https://gitee.com/timou_top/java-project.git克隆到本地 使用IDEA集成Git1.新建项目，绑定git 将我们的远程git文件目录拷贝到项目中即可 2.修改文件使用idea操作git 添加到暂存区 commit提交 push到远程仓库 3.提交测试 上面都是单个人的操作 说明：Git分支123456789101112131415161718# 查看所有的分支git branch# 查看远程所有的分支git branch -r# 新建一个分支，但是依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 合并指定分支到当前分支git merge [branch]# 删除远程仓库分支git push origin --delete [branch-name]git branch -dr [remote/branch] 我们多个分支如果并行执行，会导致我们代码不冲突，也就是同时存在多个版本！！！！ web-api A（Restful.xxxx（）） web-admin B 可能调用A 修改了A的代码 web-app C 可能会调用B和A的代码 冲突了协商即可 如果在同一个文件在合并分支的时候都被修改了，则会引起冲突：解决的办法就是我们可以修改冲突文件后重新提交！ master主分支应该非常稳定，用来发布新的版本，一般情况下不允许直接在上面工作，工作上的一般建立在dev上面，工作完之后，比如要发布，，或者说dev分支代码稳定之后可以合并到master上面来。 &#x3D;&#x3D;注意：找人一起搭建一个远程仓库，联系git，两个人或者是三个人都可以练习&#x3D;&#x3D; 团队很重要 寻找小伙伴","tags":["git"]},{"title":"jvm学习","path":"/2022/01/10/jvm学习/","content":"JVM探究 请你谈谈你对JVM的理解？ jvm8虚拟机和之前的变化 或者说更新 什么是OOM，什么是栈溢出StackOverFlowError Exception ？怎么分析 JVM的常用的调优参数有哪些？ 内存快照如何抓取，怎么分析Dump下来的文件？ 谈谈JVM中类加载器你的认识？？ 1.JVM的位置 2.JVM的体系结构 很多的第三方插件都是在执行引擎那一块加上的，其他的基本动不了 3.类加载器作用： 加载class文件 new Student(); 引用放在javaStack，但是具体的实例是放在堆里面的 1.虚拟机自带的加载器 2.启动类（根）加载器 3.扩展类加载器 4.应用程序加载器 5.双亲委派机制 4.双亲委派机制 沙箱安全机制Java安全模型的核心就是沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境，沙箱机制就是将java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，组织对本地系统造成破坏。沙箱主要限制系统资源访问，系统资源包括： CPU、内存、系统文件、网络。不同级别的沙箱对这些资源访问的限制也可以不一样 所有的java程序都可以指定沙箱，可以定制安全策略。 在java中将执行程序分为本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信任的。对于授信的本地代码可以访问一切本地资源。而对于非授信的远程代码在早期的java实现中，安全依赖于沙箱机制。如下图所示JDK1.0安全模型。 但如此严格的机制也给程序的功能带来障碍，比如用户希望远程代码访问本地系统的时候，就无法实现。因此在后续的java1.1版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型 在java1.2版本中，再次改进了安全机制，增加代码签名，不论本地代码或者是远程代码，都会按照用户的安全策略设定，由类记载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型 当前最新的安全机制实现，则引入了域（Domain）的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问，虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如图所示最新的安全模型。 组成沙箱的基本组件： 字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。 java javax 类装载器（class loader）：其中类装载器在3个方面对Java沙箱起作用 它防止恶意代码去干涉善意的代码； &#x2F;&#x2F;双亲委派机制 它守护了被信任的类库边界； 它将代码归入保护域，确定了代码可以进行哪些操作。3 虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一些列唯一的名称组成，每一个被装载的类有一个名字，这个命名空间是由java虚拟机为每一个类装载器维护的，他们互相之间甚至是不可见的。 类装载器采用的机制是双亲委派模式。 从内层JVM自带的类加载器开始加载，外层恶意同名类得不到加载进而无法使用； 由于严格的通过包来区分访问域，，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效 存取控制： 存取控制器可以控制核心API对操作系统的存取权限，而这个控制策略的设定可以由用户控制 安全管理器： 是核心API和操作系统之间的主要接口，实现权限控制，比存取控制器优先级别高 安全软件包： java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括： 安全提供者 消息摘要 数字签名 keytools https 生成一个安全证书 https通过java实现 加密 鉴别 6.Native12345678910111213141516171819package Native;public class Demo &#123; public static void main(String[] args) &#123; new Thread(()-&gt;&#123; &#125; , &quot;my thread name&quot;).start(); //凡是带了native关键字的，说明了java的作用范围打不到了，会去调用底层的c语言的库 //会进入本地方法栈 ， 调用本地方法接口 java native interface //JNI的作用就是为了扩展java的使用融合不同的编程语言为java所用 最初就是为了融合c和c++ // java诞生的时候 c 和 c ++ 横行，必须要用调用c和c++的程序 // 在内存中专门开辟了一块标记区域： native method stack 登记native方法 //在最终执行的时候，加载本地方法库中的方法 通过jni //private native void start0(); 就是一个单纯的class //java程序驱动打印机， java去管理系统 robot 写外挂 在企业级应用中较为少见 //调用其他接口： Socket webService http // 写其他的东西 通过socket来进行调用 &#125;&#125; 7.pc寄存器程序技术器： programe counter register 每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储执行一条指令的地址，也是即将要执行的指令代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计 8.方法区Method Area 方法区 方法区是被所有的线程共享的，所有的字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域中，此区域属于共享空间 静态变量、常量、类信息（构造方法和接口定义），运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关 static final Class 常量池 1234567891011package Native;public class Demo01 &#123; private int a; private String name; public static void main(String[] args) &#123; Demo01 demo01 = new Demo01(); demo01.a=1; demo01.name=&quot;113&quot;; &#125;&#125; 9.栈一种数据结构 ， 一般和队列做比较 程序 &#x3D; 数据结构 + 算法 程序 &#x3D; 框架 + 业务逻辑 淘汰 SSM SSH SpringBoot SpringCloud 栈： 新进后出 后进先出 类似于一个桶. 队列： 先进先出（FIFO） 为什么main先执行后结束 把mai方法丢进栈里面，然后依次进入往上压入的方法，一旦main方法结束，就相当于是整个程序结束了，栈溢出就是一些方法相互调用，然后如果特别多的话就会溢出 栈： 栈内存，主管程序的运行，生命周期和线程同步，线程结束我们的栈内存就会释放，对于栈来说，不存在垃圾回收问题，一旦线程结束，栈就会结束。 栈： 8大基本类型，对象的引用 实例的方法 栈运行原理： 栈帧 程序正在执行的方法，一定是在栈的顶部，直到栈的东西都弹出来 栈+堆+方法区的一些关系： 对象实例化的过程 10.三种JVM sun公司 HotSpot BEA公司的 JRockit IBM的j9vm JIT编译器 我们学习的都是hotspot的 11.堆（重点）Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。类加载器读取了文件之后，一般把啥东西放入堆中？ 类 方法 常量 变量，保存我们所有引用类型的真实对象 堆内存中还要分为三个内存： 新生区 养老区 永久区 GC垃圾回收主要在伊甸园和养老区 假设内存满了，就是oom，堆内存不够 java.lang.OutOfMemoryError: Java heap space 在8之后，永久存储区改了个名字，叫元空间 12.新生区老年区新生区 类： 诞生和成长的地方，甚至是死亡 伊甸园区： 所有的对象都时在伊甸园区中创建的 幸存者（0,1） 真理： 经过研究，99%的对象都是临时对象，进入养老区的并不是很多 13.永久区这个区域是常驻内存的，用来存放jdk自身携带的class对象。interface元数据， 存储的是java运行时的一些环境或者是类信息，这个区域不存在垃圾回收，在关闭虚拟机的时候回释放这个区域的内存 一个启动类，加载了大量的第三方jar包 一个tomcat部署了太多的应用 或者是大量动态生成的反射类 ， 如果这些类进行不断的加载，就可能放不下，知道内存满，就会出现OOM jdk1.6之前 ： 永久代 常量池是在方法区 jdk1.7 ： 永久代 但是慢慢退化了 去永久代 这个时候常量池是在堆中 jdk1.8之后 ： 无永久代，变成了元空间 常量池在元空间 现在的模型： 14.堆内存调优 123456789101112131415161718maxMemory:981.5totalMemory:981.5Heap PSYoungGen total 305664K, used 20971K [0x00000000eab00000, 0x0000000100000000, 0x0000000100000000) eden space 262144K, 8% used [0x00000000eab00000,0x00000000ebf7afb8,0x00000000fab00000) from space 43520K, 0% used [0x00000000fd580000,0x00000000fd580000,0x0000000100000000) to space 43520K, 0% used [0x00000000fab00000,0x00000000fab00000,0x00000000fd580000) ParOldGen total 699392K, used 0K [0x00000000c0000000, 0x00000000eab00000, 0x00000000eab00000) object space 699392K, 0% used [0x00000000c0000000,0x00000000c0000000,0x00000000eab00000) Metaspace used 3243K, capacity 4496K, committed 4864K, reserved 1056768K class space used 351K, capacity 388K, committed 512K, reserved 1048576KProcess finished with exit code 0# Metaspace 元空间 构思里面存在，但是在物理区域的时候没有这个# PSYoungGen + ParOldGen = 1005056k = 981.5 = totalMemory# -Xms1024m -Xmx1024m -XX:+PrintGCDetails# 把堆内存的空间调打，如果还不行，可能是代码有问题（专业工具） 1234567891011121314151617181920212223242526272829[GC (Allocation Failure) [PSYoungGen: 1536K-&gt;504K(2048K)] 1536K-&gt;687K(7680K), 0.0026000 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 1980K-&gt;503K(2048K)] 2164K-&gt;867K(7680K), 0.0014383 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 1762K-&gt;408K(2048K)] 2126K-&gt;1219K(7680K), 0.0012731 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 1779K-&gt;424K(2048K)] 2591K-&gt;2130K(7680K), 0.0012355 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 1341K-&gt;0K(2048K)] [ParOldGen: 5287K-&gt;1527K(5632K)] 6629K-&gt;1527K(7680K), [Metaspace: 3231K-&gt;3231K(1056768K)], 0.0052460 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 951K-&gt;0K(2048K)] 4268K-&gt;3317K(7680K), 0.0006889 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] 3317K-&gt;3317K(7680K), 0.0003715 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] [ParOldGen: 3317K-&gt;3316K(5632K)] 3317K-&gt;3316K(7680K), [Metaspace: 3231K-&gt;3231K(1056768K)], 0.0057998 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] 3316K-&gt;3316K(7680K), 0.0002574 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] [ParOldGen: 3316K-&gt;3296K(5632K)] 3316K-&gt;3296K(7680K), [Metaspace: 3231K-&gt;3231K(1056768K)], 0.0070062 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] Heap PSYoungGen total 2048K, used 42K [0x00000000ffd80000, 0x0000000100000000, 0x0000000100000000) eden space 1536K, 2% used [0x00000000ffd80000,0x00000000ffd8abc8,0x00000000fff00000) from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) to space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen total 5632K, used 3296K [0x00000000ff800000, 0x00000000ffd80000, 0x00000000ffd80000) object space 5632K, 58% used [0x00000000ff800000,0x00000000ffb38338,0x00000000ffd80000) Metaspace used 3263K, capacity 4496K, committed 4864K, reserved 1056768K class space used 353K, capacity 388K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space\tat java.util.Arrays.copyOf(Arrays.java:3332)\tat java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)\tat java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:674)\tat java.lang.StringBuilder.append(StringBuilder.java:208)\tat Native.Demo01.main(Demo01.java:12)Process finished with exit code 1# 当GC清理不了的时候才会进行报错 ， 是oom的错误 在一个线程中突然出现了一个oom故障，该如何排除 ， 研究为什么出错？ 能够看到代码的第几行出错？ ： 内存快照分析工具 MAT（eclipse），Jprofile（IDEA的） Debug一行一行分析代码 MAT（eclipse），Jprofile（IDEA的）作用： 分析Dump内存文件 ，快速定位内存泄露 获得堆中的数据 获得大的对象 ….. 123456# -Xmx1m 最小的内存 1/64# -Xmx8m 最大的内存 1/4# -XX:+HeapDumpOnOutOfMemoeyError 打印OOM的信息 # -XX:+PrintGCDetails 打印GC来及回收信息-Xmx1m -Xmx8m -XX:+HeapDumpOnOutOfMemoeyError# 要找其他的错误，只需要把后面的改了就行了 这种方式不知道第几行出问题了 15.GC垃圾回收 JVM在进行垃圾回收的时候，并不是对这三个区域进行统一的回收，大部分的时候的回收都是在新生代 新生代 幸存区（form to ） 老年区 GC两种类型： 轻GC 普通的GC 只针对新生代 ， 偶尔去轻幸存区 重GC 全局的GC 老年区 JVM的内存模行和分区： 详细到每个区放什么 堆里面的分区有哪些 ： eden from to old 说说他们的特点 GC的算法有哪些： 1. 标记清除法 2. 标记整理（标记压缩） 3. 复制算法 4. 引用计数法 普通GC和重GC分别在什么时候发生 引用计数法： 复制算法： 好处： 没有内存的碎片 坏处： 浪费了内存空间 多了一半内存空间永远是空 to 假设对象是100%存活（极端情况的时候回被放大） 复制算法最佳使用场景是对象存活度较低的情况： 新生区 标记清除算法： 缺点： 两次扫描 ， 严重浪费时间，会产生内存碎片 优点： 不需要额外的空间 标记压缩： 是对于标记清除的再优化 总结： 内存效率： 复制算法》标记清除算法》标记压缩（时间复杂度） 内存整齐度：复制算法》标记压缩》标记清除算法 内存利用率：标记压缩》标记清除算法》复制算法 思考： 难道没有最优的算法吗？ 没有最优的算法来进行调优，只有最合适的 GC： 分代收集算法 年轻代： 存活率低 复制算法 老年代： 区域大，存活率高 标记清除（内存碎片不是太多）+标记压缩混合实现 一天学JVM，不现实，要深究，必须花时间学习，多看面试题 16.JMM java memory model 什么是JMM 【JMM】（Java Memory Model的缩写）允许编译器和缓存以数据在处理器特定的缓存（或寄存器）和主存之间移动的次序拥有重要的特权，除非程序员使用了volatile或synchronized明确请求了某些可见性的保证。 他是干啥的 官方 博客 对应的视频 作用：缓存一致性协议，用于定义数据读写的规则。 JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory） 解决共享对象可见性这个问题，我们可以使用java volatile关键字或者是加锁 他如何学习 JMM是一个抽象的概念 volatile 123456789101112131415lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 17.总结1.百度 2.思维导图","tags":["虚拟机"]},{"title":"docker学习","path":"/2022/01/08/docker学习/","content":"Docker？ 2020年，docker必备的 Devops Docker 学习 Docker 运行 Docker概述 Docker安装 Docker命令 镜像命令 容器命令 操作命令 。。。 Docker镜像 容器数据卷 DockerFile 做镜像 Docker网络原理 IDEA整合Docker 到这就是单机版的docker 集群 Docker Compose 集群的编排管理 Docker Swarm 相当于简化版的k8s CI&#x2F;CD jenkins Docker概述Docker为什么会出现一款产品： 开发-》上线 两套环境！ 应用环境，应用配置 开发人员 运维人员 会产生问题 我在我的电脑上可以运行，你那不能运行 版本更新导致服务不可用 这些问题对于运维考验是十分大的 开发即运维！ 环境配置是比较麻烦的，每个机器都要部署环境（集群 redis hadoop ES 费时费力） 从根本上上解决问题 发布一个项目 jar war redis mysql jdk es 可能你部署环境的时候部署好久都不能部署完 我们可以带着环境去运行 项目能不能带着环境打包安装 Docker就是干这个事的 配置是十分麻烦的 不能跨平台的 环境是不能跨平台的，环境是天壤指别的 传统的给一个jar就行了，所有的东西交给运维就行了，现在的思想是我们把一套流程做完！ java—–》apk—-》发布 应用商店 软件会有人用 张三使用apk 下载安装即可用！ 我们现在就是这个逻辑，把环境和代码全部打包就可以 Docker仓库 类似一个商店 下载运行即可 Docker给以上的问题提出了解决方案！！！！ Docker的思想就来源于集装箱！ jre —– 多个应用 （端口冲突 配置错误，连接错误） —- 原来可能是交叉的 隔离：Docker的思想 打包装箱，每个箱子是互相隔离的，我们之后就不用担心端口或者是其他的环境出问题了 一个箱子装水果，一个箱子装生化武器 ，现在我们为了让这些东西放在一个环境，我们通过容器进行隔离，我们通过这个就直接可以使用隔离机制保护的很好 Docker通过隔离的机制，可以把服务器运行到极致 Tomcat 集群 或者是redis集群，我们通过docker一键就可以安装了 本质：所有的技术都是因为出现了问题，我们才会去学习，才会出现新的东西 Docker的历史2010年，几个搞it的年轻人，在美国成立了一家公司dotcloud 做一些pass的云计算服务 linux虚拟机 有关的容器技术 将自己的技术（容器化技术）进行统一的简化命名，Docker Docker刚刚诞生的时候，没有引起行业的注意，由于经济问题，dotcloud，经营不下去，开源开放源代码，让所有的人一起研发，2013年，Docker创始人将docker开源，很多人觉得技术可以，现在很多的人发现了docker的优点，所以就火了。几乎每个月就会更新一个版本。到了2014年4月9日docker1.0发布！6年几乎成为开发人员所必须的技术。 Docker为什么会这么火？ 十分轻巧 在容器出来之前，我们都使用的是虚拟机技术 虚拟机：在window装一个虚拟机软件wmware，通过这个软件我们可以虚拟一台或者是多台电脑，十分笨重的是基本的是十几个G的，笨重，好处是每个虚拟的电脑都相当于是一个真实的电脑。虚拟机是虚拟化技术，Docker容器技术也是一种容器化技术！ 例子： 12wm: linux centos 原生镜像（一整个电脑） 隔离需要开启多个虚拟机 一般都要几分钟docker容器： 隔离 镜像机制 只是一个最核心的环境 4m+jdk+mysql 直接运行镜像就可以了，这个东西是十分小巧的 容器是秒级的启动 聊聊DockerDocker是基于GO语言开发的开源项目 官网：https://www.docker.com/ 文档地址：https://docs.docker.com/get-docker/ Docker的文档是十分详细的！！！ 仓库地址：https://hub.docker.com/ pull push 发布到远程仓库也可以 Docker百度百科Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 Docker能干啥？ 之前的虚拟机技术 缺点: 资源占用十分多 冗余步骤多 启动十分的慢 容器化技术 &#x3D;&#x3D;容器化技术不是模拟的一个完整的操作系统，比如安装centos只需要一个核心&#x3D;&#x3D; 比较Docker和虚拟机技术的不同： 传统虚拟机虚拟出一套硬件，运行一个完整的操作系统，在这个系统安装软件运行 容器化技术是直接应用在宿主机的内容，容器是没有内核的，实现公用的内核，也没有虚拟我们的硬件，所有就轻便了 每个容器间是互相隔离的，每个容器都有一个自己的文件系统，互不硬性 Docker 3 30 利用这个linux的环境 DevOps 开发 运维 初级程序员 运维也一定要会 更快速的交付和部署 传统： 帮助文档 安装程序 部署 Docker： 打包镜像，发布测试，一键运行 更便捷的升级和扩缩容 使用了docker我们部署应用就和搭积木一样！！ springboot 1.5 redis 5 tomcat 8 现在我们通过docker就可以直接进行运行了 项目打包一个镜像，服务器A，可以直接在服务器B直接运行 更简单的系统运维 在容器化之后，我们的开发，运行测试基本环境都是高度一直的 更高小的资源利用 1核2G 可以几十个tomcat Docker 是内核级别的虚拟化，可以再咱们的一个物理机上可以运行很多的容器实例！！！服务器的性能可以被压榨到极致 Docker安装Docker基本组成 镜像 image: 就好比一个模板，可以通过模板来创建容器服务，tomcat镜像—-》run——》tomcat容器（提供服务），通过这个镜像可以创建多个容器（最终的服务或者是项目运行就是在这个容器中的） 容器 container：Docker利用容器技术，独立运行一个或者是一组应用，通过镜像来创建的，启动，停止，删除，基本命令！目前就可以把这个容器理解为一个简易的linux系统 仓库 repository：就是存储镜像的地方！！仓库分为公有仓库和私有仓库。Docker Hub（默认是国外的） 阿里云…都有容器服务器（我们可以配置镜像加速） 安装Docker环境准备 会一点的linux基础 Centos 7 我们使用xshell连接远程服务器进行操作 环境查看1234567891011121314151617181920# 系统的内核是3.10版本以上的[root@izbp169pmuqqu68q0mhkfaz /]# uname -r3.10.0-514.26.2.el7.x86_64# 系统版本[root@izbp169pmuqqu68q0mhkfaz /]# cat /etc/os-releaseNAME=&quot;CentOS Linux&quot;VERSION=&quot;7 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;7&quot;PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR=&quot;0;31&quot;CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;HOME_URL=&quot;https://www.centos.org/&quot;BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot; 安装1234567891011121314151617181920212223242526272829303132# 1.卸载旧的版本yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 2. 需要的安装包yum install -y yum-utils# 3. 设置镜像的仓库yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 这个是阿里云的 推荐使用，不然的话十分的慢 https://download.docker.com/linux/centos/docker-ce.repo # 默认的是国外的，我们使用国内的# 更新索引yum makecache fast# 4.安装docker最新的 docker-ce是社区版的 ee是企业版的 官方也使用ceyum install docker-ce docker-ce-cli containerd.io# 5.启动dockersystemctl start docker# 6.安装成功下图所示 12# 7.运行hello-worlddocker run hello-world 运行成功： 12# 8.查看hello-world镜像在不在docker images 卸载docker1234# 移除镜像yum remove docker-ce docker-ce-cli containerd.io# 删除工作目录rm -rf /var/lib/docker 设置阿里云加速 登录阿里云找到容器镜像服务 找到镜像加速 配置使用 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://5q2uftpp.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 回顾hello-world流程运行流程图 有些没有会找不到，报错 底层原理Docker是如何工作的 Docker是一个client-server结构的系统，Docker的守护运行在我们的主机上（宿主机），通过Socker从客户端访问 DockerServer接受DockerClient的指令，就会执行这个指令 Docker为什么比虚拟机快： 左边是虚拟机，右边是docker docker有着比虚拟机更少的抽象层 docker利用的是宿主机的内核，vm需要的是Guest OS 所以说，新建一个容器的时候，docker并不需要像虚拟机一样重新加载一个操作系统的内核，避免引导。虚拟机加载的是Guest OS，分钟级别的，而docker利用的是宿主机的操作系统，省略了这个复杂的过程 之后学习完毕所有的命令，在回过头来看这段理论就会十分清晰的 Docker的常用命令帮助命令123docker version # 显示docker的版本信息docker info # 显示更加详细的信息 镜像和容器的数量的等docker 命令 --help # 帮助 命令文档：https://docs.docker.com/reference/ 镜像的命令12345678910111213141516171819docker images # 查看所有本地主机上面的镜像[root@izbp169pmuqqu68q0mhkfaz /]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest bf756fb1ae65 9 months ago 13.3kBREPOSITORY # 镜像的仓库源TAG # 镜像的标签IMAGE ID # 镜像的idCREATED # 镜像的创建时间SIZE # 镜像的大小# 可选项 -a # 列出所有的镜像 -q # 只显示镜像的id -aq # 显示所有镜像的id docker search 可以直接去这个地址搜索镜像：https://registry.hub.docker.com/ 镜像搜索123456789101112131415docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10015 [OK] mariadb MariaDB is a community-developed fork of MyS… 3669 [OK] # 可选项 -f, --filter filter Filter output based on conditions provided # 过滤 --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don&#x27;t truncate output [root@izbp169pmuqqu68q0mhkfaz /]# docker search mysql --filter=STARS=3000NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10015 [OK] mariadb MariaDB is a community-developed fork of MyS… 3669 [OK] 下载镜像123456789101112131415161718192021222324252627282930313233343536373839404142docker pull mysql # 下载镜像 默认使用最新版[root@izbp169pmuqqu68q0mhkfaz /]# docker pull mysqlUsing default tag: latest # 如果不写tag默认是罪行的latest: Pulling from library/mysqld121f8d1c412: Pull complete # 分层下载 docker image的核心f3cebc0b4691: Pull complete 1862755a0b37: Pull complete 489b44f3dbb4: Pull complete 690874f836db: Pull complete baa8be383ffb: Pull complete 55356608b4ac: Pull complete dd35ceccb6eb: Pull complete 429b35712b19: Pull complete 162d8291095c: Pull complete 5e500ef7181b: Pull complete af7528e958b6: Pull complete Digest: sha256:e1bfe11693ed2052cb3b4e5fa356c65381129e87e38551c6cd6ec532ebe0e808 #签名Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest # 真实地址# 下面的这两个命令是等价的docker pull mysqldocker pull docker.io/library/mysql:latest# 指定版本下载[root@izbp169pmuqqu68q0mhkfaz /]# docker pull mysql:5.75.7: Pulling from library/mysql d121f8d1c412: Already exists # 之前下载过了，可以使用以前的东西f3cebc0b4691: Already exists 1862755a0b37: Already exists 489b44f3dbb4: Already exists 690874f836db: Already exists baa8be383ffb: Already exists 55356608b4ac: Already exists 277d8f888368: Pull complete 21f2da6feb67: Pull complete 2c98f818bcb9: Pull complete 031b0a770162: Pull complete Digest: sha256:14fd47ec8724954b63d1a236d2299b8da25c9bbb8eacc739bb88038d82da4919Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 docker rim删除镜像 没有全部删除，只删除了属于5.7版本的层次的东西 123docker rmi -f ef08065b0a30 # 删除指定id 的镜像docker rmi -f id [id] # 删除多个镜像docker rmi -f $(docker images -aq) #删除所有的镜像 容器命令说明： 我们有了镜像才会有容器，我们下载一个centos来测试学习 1docker pull centos 新建容器并且启动12345678910111213141516171819202122232425262728293031323334353637383940docker run [可选参数] image# 参数说明--name # 容器名字 tomcat01 用来区分容器-d # 后台运行-it # 使用交互模式运行-p # 指定的容器的端口 8080:8080 -p ip：主机端口：容器端口 -p 主机端口：容器端口 （常用） -p 容器端口 容器端口-P # 随机指定端口# 测试[root@izbp169pmuqqu68q0mhkfaz /]# docker run -it centos /bin/bash # 启动并且进入容器[root@42dde16a4b41 /]# # 此时已经在容器的内部了[root@42dde16a4b41 /]# lsbin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var# 上面的就是一个小型的服务器 跟外部的没有啥关系# 从容器中推到主机[root@42dde16a4b41 /]# exitexit[root@izbp169pmuqqu68q0mhkfaz /]# lsbin boot data dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var# 列出所有的运行的容器[root@izbp169pmuqqu68q0mhkfaz /]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42dde16a4b41 centos &quot;/bin/bash&quot; 4 minutes ago Exited (0) About a minute ago strange_hoover30aaa7b43000 bf756fb1ae65 &quot;/hello&quot; 2 hours ago Exited (0) 2 hours ago busy_ptolemy # 列出当前正在运行的容器-a # 列出当前正在运行的容器，还有历史运行的容器-n=? # 显示最近创建的容器-q # 只显示容器的编号 退出容器123exit # 容器停止退出ctrl+p+q # 容器停止不退出 删除容器1234docker rm 容器id # 删除指定的容器docker rm $(docker ps -aq) # 删除所有的容器# 不能删除正在运行的容器docker ps -a -qxargs docker rm # 删除所有的容器 启动和停止容器12345docker start 容器id # 启动启动容器docker stop 容器id # 停止当前正在运行容器docker restart 容器id # 重启容器docker kill 容器id # 强制停止当前容器 常用的其他命令123456789101112131415# 后台启动# docker run -d 镜像名docker run -d centos# 问题 ： docker ps 发现centos停止了# 常见的坑，容器使用后台运行，就必须要有一个前台进程，docker发现没有应用就会自动停止# nginx，容器启动之后，发现自己没有服务会立刻停止 发现没有程序了，最后就停止了# 查看日志 docker logsdocker logs -f -t --tail 19 26534cd836dc 没有日志，自己编写一段shell脚本--tail num # 要显示的日志条数-f # 带上时间戳&quot;while true:do echo timous;sleep 2;&quot; 查看容器中的进程信息 1234567891011[root@izbp169pmuqqu68q0mhkfaz /]# docker top --helpUsage:\tdocker top CONTAINER [ps OPTIONS]Display the running processes of a containerdocker top 容器id[root@izbp169pmuqqu68q0mhkfaz /]# docker top ee55e34eb941UID PID PPID C STIME TTY TIME CMDroot 17647 17626 0 16:06 ? 00:00:00 /bin/bash -c while true;do echo timous;sleep 1;doneroot 17987 17647 0 16:09 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1 查看镜像的元数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210docker inspect ee55e34eb941[root@izbp169pmuqqu68q0mhkfaz /]# docker inspect ee55e34eb941[ &#123; &quot;Id&quot;: &quot;ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3&quot;, &quot;Created&quot;: &quot;2020-10-04T08:06:10.003607393Z&quot;, &quot;Path&quot;: &quot;/bin/bash&quot;, &quot;Args&quot;: [ &quot;-c&quot;, &quot;while true;do echo timous;sleep 1;done&quot; ], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 17647, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2020-10-04T08:06:10.379247101Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125;, &quot;Image&quot;: &quot;sha256:0d120b6ccaa8c5e149176798b3501d4dd1885f961922497cd0abef155c869566&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3/ee55e34eb941ef3731b9cdccfec672c46682690b87de5bca7591f363389689c3-json.log&quot;, &quot;Name&quot;: &quot;/charming_gates&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: &#123; &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: &#123; &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: &#123;&#125; &#125;, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: &#123;&#125;, &quot;RestartPolicy&quot;: &#123; &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 &#125;, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;Capabilities&quot;: null, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: false, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] &#125;, &quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/e9f1b7ac4782a1ff47ebd0ac9a25147a64006cc8b0ba8fdb86d31980438a3850-init/diff:/var/lib/docker/overlay2/2f1f2c9feada01705f5f971d6cbf9f5cdb6d64de3a48556ed7fada3f8252ac9d/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/e9f1b7ac4782a1ff47ebd0ac9a25147a64006cc8b0ba8fdb86d31980438a3850/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/e9f1b7ac4782a1ff47ebd0ac9a25147a64006cc8b0ba8fdb86d31980438a3850/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/e9f1b7ac4782a1ff47ebd0ac9a25147a64006cc8b0ba8fdb86d31980438a3850/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;, &quot;Mounts&quot;: [], &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;ee55e34eb941&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;while true;do echo timous;sleep 1;done&quot; ], &quot;Image&quot;: &quot;centos&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123; &quot;org.label-schema.build-date&quot;: &quot;20200809&quot;, &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;, &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;, &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;, &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot; &#125; &#125;, &quot;NetworkSettings&quot;: &#123; &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;9a08423b1508ec7922699865f0f5482ee7c6dc9a0b37451201e89a6a604cbc86&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: &#123;&#125;, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/9a08423b1508&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;86c2383afa0dc2f44b00f5d8ac8bc939a9b5080d01378021adbed863652bcd5d&quot;, &quot;Gateway&quot;: &quot;172.18.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.18.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;, &quot;Networks&quot;: &#123; &quot;bridge&quot;: &#123; &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;30b06d957b64f677ac44cc752d240e535850bb5bacc643d96dcf2ea976880c80&quot;, &quot;EndpointID&quot;: &quot;86c2383afa0dc2f44b00f5d8ac8bc939a9b5080d01378021adbed863652bcd5d&quot;, &quot;Gateway&quot;: &quot;172.18.0.1&quot;, &quot;IPAddress&quot;: &quot;172.18.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;, &quot;DriverOpts&quot;: null &#125; &#125; &#125; &#125;] 进入当前正在运行的容器 12345678910111213141516171819# 我们通常都是使用后台管理的方式进行运行的，我们需要进入容器，修改一些配置#命令docker exec -it 容器id /bin/bash[root@izbp169pmuqqu68q0mhkfaz /]# docker exec -it ee55e34eb941 /bin/bash[root@ee55e34eb941 /]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 08:06 ? 00:00:00 /bin/bash -c while true;do echo timous;sleep 1;doneroot 2075 0 0 08:40 pts/0 00:00:00 /bin/bashroot 2099 1 0 08:40 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1root 2100 2075 0 08:40 pts/0 00:00:00 ps -ef# 方式二docker attach 容器id# 测试[root@izbp169pmuqqu68q0mhkfaz /]# docker attach ee55e34eb941正在执行当前的代码exec 进入容器之后开启一个新的终端，可以在里面操作attach 进入容器正在执行的终端，不会启动新的进程 从容器拷贝文件到主机内 12345678910111213141516docker cp 容器id：容器内路径 目的主机路径[root@izbp169pmuqqu68q0mhkfaz home]# docker attach c6a9acaf91e5 [root@c6a9acaf91e5 /]# cd /home[root@c6a9acaf91e5 home]# ls[root@c6a9acaf91e5 home]# touch test.java[root@c6a9acaf91e5 home]# exit exit[root@izbp169pmuqqu68q0mhkfaz home]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc6a9acaf91e5 centos &quot;/bin/bash&quot; 2 minutes ago Exited (0) 4 seconds ago romantic_almeida[root@izbp169pmuqqu68q0mhkfaz home]# docker cp c6a9acaf91e5:/home/test.java /home[root@izbp169pmuqqu68q0mhkfaz home]# lsadmin staragent test.java timous.java www# 拷贝是一个手动过程 未来我们可以使用卷技术来进行实现 小结 123456789101112131415161718192021222324252627282930313233343536373839404142434445attach Attach to a running container # 当前 shell 下 attach 连接指定运行镜像build Build an image from a Dockerfile # 通过 Dockerfile 定制镜像commit Create a new image from a container changes # 提交当前容器为新的镜像cp Copy files/folders from the containers filesystem to the host path#从容器中拷贝指定文件或者目录到宿主机中create Create a new container # 创建一个新的容器，同run，但不启动容器diff Inspect changes on a container&#x27;s filesystem # 查看 docker 容器变化events Get real time events from the server # 从 docker 服务获取容器实时事件exec Run a command in an existing container # 在已存在的容器上运行命令export Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ]history Show the history of an image # 展示一个镜像形成历史images List images import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]info Display system-wide information # 显示系统相关信息inspect Return low-level information on a container # 查看容器详细信息kill Kill a running container # kill 指定 docker 容器load Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save]login Register or Login to the docker registry server # 注册或者登陆一个docker 源服务器logout Log out from a Docker registry server # 从当前 Dockerregistry 退出logs Fetch the logs of a container # 输出当前容器日志信息port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT #查看映射端口对应的容器内部源端口pause Pause all processes within a container # 暂停容器ps List containers # 列出容器列表pull Pull an image or a repository from the docker registry server #从docker镜像源服务器拉取指定镜像或者库镜像push Push an image or a repository to the docker registry server #推送指定镜像或者库镜像至docker源服务器restart Restart a running container # 重启运行的容器rm Remove one or more containers # 移除一个或者多个容器rmi Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]run Run a command in a new container # 创建一个新的容器并运行一个命令save Save an image to a tar archive # 保存一个镜像为一个tar 包[对应 load]search Search for an image on the Docker Hub # 在 docker hub 中搜索镜像start Start a stopped containers # 启动容器stop Stop a running containers # 停止容器tag Tag an image into a repository # 给源中镜像打标签top Lookup the running processes of a container # 查看容器中运行的进程信息unpause Unpause a paused container # 取消暂停容器version Show the docker version information # 查看 docker 版本号wait Block until a container stops, then print its exit code # 截取容器停止时的退出状态值 docker上面学的知识最基本的命令，还有很多的命令需要学习 作业练习Docker安装Nginx12345678910111213141516171819202122232425262728293031323334353637383940414243# 1. 搜索镜像 dockerhub上去搜索# 2. 下载镜像# 3. 运行下载的Nginx-d # 后台启动 --name 给容器起名字 -p 宿主机端口：容器内端口docker run -d --name nginx01 -p 3344:80 nginx# 本地测试 curlcurl localhost:3344# 测试结果&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;root@09646f289814:/# whereis nginxnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginxroot@09646f289814:/# cd /etc root@09646f289814:/etc# cd nginxroot@09646f289814:/etc/nginx# lsconf.d\tfastcgi_params\tkoi-utf koi-win mime.types modules nginx.conf scgi_params\tuwsgi_params win-utf **注意：**如果端口或者不能启动的话就直接重启docker 1[root@izbp169pmuqqu68q0mhkfaz home]# systemctl restart docker # 重启docker 端口暴露：、 思考问题： 我们每次改动nginx配置文件都需要进入容器的内部，我要是能够在容器外部提供一个映射路径，达到在容器外部修改文件，容器内部就可以自动修改？ -v 数据卷的技术 Docker安装Tomcat&#x3D;&#x3D;注意：&#x3D;&#x3D;这里的容器内部的和容器外部的端口都要打开的 123456789101112131415# 官方的使用docker run -it --rm tomcat:9.0# 我们之前都是启动的后台，停止容器之后还是可以找到的，上面的是用完就会删除的 但是不会删除镜像#下载启动# 测试访问没问题，但是没有出现tomcat页面 这是因为这是个不完整的版本的docker exec -it tomcat01 /bin/bash# 进入之后发现 没有webapps和ll命令 阿里云镜像的原因，默认是最小的镜像，所有的不必要的都剔除掉，保证最小可运行的环境cp -r webapps.dist/* webappsroot@5d448aeddfff:/usr/local/tomcat/webapps# lsROOT docs examples host-manager manager 思考问题： 我们以后部署项目，每次都进去是十分麻烦的，我们如果可以在容器外部提供一个映射路径，webapps，使得我们在外部放置的项目自动同步到我们的内部就好了。 部署es+kibana12345678910111213141516171819# es 暴露的端口很多# es 十分消耗内存# es的数据一般要放置到安全文件夹# --net somenetwork这是一个网络配置docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:tag# 下载启动docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2# 启动完之后发现自己的服务器都是很卡的 docker status 查看cpu的状态# 启动完之后发现自动关了# 测试es是否成功了# 开始测试的时候发现他自动停止了# 可以修改配置文件 -e 环境配置修改docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2 12345678910111213141516171819[root@izbp169pmuqqu68q0mhkfaz /]# clear[root@izbp169pmuqqu68q0mhkfaz /]# curl localhost:9200&#123; &quot;name&quot; : &quot;bf3f2cba9661&quot;, &quot;cluster_name&quot; : &quot;docker-cluster&quot;, &quot;cluster_uuid&quot; : &quot;6SNBo33YSSaOLNBJ8IN_SQ&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;7.6.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;docker&quot;, &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;, &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.4.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 作业：使用kibana连接 可视化 portainer 1docker run -d -p 8088:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true pontainer/pontainer Ranch （持续集成和部署） 什么是portainer？ Docker的图形化界面管理工具！提供一个后台模板供我们操作 1234567docker run -d -p 8088:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true pontainer/pontainer# 这个是我们的官方给的东西 上面的经过试验，不能使用$ docker volume create portainer_data$ docker run -d -p 8088:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainerhttp://localhost:8088/ 运行之后的截图 选择本地的 进入之后的面板 我们所有的信息都可以看到 我们平时不会使用，我们测试一下就可以了。 Docker镜像讲解镜像是什么镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件的所有内容，包括代码，运行时，库，环境变量和配置文件 所有的应用直接打包成为一个Docker镜像部署 如何得到镜像： 远程仓库下载 朋友拷贝给你 自己制作一个镜像Dockerfile Docker加载原理 UnionFS 联合文件系统 我们下载的时候看到的一层一层的就是这个 UnionFS（联合文件系统）： Union文件系统时一种分层、轻量级并且高性能的文件系统，它支持对文件系统的的修改，作为一次提交来一层一层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite severral directions into single virtual filesystem）.Union文件系统时Docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 特性： 一次同时加载多个文件系统，但是从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有的底层的文件和目录 类似于git 的版本控制 ， 每一次都会直接记录下来 比如tomcat和mysql都是在centos下面执行的，我们下载一个就够了（这只是一个说法） Docker镜像加载原理 docker的镜像实际上是由一层一层的文件系统组成，这种层级的文件系统UnionFS（联合文件系统） boorfs（boot file system）主要包含bootloader和kernel，bootloader主要用于引导加载kernel，linux刚启动的时候会加载bootfs文件系统，早Docker镜像的最底层bootfs，这一层和我们典型的linux&#x2F;unix系统是一样的，包含boot加载器和内核。当boot加载完成之后，整个内核就在内存中了，此时内存的使用权由bootfs转交给内核，此时系统也会卸载bootfs rootfs（root file system），在bootfs之上，包含的就是典型linux系统中的。&#x2F;dev, &#x2F;proc ,&#x2F;bin ,&#x2F;etc等标准文件和目录。rootfs就是各种不同的操作系统发行版本，比如ubuntu ，centos等等 平时我们安装的centos是需要好几个G的，为什么这里的centos才200M？ 对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令和程序库就可以了，因为底层都是直接用的Host的kernel，自己只需要提供rootfs就可以了，由此可见，对于不同的linux发行的版本，bootfs基本上是一致的，因此不同的发行版本可以使用一个bootfs。 分层理解 分层的镜像 我们可以去下载一个镜像，发现观察下载的日志输出，可以看到是一层一层的在下载 这里的每一层就是一个文件级的记录 理解： 所有的Docker镜像都是起始于一个基础的镜像层，当进行修改或增加新的内容的时候，就会在当前的镜像之上，创建新的镜像，举一个简单的例子，假如基于Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果该镜像中添加了python包，就会在基础的镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层 该镜像相当于已经包含了三个镜像层，如下图所示（这是一个用于演示的很简单的例子） 在添加额外的镜像的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要，下图举了一个简单的例子，每个镜像包含三个文件，而镜像包含了来自两个镜像层的六个文件 上图中的镜像层跟之前的图中略有区别，主要目的是便于展示文件 下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为上层的文件7是文件5的一个更新版本 这种情况下，上层镜像层中的文件覆盖了底层镜像中的文件。这样就使得文件的更新版本作为一个新的镜像层添加到镜像当中。Docker可以通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示同一的文件系统。Linux上可用存储的引擎有： AUFS、Overlay2、Device Mapper、Btrfs以及zfs。顾名思义，每种存储引擎都基于Linux中对应文件系统或者块设备技术，并且每种存储引擎都有独特的性能特点。 Docker在Windows上仅支持windowfilter一种存储引擎，该存储引擎基于NTFS文件系统之上实现了分层和COW[1]. 下图展示了与系统显示相同的三层镜像，所有镜像层堆叠合并，对外提供统一的视图 特点 Docker默认都是只读的，容器启动时，一个新的可写层被加载到镜像的顶部！ 这一层就是我们通常所说的容器层，容器层之下的都叫镜像层 也就是说原来的你是没有动，只是在上面添加了新的东西 如何提交一个自己的镜像 Commit镜像123docker commit # 提交容器成为一个新的副本# 命令和git类似docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器 id 目标镜像名：[TAG] 实战测试： 1234567# 启动一个默认的tomcat# 发现这个默认的tomcat是没有webapps应用的，镜像的原因，官方的镜像是默认没有webapps的文件的# 自己拷贝了应该有的文件# 将操作过的容器通过commit提交为一个镜像，我们以后就使用这个修改多的镜像就可以了，这就是我们自己修改过的一个镜像 学习方式说明： 概念 ，一定要实践，实践和理论像结合，一次搞定 如果你想保存当前容器的状态，，就可以通过commit来进行提交，获得一个镜像，就好比虚拟机的快照 现在就是入门 容器数据卷什么是容器数据卷docker的理念： ​\t将环境和应用打包成为一个镜像！！ 如果数据放在容器中，那么我们删除容器的时候，数据就会丢： 需要数据持久化 MySQL，容器删了，MySQL的数据可以保存在本地 容器之间可以有一个数据共享的技术！！Docker容器中产生的数据可以同步到本地，容器删除，数据不会丢失，这就是我们的卷技术！ 也就是目录的挂载，将我们的容器的目录挂在在linux上。 就是为了容器的持久化和同步操作，容器间的数据也是可以共享的 使用数据卷 使用命令来进行挂载 1docker run -it -p 主机端口：容器端口 -v 容器内的目录：主机目录 运行的容器的： 主机上面的： 从这里可以看出，我们的数据时挂载过来了 这也就类似于双向绑定，这样即使把容器删除之后也会保留数据的，缺点是数据会有两份的 即使容器停止之后，在宿主机修改文件，容器也是会更改的 实战： 安装mysqlmysql的数据持久化问题 data 123456789101112131415161718# 1. 获取镜像docker search mysql# 2. 运行容器 做数据挂载 # 安装启动mysql的时候需要配置密码的# 官方测试$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag# 启动mysql-d 后台运行-p 端口映射-v 路径挂载-- name 名字-e 配置环境# /home/mysql/conf:/etc/mysql/conf.d /home/mysql/conf 这个时候在5.7版本的是没有数据的，8.0以上的版本可能会有docker run -d -p 3344:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysqldev mysql# 此时的mysql的最新版本和旧的版本可能是不一样的 mysql5.7成功连接 但是最新的mysql用sqlyog或者是navcat都无法成功docker run -d -p 3355:3306 -v /home/mysql01/conf:/etc/mysql -v /home/mysql01/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 经过查看之后发现是因为加密规则发生了变化， 123456789101112131415# 进入mysql8.0版本的docker exec -it acd145dcb29d /bin/bash# 进入我们的mysqlroot@acd145dcb29d:/# mysql -uroot -pEnter password: Welcome to the MySQL monitor# 修改加密规则mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27; PASSWORD EXPIRE NEVER;Query OK, 0 rows affected (0.24 sec)mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;Query OK, 0 rows affected (0.02 sec)# 修改加密规则之后修改密码mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;Query OK, 0 rows affected (0.01 sec) 此时我们再通过连接发现已经可以连接上去了： 在本地创建数据库，查看映射的路径也是没有问题的，经过测试在干掉mysql容器之后，服务器本地依然书没有数据的丢失的 具名挂载和匿名挂载12345678910111213141516# 匿名挂载-v 容器内路径docker run -d -p --name nginx01 -v /etc/nginx nginx# 查看所有的卷的情况# -v 卷名:容器内路径docker volume lsDRIVER VOLUME NAMElocal edfe864135f1168478f3f213897a44bd3fa637309aad854a37a4ea02ba2fa736 # 这个时候匿名挂载local portainer_data local 47b671908d5e1b9b7abe1b3e07ea090e1a45061f0cc6f98000c3d7e07c0d1c6elocal edfe864135f1168478f3f213897a44bd3fa637309aad854a37a4ea02ba2fa736local nginxtest # 这个是具名挂在local portainer_data 所有docker容器内的卷，没有指定目录的情况下，都是在/var/lib/docker/volumes/nginxtest/_data 我们通过具名挂载可以方便的找到我们的一个卷，大多数情况下使用具名挂载 如何确定是具名挂载还是匿名挂载，还是指定路径挂载 123456-v 容器内路径 # 匿名挂载-v 卷名：容器内路径 # 具名挂载-v /宿主机路径：容器内路径 # 指定路径挂载ro/rw # 这个是指定读写权限的 ro read only rw read write# 一旦设定了 ro 我们就改动不了了 ro意思是只能从外部改变，不能从内部改变 也就是宿主机可以改变，但是容器内不能改变docker run -d -P --name nginx05 -v nginxtest:/etc/nginx：ro/rw nginx 初识DockerFiledockerfile就是用来构建docker镜像文件的构建文件！！命令脚本 方式二 123456789101112# 通过这个脚本可以生成镜像 ， 镜像是一层一层的，脚本是一个一个命令，每个命令就是一层# 指令和参数FROM centos VOLUME [&quot;volumn01&quot;,&quot;volumn02&quot;]CMD echo &quot;---end------&quot;CMD /bin/bash# 这里的每个命令就是一层 -f 文件所在的位置 -t 生成的镜像的名字和版本 # 注意这里的后面有一个点是必须加上的docker build -f dockerfile1 -t timouscentos:1.0 . 启动自己生成的容器 上面的两个是我们在生成镜像的时候所挂载的，这个卷和外部肯定有一个同步的目录，这个是匿名挂载，找的时候是乱码 从我们的Mounts，可以看到为止 这种方式我们使用的十分多，通常我们会构建自己的镜像 假设构架你的时候没有挂载卷，要手动进行镜像挂载 -v 卷名：容器内路径 数据卷容器是多个容器之间共享数据 ， 如多个mysql数据同步 contos01就是数据卷容器，两个或者是多个容器实现数据共享 12# 通过自己写的镜像启动docker run -it --name docker03 --volumes-from docker01 5d8055e306ce docker01 docker02 docker01创建文件 docker02 docker01创建的东西，docker02也能接收到，docker run -it --name docker03 --volumes-from docker01 5d8055e306ce，只要通过这种进行挂载的，都会成功进行共用。此时就算docker01容器没有的时候，我们的02和03依然是可以访问之前创建的文件的。 最主要的还是他们都挂载在相同的目录了 mysql数据共享多个mysql实现数据共享，redis实现数据共享 123456# docker run -d -p 3355:3306 -v /home/mysqltest1/conf:/etc/mysql -v /home/mysqltest1/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7docker run -d -p 3344:3306 -e MYSQL_ROOT_PASSWORD=123456 --volumes-from mysql01 --name mysql02 mysql:5.7# 这个时候就会实现数据的共享 结论： 容器之间配置信息的传递，容器数据卷的生命周期会一直持续到没有容器使用为止 但是一旦持久化到了本地，这个时候本地的数据是不会删除的 但是这种挂载启动的时候发现mysql是无法同时登陆两个的，可能是因为二者公用的是一个数据，所以一个连接的时候另外一个不能连接 DockerFiledockerfile是用来构建docker镜像的文件命令参数脚本 构建步骤： 编写一个dockerfile文件 docker build 构建一个镜像 docker run 运行镜像 docker push 发布镜像 DockerHub 阿里云镜像仓库等 查看官方是怎么做的 这就是一个基本的命令脚本。 123456789101112131415FROM scratch # 这是一个最基础的ADD centos-7-x86_64-docker.tar.xz / #添加一个centos的镜像LABEL \\ org.label-schema.schema-version=&quot;1.0&quot; \\ org.label-schema.name=&quot;CentOS Base Image&quot; \\ org.label-schema.vendor=&quot;CentOS&quot; \\ org.label-schema.license=&quot;GPLv2&quot; \\ org.label-schema.build-date=&quot;20200809&quot; \\ org.opencontainers.image.title=&quot;CentOS Base Image&quot; \\ org.opencontainers.image.vendor=&quot;CentOS&quot; \\ org.opencontainers.image.licenses=&quot;GPL-2.0-only&quot; \\ org.opencontainers.image.created=&quot;2020-08-09 00:00:00+01:00&quot;CMD [&quot;/bin/bash&quot;] 很多官方的镜像都是基础包，很多的功能是没有的，我们通常会自己搭建自己的镜像 官方可以制作镜像，我们也可以制作自己的镜像 DockerFile构建过程 基础知识： 保留的关键字都必须是大写字母 执行顺序从上到下 #表示注释 每一条命令都是一层 DockerFile是面向开发的，我们以后要发布项目做镜像，我们就要编写dockerfile文件，这个文件十分简单 Docker镜像已经逐渐成为企业交付的标准，必须掌握 步骤 开发 部署 上限 运维 DockerFile： 构建文件，定义了一切的步骤，好比一个源代码 DockerIamages ： 通过DockerFile构建成的镜像，最终发布和运行的产品 Docker容器: 容器就是镜像运行起来提供服务的 DockerFile的指令12345678910111213141516# 上面我们都是使用别人的，现在我们就可以自己写一个镜像了FROM # 基础镜像， 一切从这里开始构建MAINTAINER # 镜像是谁写的 姓名+邮箱RUN # docker镜像运行时需要构建的路径ADD # 步骤 ， 搭建一个有tomcat 的 要加一个tomcat的压缩包，添加内容WORKDIR # 镜像的等工作目录 /或者是哪个路径VOLUME # 挂载卷EXPOSE # 指定暴露端口 在这里暴露 外面就不需要暴露了ls -a -l前者不显示，后者显示CMD # 指定这个容器启动的时候要运行的命令 只有最后一个会生效，可被替代ENTRYPOINT # 可以直接追加命令ONBUILD # 当构建一个被继承DockerFile 这个时候就会运行ONBUILD指令 触发指令COPY # 类似ADD ， 将我们的文件拷贝到镜像中ENV # 构建的时候设置环境变量 实战测试DockerHub大多数的镜像都是从基础镜像中获取的 FROM scratch 创建一个自己的centos 123456789101112131415161718192021222324252627282930# 1.编写dockerfile文件FROM centosMAINTAINER timous&lt;1844736251@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;---end-----&quot;CMD /bin/bash# 2. 通过这个文件构建镜像-f dockerfile文件路径-t 镜像名和标签docker build -f mydockerfile -t mycentos:0.1 .Successfully built 4ab9930f53eeSuccessfully tagged mycentos:0.1# 3. 测试运行 直接进入了工作路径，而不是根目录 对比之前原生的，我们多了自己添加的功能。 我们可以列出本地镜像的变更历史 CMD 和ENTRYPOINT 的区别1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889CMD # 指定这个容器启动的时候要运行的命令 只有最后一个会生效，可被替代ENTRYPOINT # 可以直接追加命令FROM centosCMD [&quot;ls&quot;,&quot;-a&quot;]# 构建镜像[root@izbp169pmuqqu68q0mhkfaz dockerfile]# docker build -f dockercmd -t cmd:0.1 .Sending build context to Docker daemon 3.072kBStep 1/2 : FROM centos ---&gt; 0d120b6ccaa8Step 2/2 : CMD [&quot;ls&quot;,&quot;-a&quot;] ---&gt; Running in 252ebc591da5Removing intermediate container 252ebc591da5 ---&gt; 48c2615d874aSuccessfully built 48c2615d874aSuccessfully tagged cmd:0.1# 运行[root@izbp169pmuqqu68q0mhkfaz dockerfile]# docker run cmd:0.1....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar# 发现我们的命令生效了# 想追加一个命令 发现错误了 它会替换 docker run cmd:0.1 ls -al[root@izbp169pmuqqu68q0mhkfaz dockerfile]# docker run cmd:0.1 -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused &quot;exec: \\&quot;-l\\&quot;: executable file not found in $PATH&quot;: unknown.# ENTRYPOINT 不需要进行替换FROM centosENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;][root@izbp169pmuqqu68q0mhkfaz dockerfile]# docker run 2b16d27edab1....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar[root@izbp169pmuqqu68q0mhkfaz dockerfile]# docker run 2b16d27edab1 -ltotal 56drwxr-xr-x 1 root root 4096 Oct 5 09:13 .drwxr-xr-x 1 root root 4096 Oct 5 09:13 ..-rwxr-xr-x 1 root root 0 Oct 5 09:13 .dockerenvlrwxrwxrwx 1 root root 7 May 11 2019 bin -&gt; usr/bindrwxr-xr-x 5 root root 340 Oct 5 09:13 devdrwxr-xr-x 1 root root 4096 Oct 5 09:13 etc# 从结果可以看出我们的ENTRYPOINT 不会替换，是直接在后面追加命令的 并没有被替换 ，而是追加了docker存在很多这样的命令的 Docker‘中很多的命令都十分的相似，我们需要去了解他们的区别。我们最好就是对比练习。 实战：Tomcat 准备镜像文件，tomcat压缩包和jdk压缩包 编写Docker文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Dockerfile 是官方的命名，我们之后启动的时候不用加-f 了，就会去找这个文件FROM centosMAINTAINER timous&lt;1844736251@qq.com&gt;COPY read.txt /usr/local/readme.txtADD jdk-8u231-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.38.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_231ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.38ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.38ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME:lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.38/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.38/bin/logs/catalina.out# JDKFROM centosMAINTAINER timous&lt;1844736251@qq.com&gt;ADD jdk-8u231-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.38.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_231ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV PATH $PATH:$JAVA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.38/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.38/bin/logs/catalina.out# 构建镜像 docker build -t mytomcat .# 启动镜像docker run -d -p 8001:8080 --name mytomcat00 -v /home/tomcat/test:/usr/local/apache-tomcat-9.0.38/webapps -v /home/tomcat/tomcatlogs:/usr/local/apache-tomcat-9.0.38/logs mytomcat# 直接在本地发布项目就可以了，在挂载的目录下就可以了 &#x3D;&#x3D;注意：这里解压之后的webapps里面也是没有东西的，相当于是阉割版的，我们需要在里面添加东西再启动才能访问8080端口，这里只需要把webapps里面的东西考进去就行了，经过测试8.x和9.x是一样的，都是阉割版的，没有webapps下面的东西&#x3D;&#x3D; 经过测试，这个就可以直接发布项目了，之后需要掌握DockerFile的编写以及命令，之后我们就可以自己写项目发布应用了。 发布自己的镜像 DockerHub 1.地址：https://hub.docker.com/ 2.确定和这个账号能够登录就行了 3.在我们本地的linux登录我们的dockerhub账户 1234567891011[root@izbp169pmuqqu68q0mhkfaz ~]# docker login --helpUsage:\tdocker login [OPTIONS] [SERVER]Log in to a Docker registry.If no server is specified, the default is defined by the daemon.Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username 4.登录完毕之后我们自己docker push就可以了 1234567[root@izbp169pmuqqu68q0mhkfaz ~]# docker login -u timousPassword: WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded 5.提交镜像 12345678910111213The push refers to repository [docker.io/library/mytomcat]c67968a0b49c: Preparing 974165b6465d: Preparing 4aa18435b87c: Preparing 19a87c01b4dd: Preparing 291f6e44771a: Preparing denied: requested access to the resource is denied # 这个时候回被拒绝 可能不是因为本地的# 尽量带上自己的版本号# 增加一个tag就可以了 还有就是也要带上自己的版本号和名字 一般的话没有名字是提交不上去的[root@izbp169pmuqqu68q0mhkfaz ~]# docker tag 6c4d4c60d337 timous/tomcat:1.0[root@izbp169pmuqqu68q0mhkfaz ~]# docker push timous/tomcat:1.0 提交的时候还是按照层级来进行发布的。 阿里云镜像服务上面也可以发布 1.创建命名空间 2.创建容器镜像 3.浏览阿里云的信息 &#x3D;&#x3D;注意：这里要按照阿里云上的名字命名，不然的话会被拒绝的&#x3D;&#x3D; 也就是参考官方文档，下面就是我们的发布的image 阿里云操作1. 登录阿里云Docker Registry1$ sudo docker login --username=我命由我不由天0000-1dgpcx registry.cn-hangzhou.aliyuncs.com 用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。 您可以在访问凭证页面修改凭证密码。 2. 从Registry中拉取镜像1$ sudo docker pull registry.cn-hangzhou.aliyuncs.com/timous/timousdocker:[镜像版本号] 3. 将镜像推送到Registry1$ sudo docker login --username=我命由我不由天0000-1dgpcx registry.cn-hangzhou.aliyuncs.com$ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/timous/timousdocker:[镜像版本号]$ sudo docker push registry.cn-hangzhou.aliyuncs.com/timous/timousdocker:[镜像版本号] 请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。 4. 选择合适的镜像仓库地址从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。 如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-hangzhou.aliyuncs.com 作为Registry的域名登录。 5. 示例使用”docker tag”命令重命名镜像，并将它通过专有网络地址推送至Registry。 1$ sudo docker imagesREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEregistry.aliyuncs.com/acs/agent 0.7-dfb6816 37bb9c63c8b2 7 days ago 37.89 MB$ sudo docker tag 37bb9c63c8b2 registry-vpc.cn-hangzhou.aliyuncs.com/acs/agent:0.7-dfb6816 使用 “docker push” 命令将该镜像推送至远程。 1$ sudo docker push registry-vpc.cn-hangzhou.aliyuncs.com/acs/agent:0.7-dfb6816 小结 还有save和load，分别是保存，可以使一个压缩包 Docker网络理解网络：docker0清空所有的环境 ip addr 三个网络，分别代表了三种不同的环境 1234567891011121314151617181920# docker 如何处理容器网络的访问 下面的该如何连接docker run -d -P --name tomcat01 tomcat# 查看容器的网络地址 # 会得到一个eth0@if201这个地址[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat01 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever206: eth0@if207: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0 valid_lft forever preferred_lft forever# 我们的linux服务器能不能ping容器的内部 从下面的结果能够看出我们可以ping通我们的docker容器的内部[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# ping 172.18.0.2PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.084 ms64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.073 ms64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.087 ms 原理 我们每启动一个docker，docker就会给docker容器分配一个ip，我们只要安装docker，就会有一个网卡docker0，桥接模式，使用的技术是evth-pair技术 再次测试ip addr的时候发现多了一个 我们在启动一个tomcat02 经过观察发现，都是一对一对出现的，这个技术就是evth-pair，就是虚拟设备的接口，都是成对出现的，一端连接协议，一边连接端口，正因为这个技术，evth-pair充当一个桥梁，连接各种虚拟设备 Openstac、Docker等都是使用的这个技术 tomcat01和tomcat02是不是能直接ping同呢？ 12345[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat02 ping 172.18.0.2PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.134 ms64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.090 ms# 经过测试，是可以ping通的 结论： tomcat01和tomcat02是一个公用的路由器，docker0 所有的容器在不指定网络的情况下，都是docker0的路由，docker会给我们分配一个可用的ip地址 小结 Docker使用的是linux的桥接 Docker中的所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件都是10M等），只要容器删除，对应的一对地址就没有了 思考，编写了一个服务，database&#x3D;ip….. springcloud feign …. 我们能不能通过名字来ping，我们希望可以通过名字来进行访问，如果能够做到这一点我们就可以进行高可用了。 –link123456789101112131415[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat02 ping tomcat01ping: tomcat01: Name or service not known# 我们无法直接ping tomcat ping通 我们该如何解决[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker run -d -P --name tomcat03 --link tomcat02 tomcat13c7e106aab64631cc484b2057292bf0b6f8e1ce3923ea3e7a3de1eb80c8bb99[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat03 ping tomcat02PING tomcat02 (172.18.0.3) 56(84) bytes of data.64 bytes from tomcat02 (172.18.0.3): icmp_seq=1 ttl=64 time=0.127 ms64 bytes from tomcat02 (172.18.0.3): icmp_seq=2 ttl=64 time=0.092 ms64 bytes from tomcat02 (172.18.0.3): icmp_seq=3 ttl=64 time=0.098 ms64 bytes from tomcat02 (172.18.0.3): icmp_seq=4 ttl=64 time=0.097 ms# 发现通过这个之后，我们可以解决这个网络的连通问题[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat02 ping tomcat03ping: tomcat03: Name or service not known# 经过测试，发现不能连接 探究inspect 123456789[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat03 cat /etc/hosts127.0.0.1\tlocalhost::1\tlocalhost ip6-localhost ip6-loopbackfe00::0\tip6-localnetff00::0\tip6-mcastprefixff02::1\tip6-allnodesff02::2\tip6-allrouters172.18.0.3\ttomcat02 d63422c29b92 # 我们看到直接在hosts的配置中直接配置了一个配置172.18.0.4\t13c7e106aab6 –link就是在hosts里面添加了一个tomcat02的地址的配置，此处的就能够直接看出来本质了，但是这个已经不推荐了 我们现在玩docker已经不建议使用了，我们需要更高级的网络，我们需要自定义网络 docker0不支持容器名字的访问 自定义网络容器互联 查看所有的docker网络， 网络模式 桥接模式 bridge docker上面大桥 01 02 0 这个是默认的 自己创建也使用这个模式 不配置网络 none 主机模式 host 和宿主机共享网络 container： 容器内网络连通（用得少， 局限很大） 测试1234567891011121314151617# 我们直接启动的默认有--net bridge 这个就是docker0docker run -d -P --name tomcat01 tomcatdocker run -d -P --name tomcat01 --net bridge tomcat# docker0 是默认的 域名是不能访问的 --link可以打通连接 我们可以自定义网络来进行部署项目--driver 桥接--subnet 子网--gateway 网关[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet88d5d361b0539b4461d073b040bbe14f0fe8bf21c6a2242bba42467aea983a51[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker network lsNETWORK ID NAME DRIVER SCOPE6e908f0c98ad bridge bridge local9fa20911f238 host host local88d5d361b053 mynet bridge localbfb5c7518713 none null local 我们自己的网络就配置好了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker network inspect mynet[ &#123; &quot;Name&quot;: &quot;mynet&quot;, &quot;Id&quot;: &quot;88d5d361b0539b4461d073b040bbe14f0fe8bf21c6a2242bba42467aea983a51&quot;, &quot;Created&quot;: &quot;2020-10-07T22:28:14.670138277+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;, &quot;Gateway&quot;: &quot;192.168.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123; &quot;b103628af5e9cf31882dda4daad6ddc9050a929e3cabcd5cf14450112f53dc7d&quot;: &#123; &quot;Name&quot;: &quot;tomcat02&quot;, &quot;EndpointID&quot;: &quot;0723ecfc892ff755a3cd6ac46e3b0b1e27d9388223e5c0ab61a589973985ac39&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;e0bfc05259b497257357904fc7be88f5ae26846f2afa3510172a5dee51eca601&quot;: &#123; &quot;Name&quot;: &quot;tomcat03&quot;, &quot;EndpointID&quot;: &quot;b53ad2db79b00c3eae4ab2a2d852f2b99cf0044eb121ef17bbc68ad3b27d9cc0&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123;&#125;, &quot;Labels&quot;: &#123;&#125; &#125;]# 再次测试ping连接，不使用--link，我们也可以直接使用名字ping通[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat02 ping 192.168.0.3PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.137 ms64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.100 ms^C--- 192.168.0.3 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1000msrtt min/avg/max/mdev = 0.100/0.118/0.137/0.021 ms[root@izbp169pmuqqu68q0mhkfaz TomcatJdk]# docker exec -it tomcat02 ping tomcat03PING tomcat03 (192.168.0.3) 56(84) bytes of data.64 bytes from tomcat03.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.066 ms64 bytes from tomcat03.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.110 ms64 bytes from tomcat03.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.124 ms# 我们自定义的网络，docker都帮我们维护了关系 推荐我们平时这么使用网络 好处 redis集群 不同的集群在不同的网络，，保证网络是安全的 mysql集群 网络连通的操作测试连通tomcat-01到mynet docker network inspect mynet &#x3D;&#x3D;连通之后就相当于把tomcat-01直接放进mynet里面，一个容器两个地址&#x3D;&#x3D; 这里能够看出02不能够连接，但是01能够连接。 假设要跨网络去操作别人就需要使用docker connect来进行连通 实战： 部署redis集群 在r-m-3没了的时候，我们的r-s-3就会顶上去 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# shell脚本直接创建6个redisfor port in $(seq 1 6); \\do \\mkdir -p /mydata/redis/node-$&#123;port&#125;/conftouch /mydata/redis/node-$&#123;port&#125;/conf/redis.confcat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1$&#123;port&#125;cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdone# 运行容器docker run -p 6371:6379 -p 16371:16379 --name redis-1 \\-v /mydata/redis/node-1/data:/data \\-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6372:6379 -p 16372:16379 --name redis-2 \\-v /mydata/redis/node-2/data:/data \\-v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6373:6379 -p 16373:16379 --name redis-3 \\-v /mydata/redis/node-3/data:/data \\-v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6374:6379 -p 16374:16379 --name redis-4 \\-v /mydata/redis/node-4/data:/data \\-v /mydata/redis/node-4/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6375:6379 -p 16375:16379 --name redis-5 \\-v /mydata/redis/node-5/data:/data \\-v /mydata/redis/node-5/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6376:6379 -p 16376:16379 --name redis-6 \\-v /mydata/redis/node-6/data:/data \\-v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf# 创建集群redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1[root@izbp169pmuqqu68q0mhkfaz /]# docker exec -it redis-1 /bin/sh/data # lsappendonly.aof nodes.conf/data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1# 进去测试/data # redis-cli -c 127.0.0.1:6379&gt; cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:1cluster_stats_messages_ping_sent:143cluster_stats_messages_pong_sent:145cluster_stats_messages_sent:288cluster_stats_messages_ping_received:140cluster_stats_messages_pong_received:143cluster_stats_messages_meet_received:5cluster_stats_messages_received:288127.0.0.1:6379&gt; cluster nodescdc72565a6fbbc78d4173303abb899159768f7a3 172.38.0.11:6379@16379 myself,master - 0 1602084842000 1 connected 0-546091f6e56ca65c2345de0bd30a921124a9c62dd860 172.38.0.13:6379@16379 master - 0 1602084842876 3 connected 10923-16383130eefbca879a19e897ee3b94d1a751727fc1f0f 172.38.0.14:6379@16379 slave 91f6e56ca65c2345de0bd30a921124a9c62dd860 0 1602084841000 4 connectedea144f07a760b383c79d0cb6684fad6b1451b391 172.38.0.15:6379@16379 slave cdc72565a6fbbc78d4173303abb899159768f7a3 0 1602084842575 5 connectedadb8733c26c78112f07d4c5f8b463290f8b90314 172.38.0.16:6379@16379 slave 2a4a261302515c19fbb92734fee8993b2d1f5c74 0 1602084842575 6 connected2a4a261302515c19fbb92734fee8993b2d1f5c74 172.38.0.12:6379@16379 master - 0 1602084841874 2 connected 5461-10922127.0.0.1:6379&gt; set a b-&gt; Redirected to slot [15495] located at 172.38.0.13:6379OK docker redis集群搭建成功 我们使用docker之后，所有的技术都会慢慢变得简单起来 SpringBoot微服务打包docker镜像 构建springboot项目 打包应用 编写dockerfie 构建镜像 发布运行 运行成功 我自己的项目已经部署到服务器上面了 Docker ComposeDocker Swarm","tags":["运维"]},{"title":"jar包下载问题","path":"/2022/01/03/jar包下载问题/","content":"jar包下载慢的问题的解决在maven的配置文件中增加如下的配置 12345678910111213141516171819202122232425262728293031323334353637&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;!-- 阿里云仓库 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库1 --&gt; &lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库2 --&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 配置完成即可快速下载jar包","tags":["小技巧"]},{"title":"java基础知识","path":"/2021/12/31/java基础知识/","content":"Java的基础知识变量、数据类型、运算符二进制计算机中广泛使用的数制，由0和1进行表示，数字计算机只能识别和处理二进制计算。也对应着高电平和低电平等等。在线进制转换工具：https://tool.lu/hexconvert/ ， 下面是一些常见的二进制的数和十进制数的转换。 0 0 1 1 2 10 3 11 4 100 5 101 6 110 7 111 8 1000 9 1001 10 1010 11 1011 12 1100 13 1101 14 1110 注释&#x2F;&#x2F;是给人看的，不是给机器看的，在以后的编程中是非常有用的。 下面是带有注释的代码 //后面对应的就是注释，不影响程序的运行 123456public class HelloWorld &#123; public static void main(String[] args) &#123; //这是我写的第一个注释 System.out.println(&quot;我是Timous&quot;); &#125;&#125; 下面是对应的运行成功的结果。 标识符在命名标识符的时候一般使用驼峰命名的方式。 标识符需要遵守一定的规则： 标识符必须以字母、下划线、美元符号开头 标识符其他部分可以使字母、下划线、美元符、和数组的任意组合 Java标识符大小写敏感，而且长度无限制 标识符不可以是Java的关键字 Java不采用语言使用的ASCII字符集，而是采用Unicode这样的标准国际字符集。因此，这里的字母的含义不仅仅是英文还包括汉字等等。但是不建议大家使用汉字来定义标识符。 Java的关键字、保留字 abstart assert boolean break byte case catch char class const continue default do double else extends final finally float for goto if implements impotrt instanceos int interface long native new null package private protected public return short static strictfp super switch synchronized this throw throws transient try void volatile while 变量（variable）变量的本质是可操作的存储空间，空间位置是确定的，但是里面放置什么值是不确定的。可以通过变量名来访问对应的存储空间，从而操作对应存储空间的值。空间是有大有小的，所以之后还要学习对应的数据类型。在声明变量的时候最好是能够使变量具有一定的可读性。局部变量在使用之前要进行声明。常量只能初始化一次。 int 4个字节 long 8个字节 double 8个字节 变量的分类和作用域从整体上可将变量划分为局部变量、成员变量（也称为实例变量）和静态变量。 类型 声明位置 从属于 生命周期（作用域） 局部变量 方法或语句块内部 方法&#x2F;语句块 从声明的位置开始，知道方法或语句块执行完毕，局部变量消失 成员变量（局部变量） 类内部，方法外部 对象 对象创建，成员变量也跟着创建，对象消失，成员变量也跟着消失 静态变量（类变量） 类内部，static修饰 类 类被加载，静态变量就有效，类被卸载，静态变量就跟着消失 基本数据类型Java是一种强类型的语言，每个变量必须声明其数据类型，Java的数据类型可以分为量大类：基本数据类型、引用数据类型 Java中定义了3类8种数据类型 数值型 - byte short int long float double 字符型 - char 布尔型 - boolean 控制语句顺序结构、选择判断、循环结构 选择判断 生成随机1到6的数字 123456public static void main(String[] args) &#123; double d = Math.random(); //Math.random()生成一个[0 , 1)的是随机数 System.out.println(d); int a = 1+(int)(Math.random()*6); //随机生成一个0到6的随机数 System.out.println(a);&#125; 递归自己调用自己，一个递归技术的方法会直接或者是间接调用自己 12345678910111213141516public class HelloWorld &#123; public static void a()&#123; System.out.println(&quot;test.a&quot;); a(); &#125; public static void b()&#123; System.out.println(&quot;test.b&quot;); &#125; public static void main(String[] args) &#123; a(); &#125;&#125; 定义递归的时候要有结束的条件，不然会出现StackOverflowError 递归要有开始和结束才能够实现。不然会出现错误，栈溢出等状况。 面向对象 类对应的就是表格的结构，对象对应的就是表格的内容，实际上所有的数据都可以用表格来表示。数据库也是一张张的表格，“表格就是对象”。","tags":["java"]},{"title":"hexo的写作问题","path":"/2021/12/27/hexo的写作问题/","content":"关于hexo的使用的基本的命令问题在经历了考研之后的第一天，开始重新进行代码的学习，不知道考不考的上，好多的编程知识也忘记了很多，今天开始进行一步一步的回忆，进行慢慢的学习，也只能慢慢学习，年后可能直接要找工作了，希望能够上岸，关于考研这个事情，能考就考，我身边一个快手的朋友，在快手干了半年之后，重新把工作辞了进行考研，这是贴身的经历。希望能够上岸。 创建hexo的博客在创建的时候是有选择的，可以进行三种方式的创建，post、page和draft，存储的路径如下面的图所示。 创建命令 12hexo new [layout] &lt;title&gt; ## layout就是上面的三种方式的布局，我们在进行的时候 ## 这里不知道为啥，我的直接全部都出现在了第一个也就是默认的里面了 下面的就是我创建好的本篇博客的题目 创建完成之后可以用任何你本地的软件打开，形成自己独特的风格，这里我比较喜欢的是typora，现在可能会进行收费了，但是之前是不进行收费的，我的还是之前的版本，你也可以下载以前的版本进行使用，打开这些md的文件进行自己的编写。从下面也可以看到以前写的博客题目，具体的如下图所示。 生成并上传对应的博客生成hexo对应的文件并上传到gitee上面可以通过具体的域名进行访问。 123hexo g ## 这个是对应的生成文件的代码 generate 生成 hexo d ## 这个是上传到gitee上的命令 delivery 传送 更新gitee并访问博客在经过上面的命令之后，每次需要进行手动的更新之后，才能够进行访问。如下图，进行强制的更新。 在更新之后就可以进行访问了。输入自己的对应gitee的域名就可以进行访问了，这个所有的都是不需要进行收费的。 发表一下我现在的感受就是，冷，由于家里没有暖气，今天就写到这了，没有办法，家在乡下。","tags":["hexo"]},{"title":"axios的params和data的区别","path":"/2021/05/13/axios的params和data的区别/","content":"params和data的区别就是你后端接受参数是的状态，是requestbody还是实体类的方式，如果是实体类，那么就是params参数的形式，不然的话就是data的格式 下面的是参数params 下面的是参数data","tags":["小技巧"]},{"title":"Jenkins","path":"/2021/04/12/Jenkins/","content":"Jenkins自动化部署基于Docker安装Jenkins使用docker安装jenkins1docker run -p 9000:8080 -p 5000:5000 -v jenkins_data:/var/jenkins_home jenkinsci/blueocean 访问Jenkins地址http://47.105.129.77:9000/ 输入秘钥之后： 之后出现 创建用户啥的 之后就安装好了 配置java等环境 查看jenkins镜像安装的java地址 echo $JAVA_HOME maven可以自动进行下载 安装maven插件 完成 可以进行maven的构建 开始进行自动部署 进行配置 添加git密码账户 立即构建 构建成功 构建之后的配置 12345678910111213141516171819202122232425262728#!/bin/bash# 服务名称SERVER_NAME=testjenkins# 源jar的路径JAR_NAME=testjenkins-0.0.1-SNAPSHOT# 源jar的路径 直接copy就可以JAR_PATH=/var/jenkins_home/workspace/testJenkins/target# 打包之后的路径JAR_WORK_PATH=/var/jenkins_home/workspace/testJenkins/targetecho &quot;查询进程id--》 $SERVER_NAME&quot;PID=`ps -ef | grep &quot;$SERVER_NAME&quot; | awk &#x27;&#123;print $2&#125;&#x27;`echo &quot;得到进程ID ： $PID&quot;echo &quot;进程结束&quot;for id in $PIDdo kill -9 $id\techo &quot;kill $id&quot;doneecho &quot;进程完成&quot;# 复制jar到执行目录echo &quot;复制jar包到执行目录： cp $JAR_PATH/$JAR_NAME.jar $JAR_WORK_PATH&quot;cp $JAR_PATH/$JAR_NAME.jar $JAR_WORK_PATHecho &quot;复制jar完成&quot;cd $JAR_WORK_PATH# 修改文件的权限chmod 755 $JAR_NAME.jarjava -jar $JAR_NAME.jar 如下图所示： 为了能够访问，我们需要重新构建 12345# 重启dockersystemctl stop docker # 删除镜像docker rm $(sudo docker ps -a -q)docker run -p 9000:8080 -p 5000:5000 -p 8001:8001 -v jenkins_data:/var/jenkins_home jenkinsci/blueocean 测试 修改完代码之后还是成功的进行了访问 问题 命令： 1BULILD_ID=dontKillMe nohup java -jar $JAR_NAME.jar &amp; 测试结果是成功的！！！！ 之后是在idea提交之后自动构建的效果，这里暂时不做研究。之后可能会进行研究。。 安装gitee插件： 安装之后重启 进行密码生成 进行gitee激活 注上面的配置会出现端口的问题，下面是解决的方案 123456789101112131415161718192021222324252627282930#!/bin/bash# 服务名称SERVER_NAME=testjenkins# 源jar的路径JAR_NAME=testjenkins-0.0.1-SNAPSHOT# 源jar的路径 直接copy就可以JAR_PATH=/var/jenkins_home/workspace/testJenkins/target# 打包之后的路径JAR_WORK_PATH=/var/jenkins_home/workspace/testJenkins/targetecho &quot;查询进程id--》 $SERVER_NAME&quot;PID=`ps -ef | grep &quot;$SERVER_NAME&quot; | awk &#x27;&#123;print $1&#125;&#x27;`echo &quot;得到进程ID ： $PID&quot;echo &quot;进程结束&quot;for id in $PIDdo kill -9 $id\techo &quot;kill $id&quot;doneecho &quot;进程完成&quot;# 复制jar到执行目录echo &quot;复制jar包到执行目录： cp $JAR_PATH/$JAR_NAME.jar $JAR_WORK_PATH&quot;cp $JAR_PATH/$JAR_NAME.jar $JAR_WORK_PATHecho &quot;复制jar完成&quot;cd $JAR_WORK_PATH# 修改文件的权限chmod 755 $JAR_NAME.jarBUILD_ID=dontKillMe nohup java -jar $JAR_NAME.jar &amp; # 前台的启动方式# java -jar $JAR_NAME.jar 构建成功！！每次提交代码都会尝试进行构建 至此，今天的东西就结束了！！！","tags":["运维","Jenkins"]},{"title":"ArrayList底层源码详解","path":"/2021/04/06/ArrayList底层源码详解/","content":"ArrayList底层源码详解ArrayList底层的数据结构List解耦的可调整大小的数组实现 数组的特点是一旦初始化，长度就不可以发生改变，这个时候又是一个可以调整的数组 数组特点： 增加元素 删除元素 修改元素 查找元素 数组结构介绍特点： 在增删的时候比较慢： 每次增加元素和删除元素，都需要修改数组的长度，拷贝以及移动元素的位置 查找和修改的时候比较快： 由于数组是存储在一块连续的地址空间，所以可以根据地址+索引的方式快速获取对应位置的元素 类图简介 ArrayList的继承关系Serializable标记性接口介绍类的序列化是由实现java.io.Serializable接口的类启动。不实现接口的类将不会使任何状态的序列或反序列化。可序列化的类的所有子类都是可序列化的。序列化接口没有方法或者是字段，仅用来标识可串行化的语义。 序列化： 将对象的数据写到文件中（写对象） 反序列化： 将文件中的对象的数据读出来（读对象） Serializable源码介绍这种接口在我们的java中还是很多的，就是标记性接口 12public interface serializable&#123;&#125; 案例： 通过序列化或者是反序列化集合 Exception in thread &quot;main&quot; java.io.NotSerializableException: com.domain.Student Cloneable标记性接口介绍 一个类实现了Cloneable接口知识Object.clone（）方法，该方法对于类的实例进行字段的复制是合法的，在不实现Cloneable接口的实例上面调用克隆方法会导致异常ClassNotSupportedException被抛出，简而言之就是克隆根据你已有的数据，创建一份完全一样的拷贝数据 Cloneable源码介绍： 12public interface Cloneable&#123;&#125; 克隆的前提条件： 克隆的对象所在的类必须实现Cloneable接口 必须重写clone方法 克隆的基本使用 已知A对象的姓名为陈留红，年龄23岁，技能为写代码（技能为一个skill），由于项目的特殊要求，需要将该对象复制到另外一个对象中，并且A和B两个对象互不影响 方式一： 创建两个对象模拟 1234567891011121314151617181920212223package com.domain;import java.util.ArrayList;public class ArrayList_clone &#123; public static void main(String[] args) &#123; //创建ArrayList集合 ArrayList&lt;String&gt; arrayList = new ArrayList(); arrayList.add(&quot;陈留红&quot;); arrayList.add(&quot;刘佳金&quot;); arrayList.add(&quot;米金龙&quot;); arrayList.add(&quot;叶剑&quot;); //调用方法进行克隆 Object clone = arrayList.clone(); System.out.println(clone == arrayList); //两个地址是不同的，对象里面的内容跟集合里面的内容是一样的 System.out.println(clone); System.out.println(arrayList); &#125;&#125; 案例：已知对象A的姓名为豹子头林冲，年龄30.由于项目的特殊要求，需要将该对象的数据复制到另一个对象B中去，并且A和B两个对象的数据不会相互影响 传统的方式： 123456789101112131415161718192021222324252627package com.domain;public class ArrayList_Clone_Case &#123; /** * 案例：已知对象A的姓名为豹子头林冲，年龄30.由于项目的特殊要求， * 需要将该对象的数据复制到另一个对象B中去， * 并且A和B两个对象的数据不会相互影响 */ public static void main(String[] args) &#123; //传统方式 //创建学生对象 Student student = new Student(&quot;豹子头林冲&quot;,30); //再创建一个新的对象 Student student1 = new Student(); student1.setUsername(student.getUsername()); student1.setAge(student.getAge()); System.out.println(student == student1); System.out.println(student); System.out.println(student1); System.out.println(&quot;此时不管修改那个的值，两者不会受到影响&quot;); student.setAge(20); System.out.println(student); System.out.println(student1); &#125;&#125; clone的方法： 浅拷贝： 123456789101112131415161718192021222324252627package com.domain;public class ArrayList_Clone_Case1 &#123; /** * 案例：已知对象A的姓名为豹子头林冲，年龄30.由于项目的特殊要求， * 需要将该对象的数据复制到另一个对象B中去， * 并且A和B两个对象的数据不会相互影响 * * 浅拷贝 */ public static void main(String[] args) throws CloneNotSupportedException &#123; //传统方式 //创建学生对象 Student student = new Student(&quot;豹子头林冲&quot;,30); //调用克隆的方法进行数据的拷贝 Object clone = student.clone(); System.out.println(clone == student); System.out.println(student); System.out.println(clone); System.out.println(&quot;修改数据&quot;); student.setAge(50); System.out.println(student); System.out.println(clone); &#125;&#125; 浅拷贝的局限性： 123456789101112131415161718192021222324252627282930313233package com.domain;public class ArrayList_Clone_Case2 &#123; /** * 案例：已知对象A的姓名为豹子头林冲，年龄30.由于项目的特殊要求， * 需要将该对象的数据复制到另一个对象B中去， * 并且A和B两个对象的数据不会相互影响 * * 浅拷贝 * * 浅拷贝的局限性 */ public static void main(String[] args) throws CloneNotSupportedException &#123; //传统方式 //创建技能对象 Skill skill = new Skill(&quot;倒拔垂杨柳&quot;); //创建学生对象 Student student = new Student(&quot;鲁智深&quot;,30 , skill); //调用克隆的方法进行数据的拷贝 Object clone = student.clone(); System.out.println(clone == student); System.out.println(student); System.out.println(clone); System.out.println(&quot;修改数据&quot;); student.setAge(50); skill.setSkillName(&quot;拳打镇关西&quot;); System.out.println(student); System.out.println(clone); &#125;&#125; 经验总结： 浅拷贝在的基本数据类型是可以完全拷贝的，但是关于引用类型的是拷贝的地址 深拷贝： 所有类型的数据都是不会受到影响的 skill类 123456789101112131415161718192021222324252627282930313233package com.domain;public class Skill implements Cloneable&#123; private String skillName; public String getSkillName() &#123; return skillName; &#125; public Skill(String skillName) &#123; this.skillName = skillName; &#125; public Skill() &#123; &#125; public void setSkillName(String skillName) &#123; this.skillName = skillName; &#125; @Override public String toString() &#123; return &quot;Skill&#123;&quot; + &quot;skillName=&#x27;&quot; + skillName + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; student类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.domain;import java.io.Serializable;public class Student implements Serializable , Cloneable&#123; //姓名 private String username; //年龄 private Integer age; private Skill skill; public Student() &#123; &#125; public Student(String username, Integer age) &#123; this.username = username; this.age = age; &#125; public Student(String username, Integer age, Skill skill) &#123; this.username = username; this.age = age; this.skill = skill; &#125; public Skill getSkill() &#123; return skill; &#125; public void setSkill(Skill skill) &#123; this.skill = skill; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; /** * 分析: 创建StringBuild对象 * 先追加一个当前类的类名，以及大括号、成员变量的名字以及=‘ * 再追加成员变量对应的值就是数据 * 再追加’， 后面在跟一个成员变量的名字以及= * 再追加成员变量的值和大括号 * * @return */ @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(&quot;Student[username=&#x27;&quot;); sb.append(this.username); sb.append(&quot;&#x27;, age=&quot;); sb.append(this.age); sb.append(&quot;&#x27;, skill=&quot;); sb.append(skill.getSkillName()); sb.append(&quot;]&quot;); return sb.toString(); &#125; //字符串拼接的时候回有很多的垃圾，我们可以优化 所以有字符串缓冲区等/* @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;*/ /** * 方法的权限修饰符需要修改 public * 方法的返回值是要克隆的对象，可以改为当前类的类名 * @return * @throws CloneNotSupportedException */ @Override public Object clone() throws CloneNotSupportedException &#123; //深拷贝不能简单的调用父类的方法 //先克隆出来一个学生对象 Student stu = (Student)super.clone(); //调用skill类中的克隆方法，克隆出来一个skill对象 Skill skill = (Skill) this.skill.clone(); //技能克隆出来的技能赋值 stu.setSkill(skill); return stu; //return super.clone(); &#125;&#125; 测试代码： 12345678910111213141516171819202122232425262728293031package com.domain;public class ArrayList_Clone_Case4 &#123; /** * 案例：已知对象A的姓名为豹子头林冲，年龄30.由于项目的特殊要求， * 需要将该对象的数据复制到另一个对象B中去， * 并且A和B两个对象的数据不会相互影响 * * 深拷贝 */ public static void main(String[] args) throws CloneNotSupportedException &#123; //传统方式 //创建技能对象 Skill skill = new Skill(&quot;倒拔垂杨柳&quot;); //创建学生对象 Student student = new Student(&quot;鲁智深&quot;,30 , skill); //调用克隆的方法进行数据的拷贝 Object clone = student.clone(); System.out.println(clone == student); System.out.println(student); System.out.println(clone); System.out.println(&quot;修改数据&quot;); student.setAge(50); skill.setSkillName(&quot;拳打镇关西&quot;); System.out.println(student); System.out.println(clone); &#125;&#125; RandomAccess标记接口介绍标记接口由List实现使用，以表明他们支持快速（通常为恒定时间）随机访问。此接口主要目的是允许通用算法更改其行为，以便应用于随机访问或顺序访问列表时提供良好的性能。用于操作随机访问列表的最佳算法（例如ArrayList）可以在应用于顺序访问列表时产生二次行为（如LinkedList）。鼓励通用列表算法在应用如果将其应用于顺序访问列表之前提供较差性能的算法时，检查给定列表是否为instanceof，并在必要的时候更改其行为以保证可接受的性能。人们认识到，随机访问和顺序访问之间的区别通常是模糊的。例如，一些List实现提供渐进的线性访问时间，如果它们在实践中获得巨大但是恒定的访问时间。这样一个List实现应该通常实现这个接口。根据经验，List实现应实现此接口，如果对于类的典型实例，此循环： 12for(int i = 0 , n=list.size() ; i++) list.get(i); //随机访问 比这个循环运行更快 12for( Iterator i = list.iterator() ; i.hasNext();) i.next(); //顺序访问 源码： 12public interface RandomAccess &#123;&#125; 案例演示1 12345678910111213141516171819202122232425262728293031323334353637package com.domain;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class Arraylist_RandomAccess &#123; public static void main(String[] args) &#123; //创建arraylist集合 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加十万条数据 for (int i = 0; i &lt; 100000; i++) &#123; list.add(i+&quot;a&quot;); &#125; //测试随机访问 long start = System.currentTimeMillis(); for (int i = 0; i &lt; list.size(); i++) &#123; // 取出集合的每一个元素 list.get(i); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;随机访问用时：&quot;+(end-start)); //测试顺序访问 long start1 = System.currentTimeMillis(); Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext())&#123; it.next(); &#125; long end1 = System.currentTimeMillis(); System.out.println(&quot;顺讯访问用时：&quot;+(end1-start1)); &#125;&#125; 通过测试我们知道，随机访问比顺序访问用的时间要短，由于ArrayList实现了RandomAccess这个接口，所以，他的随机访问的效率是比较高的 我们再看LinkedList 1234567891011121314151617181920212223242526272829303132333435package com.domain;import java.util.Iterator;import java.util.LinkedList;import java.util.List;public class Arraylist_RandomAccess_LinkedList &#123; public static void main(String[] args) &#123; //创建linkedlist集合 List&lt;String&gt; list = new LinkedList&lt;&gt;(); //添加十万条数据 for (int i = 0; i &lt; 100000; i++) &#123; list.add(i+&quot;a&quot;); &#125; //测试随机访问 long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; list.get(i); &#125; long endTime = System.currentTimeMillis(); System.out.println(&quot;随机访问时间：&quot;+(endTime-startTime)); //测试顺序访问. long startTime1 = System.currentTimeMillis(); Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext())&#123; it.next(); &#125; long endTime1 = System.currentTimeMillis(); System.out.println(&quot;顺序访问时间：&quot;+(endTime1-startTime1)); &#125;&#125; 从结果可以看出来，我们的顺序访问的时间比随机访问的时间短，这个时候我们的LinkedList是没有实现RandomAccess接口的 在企业中进行循环输出的时候判断查询返回的结果是否实现了RandomAccess这个接口，如果实现了这个接口，就推荐使用随机遍历的方式迭代结合，否则就推荐使用顺序的方式迭代集合 如何判断是够实现了RandomAccess这个接口，通过instanceof来判断是否实现这个接口 12345678/*这个是对海量数据的优化*/if(list instanceof RandomAccess)&#123; //推荐使用随机访问&#125;else&#123; //使用顺序访问&#125; AbstractList抽象类 此类提供的骨干实现的List接口以最小化来实现该接口由一个“随机访问”数据存储备份所需的工作（如阵列）。 对于顺序存取的数据（如链接列表）， AbstractSequentialList应优先使用此类。 要实现一个不可修改的列表，程序员只需要扩展这个类并提供get(int)和size()方法的实现。 要实现可修改的列表，程序员必须另外覆盖set(int, E)方法（否则会抛出一个UnsupportedOperationException ）。如果列表是可变大小，则程序员必须另外覆盖add(int, E)和remove(int)方法。 123public E set(int index, E element) &#123; throw new UnsupportedOperationException();&#125; 通过这些源码的解读，我们可以看到，要求他的子类必须实现这些方法，如果不实现就会报错，可以看出，我们必须实现这些方法。 ArrayList的源码分析构造方法 Constructor Constructor描述 ArrayList( ) 构造一个初始容量为10的空列表 ArrayList(int initialCapacity) 构造一个有指定容量的列表 ArrayList(Collection&lt;? extends E&gt; c) 构造一个包含指定集合的元素的列表，按照他们由集合的迭代器返回的顺序 案例演示空参构造1234567891011121314public class ArrayList&lt;E&gt;&#123; //默认的空容量的数组 里面啥都没有，也就是说长度是为0的 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; //集合真正存储数据的容器 transient Object[] elementData; //空参构造 public ArrayList() &#123; //赋值 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125;&#125; 有参的构造1234567891011121314151617181920//有参的构造public class ArrayList&lt;E&gt;&#123; //创建一个空的Object数组， 容量为0 private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //根据我们传递进来的值来进行判断 public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; //如果传过来的变量是大于0的话，就创建一个Object数组，容量为initialCapacity this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; //如果传递进来的参数为0 则 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; //如果不是0或者不大于0的话就会抛出异常 throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125; &#125;&#125; ArrayList(Collection&lt;? extends E&gt; c)这个构造123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//ArrayList(Collection&lt;? extends E&gt; c)public class ArrayList&lt;E&gt;&#123; private int size; private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; public ArrayList(Collection&lt;? extends E&gt; c) &#123; // 将构造方法中的参数转成数组 elementData = c.toArray(); //将数组的长度给size 看是不是等于0 if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) //再次进行判断 if (elementData.getClass() != Object[].class) //数组的创建和拷贝 elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. //如果是0 就把空数组的地址给集合存元素的数组 this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; //将集合转为数组的方法 public Object[] toArray() &#123; //调用数组工具类的方法 return Arrays.copyOf(elementData, size); &#125;&#125;class Arrays&#123; public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; //再次调用一个方法，返回一个数组 return (T[]) copyOf(original, newLength, original.getClass()); &#125; public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(&quot;unchecked&quot;) //三元运算符的运算 不管运算符的结果为啥 都会创建一个新的数组 新的数组的长度都和集合的size一样 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); //数组的拷贝 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); //返回新的数组 return copy; &#125;&#125; 添加方法 方法名 描述 public boolean add(E e) 将指定的元素追加到此列表的末尾。 public void add(int index, E element) 在此列表中的指定位置插入指定的元素。 public boolean addAll(Collection&lt;? extends E&gt; c) 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) 将指定集合中的所有元素插入到此列表中，从指定的位置开始。 public boolean add(E e)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//添加方法public class ArrayList&lt;E&gt;&#123; //默认的容量 private static final int DEFAULT_CAPACITY = 10; //默认容量为空的数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; private int size; private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit * 也就是说，创建数组的时候也会浪费一些空间，所以不是 2 的 31次方，需要减一个 8 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //1.0 先执行 public boolean add(E e) &#123; // 限制性size+1 ensureCapacityInternal(size + 1); // Increments modCount!! //0的时候是e ，size变成1 后面在遍历的时候比较容易遍历 elementData[size++] = e; //给元素赋值 return true; &#125; //执行ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); // elementData是空的 minCapcity = 1 这个是最小容量 private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; //1.0 传入一个 minCapacity = 1 private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; //判断elementData 是不是空的元素集 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //如果容量不超过10 就把10作为容量给返回 return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //如果minCapacity 超过10就返回minCapacity 这里返回的是DEFAULT_CAPACITY return minCapacity; &#125; //minCapacity 10 modCount 0 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; //modCount 1 // overflow-conscious code //判断minCapacity 容量和元素长度的大小 如果minCapacity 比较大 执行 grow(minCapacity); if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; //minCapacity 10 private void grow(int minCapacity) &#123; // overflow-conscious code //定义oldCapacity 为元素的长度，这里还是0 int oldCapacity = elementData.length; // &gt;&gt;右移 &lt;&lt; 左移 就相当于除以2的几次方 左移几位就相当于乘以2的几次方 //扩容的核心算法： 原容量的1.5倍 //newCapacity 新容量是就容量的1.5倍 ， 也就是0 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //判断新容量和 minCapacity 10 之间的关系 if (newCapacity - minCapacity &lt; 0) // newCapacity新的容量为 10 newCapacity = minCapacity; //判断是不是超过了最大的容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //如果是超过最大的容量， 就会采用更大的地址空间 newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: //调用copy数组复制 elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; //传递进来 minCapacity 超过了容量 if (minCapacity &lt; 0) // overflow //如果是直接小于 0 超过的比较多 他这个由于前面是 -8 所以添加的比较少的话不会是负数 不然的话就直接报错 throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? //后面的这段说明也就是仅仅限制在int的最大的数据类型 不会再进行扩容了 Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125;&#125; public void add(int index, E element)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//添加方法// 在指定的位置进行插入元素public void add(int index, E element)&#123; //默认的容量 private static final int DEFAULT_CAPACITY = 10; //默认容量为空的数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; private int size; private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; public void add(int index, E element) &#123; //校验索引 rangeCheckForAdd(index); //和之前的一样 ensureCapacityInternal(size + 1); // Increments modCount!! //开始拷贝元素 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 把添加的元素给我们的element elementData[index] = element; size++; &#125; //只有容量不够的时候才会调用核心扩容的方法 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; //判断所以是不是在集合范围之内 0 &lt; index &lt; size //如果不在这个范围之内会抛出一个数组越界异常 IndexOutOfBoundsException private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125;&#125; public boolean addAll(Collection&lt;? extends E&gt; c)123456789101112131415161718192021//添加方法// 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。public class ArrayList&lt;E&gt;&#123; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; //把 c 转化为数组 Object[] a = c.toArray(); //numNew 为数组的长度 int numNew = a.length; //依然调用我们的扩容的方法 ensureCapacityInternal(size + numNew); // Increments modCount //进行拷贝 System.arraycopy(a, 0, elementData, size, numNew); //重新计算size的值 ， 就是numNew的长度 size += numNew; //返回 值 return numNew != 0; &#125;&#125;//底层还是使用了System 的拷贝方法 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 public boolean addAll(int index, Collection&lt;? extends E&gt; c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ArrayList&lt;E&gt;&#123; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //校验索引是不是超过范围 rangeCheckForAdd(index); //将参数集合转换为数组 Object[] a = c.toArray(); //记录数据源的长度 int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount //numMoved 代表要移动元素的个数 数据目的（集合）的长度-调用addAll的第一个参数，就是那个索引 int numMoved = size - index; // 判断需要移动的个数是不是大于0 if (numMoved &gt; 0) //使用System中的方法arraycopy System.arraycopy(elementData, index, elementData, index + numNew, numMoved); //这个是拷贝数据源中的所有数据 System.arraycopy(a, 0, elementData, index, numNew); //更新size的值 size += numNew; //返回成功 return numNew != 0; &#125; //校验索引是不是超过范围的方法 private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; //总的来讲下面的这三个方法就是为了进行扩容 private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125;&#125; 修改方法public E set(int index, E element)123456789101112131415161718192021public class ArrayList&lt;E&gt;&#123; public E set(int index, E element) &#123; //检查索引 判断是不是越界 rangeCheck(index); //根据索引取出元素 E oldValue = elementData(index); //修改之后的元素存入到我们的elementData数组中 elementData[index] = element; //返回被替换的元素 return oldValue; &#125; private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; E elementData(int index) &#123; return (E) elementData[index]; &#125;&#125; 获取方法 public E get(int index)1234567891011121314151617public class ArrayList&lt;E&gt;&#123; public E get(int index) &#123; //判断索引是不是越界了 rangeCheck(index); //返回集合中索引对应的元素的值 return elementData(index); &#125; private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; E elementData(int index) &#123; return (E) elementData[index]; &#125;&#125; 转换方法toString（）将集合中的所有的元素转换为字符串，它是通过他的亲爷爷来进行调用的。 123456789101112131415161718192021222324252627public abstract class AbstractCollection&lt;E&gt;&#123; public String toString() &#123; //顺序遍历的迭代器 Iterator&lt;E&gt; it = iterator(); // 判断迭代器是不是有元素，如果没有 it.hasNext()是一个boolean类型的 if (! it.hasNext()) return &quot;[]&quot;; //创建一个StringBuilder（字符串的缓冲区） StringBuilder sb = new StringBuilder(); //追加了[ sb.append(&#x27;[&#x27;); // 无限循环 for (;;) &#123; //调用迭代器的方法取出元素且将光标向下移动 E e = it.next(); //三元判断 sb.append(e == this ? &quot;(this Collection)&quot; : e); if (! it.hasNext()) //没有元素 ，在最后面添加]，然后调用toString()把缓冲区的字符转换为字符串 return sb.append(&#x27;]&#x27;).toString(); //有元素就直接追加 sb.append(&#x27;,&#x27;).append(&#x27; &#x27;); &#125; &#125;&#125; 迭代器public interface Iterator 普通迭代器 源码同上（在讲toString方法的时候已经讲过基本操作，通过下面的两个案例分析源码） 案例一： 已知集合： List list &#x3D; new ArrayList&lt;&gt;();里面有三个元素：“hello”，“java”，“php”，使用迭代器遍历获取集合的每一个元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//迭代器public class ArrayList&lt;E&gt;&#123; //获取迭代器的方法 public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; //判断光标的值是不是size 也就是说是不是后面没有元素了 public boolean hasNext() &#123; return cursor != size; &#125; //一个实现了Iterator接口的内部类 不同迭代器的底层的源码是不一样的 private class Itr implements Iterator&lt;E&gt; &#123; //光标 默认值是 0 int cursor; // index of next element to return //记录 -1 int lastRet = -1; // index of last element returned; -1 if no such //将集合实际修改次数赋值给预期修改次数 int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; // @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; // 校验预期修改集合次数和实际修改集合次数是不是一致 checkForComodification(); //将光标赋值给 i int i = cursor; //判断光标的值是不是大于size 判断是不是没有元素了 if (i &gt;= size) throw new NoSuchElementException(); // 把集合存储数据的数组的地址赋值给该方法的局部变量 elementData Object[] elementData = ArrayList.this.elementData; //判断i是不是elementData的长度，如果条件满足，就会产生并发修改异常 if (i &gt;= elementData.length) throw new ConcurrentModificationException(); //光标向下移动 cursor = i + 1; //返回刚才存储的元素 return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; // final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;&#125; 案例二：List list &#x3D; new ArrayList&lt;&gt;();里面有三个元素：“hello”，“java”，“php”，使用迭代器遍历看看有没有php这个元素，如果有，就使用集合对象删除该元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148//迭代器22public class ArrayList&lt;E&gt;&#123; //查看add方法的目的就是为了查看记录集合修改次数的数据 public boolean add(E e) &#123; //这些之前都看过了 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; //真正删除元素的方法 private void fastRemove(int index) &#123; //集合的实际修改的次数会自增 //集合实际修改的次数为4 但是预期的修改次数为 3 modCount++; //计算集合要移动元素的个数 int numMoved = size - index - 1; if (numMoved &gt; 0) //移动元素的核心代码 System.arraycopy(elementData, index+1, elementData, index, numMoved); //让删除的元素位置为null，就是尽快让垃圾回收机制回收，避免占用内存 elementData[--size] = null; // clear to let GC do its work &#125; //集合删除元素的方法 public boolean remove(Object o) &#123; //判断要删除的元素是不是为null if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; //走else &#125; else &#123; //遍历集合 for (int index = 0; index &lt; size; index++) //要删除的元素和集合的每一个元素进行比较 如果是相等 if (o.equals(elementData[index])) &#123; //调用方法进行删除 fastRemove(index); return true; &#125; &#125; return false; &#125; public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such //将集合的实际修改次数赋值给预期修改次数 //获取迭代器的时候，expectedModCount也是3 int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; //判断集合的预期修改次数和实际的修改次数是不是一样 ， 如果一样的话就不会抛出异常 //删除之后，以为实际修改的次数和我们的预期修改次数是不一样的 if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;&#125;结论： 1. 集合每次调用add方法的时候，实际修改变量的次数都会自增12. 在获取迭代器的时候集合只会执行一次，将实际修改集合的次数赋值给预期的修改次数3. 集合在删除元素的时候也会针对实际修改次数的变量进行自增的操作，当我们再次调用next的时候就会产生并发的修改异常 案例三：已知集合List list &#x3D; new ArrayList&lt;&gt;();里面有三个元素： “hello”，“php”，“javase”，使用迭代器遍历集合看看有没有php这个元素，如果有，就使用集合对象删除该元素 123结论： 当要删除的元素在倒数第二个位置的时候 ， 不会产生并发修改异常原因： 因为在调用hasNext方法的时候 ， 光标的值和集合的长度一样 ， 那么就会返回false 因此就不会再去调用next方法获取集合的元素，既然不会调用next ， 也就意味着底层不会产生并发修改异常的问题 相当与在size的时候停止了，不会去比较预期修改次数和实际的修改次数 当要删除的元素在集合的倒数第二个位置的时候不会产生并发的修改异常，原因是因为在调用hasNext方法的时候，光标的值和集合的长度是一样的，就返回false，因此就不会调用下面的方法了，自然就不会产生并发修改异常了（是一个巧合）。 default void remove（） 心情随记，毕业设计没搞，啥都没做，好慌啊！！！","tags":["源码","面试题"]},{"title":"linux之Java基本环境的配置","path":"/2021/03/30/linux之Java基本环境的配置/","content":"linux服务器的基本java环境配置一、环境准备 二、服务器 三、配置java解压文件 1tar -zxvf jdk-8u231-linux-x64.tar.gz 配置环境变量 1vim /etc/profile 在文件的最后追加 123456# 这里是你自己解压后的文件的路径export JAVA_HOME=/environment/java/jdk1.8.0_231 export JAVA_BIN=$JAVA_HOME/binexport PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 刷新刚配置的变量 1source /etc/profile 查看配置好的java变量 四、配置tomcat到这java的环境变量就配置好了，接下来配置tomcat先使用9.0的版本配置解压文件tar -zxvf apache-tomcat-9.0.41.tar.gz 123cd apache-tomcat-9.0.41 # 进入tomcat文件夹cd bin # 进入bin目录./startup.sh # 开启tomcat 测试访问本地测试远程测试 五、配置nginx安装pcre 123456789# 解压文件tar -xvf pcre-8.00.tar.gz# 编译检查文件cd pcre-8.00./configure# 安装make &amp;&amp; make install# 查看安装pcre版本pcre-config --version 安装openssl zlib等其他依赖 1yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 安装nginx 123456789101112131415161718# 解压文件tar -xvf nginx-1.18.0.tar.gz# 编译检查文件cd nginx-1.18.0./configure# 安装make &amp;&amp; make install# 安装成功cd /usr/local/nginx/sbin # 里面由启动的脚本# 启动nginx./nginx# 如果不能启动nginx，输入下面的命令ln -s /usr/local/lib/libpcre.so.0 /lib64# 查看nginx是否启动 ps -ef | grep nginx # 访问nginx # 在默认的8080端口的话可能会冲突 ， 导致访问不到 http://ip:80/ nginx访问成功","tags":["linux","服务器"]},{"title":"Java的IO流","path":"/2021/03/28/Java的IO流/","content":"Java的IO流Java中有几种类型的流？ 按照流的方向： 分为输入流（inputStream）和输出流（outputStream） 按照实现功能进行分类的话： 节点流（可以从或向一个特定的（节点）读写数据。如FileReader）和处理流（是对一个已存在的流的连接和封装，通过封装的流的功能嗲用实现数据读写。如BuffferReader。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，成为流的链接。） 按照处理数据的单位： 字节流和字符流。字节流继承与InputStream和OutputStream,字符流继承与InputStreamReader和OutputStreamWriter。 字节流如何转化为字符流字节输入流转字符输入流通过InputStreamReader实现，该类的构造函数可以传入InputStream对象。 字节输出流转字符输出流通过OutputStreamWriter实现，该类的构造函数可以传入OutputStream对象。 字节流和字符流的区别字节流读取的时候，读到一个字节就返回一个字节；字符流使用了字节流读到一个或多个字节（中文对应的是两个，在UTF-8码表中是三个字节）时。先去查指定的编码表，将查到的字符返回。字节流可以处理所有类型数据。如图片、MP3、AVI视频文件，而字符流只能处理字符数据。只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都是字节流。字节流主要是操作byte类型的数据，以byte数组为准，主要操作类就是InputStream ， OutputStream。 字符流处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，而字节流处理单元为1个字节，操作字节和字节数组。所以字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符组成，所以它对多国语言支持性比较好！如果是音频文件、图片、歌曲，就使用字节流好点，如果是关系到中文（文本）的，使用字符流好点，在程序中一个字符相当于两个字节，java提供了Reader、Writer两个专门操作字符流的类。","tags":["面试题"]},{"title":"JavaSE常用的API","path":"/2021/03/27/JavaSE常用的API/","content":"JavaSE常用的APIMath.round(11.5)向上取整 此处是12 ， 如果是-11.5 ， 则取值为-11 switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上?Java5之前switch可以作用在byte、short、char、int，但是Java5中引入了枚举类型，也可以作用在enum上 ， 从Java7开始 ， 还可以作用在字符串上，但是长整型（long）截止目前为止的所有的版本中都是不可以的。 数组有没有 length() 方法？String 有没有 length() 方法？数组没有length（）方法，但是有length属性。String有length（）方法。 String 、StringBuilder 、StringBuffer 的区别？Java提供了两种类型的字符串： String和StringBuffer&#x2F;StringBuilder,他们都可以操作和存储字符串，区别如下： String是字符字符串也就是final类型的，也就意味着String引用的字符串内容是不能被改变的。 12String str = &quot;abc&quot;;str = &quot;bcd&quot;; 如上字符串str明明是可以改变的，其实不然，str仅仅是一个引用对象，它指向一个字符串对象“abc”，第二行代码的含义是让str重新指向一个新的字符串“bcd”对象，而“abc”对象并没有任何的改变，只不过该对象已经成为一个不可及的对象罢了。 StringBuffer&#x2F;StringBuilder表示的是字符串对象可以直接进行修改。 StringBuilder是Java5中引入的，它和StringBuilder的方法完全相同，区别在于它是单线程环境下使用的，因为它的所有的方法都是没有被sychronized修饰的，因此他的效率理论上也比StringBuffer高。 上次看到了71页","tags":["面试题"]},{"title":"JUC学习","path":"/2021/03/26/JUC学习/","content":"JUC学习源码+官方文档 面试高频问 什么是JUC java.util工具包 包、屏蔽同名 考虑分类 业务：无法通过普通的程序代码实现Thread Runnable 没有返回值 ， 效率相比于Callable比较低！ 我们更多使用Callable 线程和进程 线程和进程 如果不能使用一句话说出来的技术就是不扎实 进程： 它是一个程序 qq.exe music.exe 本身是一些程序的集合 .jar 一个进程往往可以包含多个线程，至少包含一个 ， java默认有两个线程，一个是GC线程，一个是main线程 线程： 开了一个进程 ， typora ， 可以写字 ， 自动保存（线程负责） Thread、Runnable 、 Callable 对于java而言 java真的可以开启线程吗？ 开不了的 123456789101112131415161718192021222324252627282930313233public synchronized void start() &#123; /** * This method is not invoked for the main method thread or &quot;system&quot; * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state &quot;NEW&quot;. */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group&#x27;s list of threads * and the group&#x27;s unstarted count can be decremented. */ group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125;&#125;//本地方法，是java调用的c++private native void start0(); 并发和并行 并发编程： 并发，并行 并发（多线程操作同一个资源） CPU只有1核 ， 在一瞬间只能处理一个事 ， 模拟出来多条线程 天下武功，唯快不破 ， 快速交替 并行（多个人一起行走） 多核CPU下，多个线程可以同时执行 123456789package com.timous.demo;public class Test1 &#123; public static void main(String[] args) &#123; //获取cpu的核数 //cpu密集型和IO密集型 System.out.println(Runtime.getRuntime().availableProcessors()); &#125;&#125; 并发编程的本质： 充分的利用CPU的资源 所有的公司都很看中的东西！ 企业是为了赚钱： 提高效率 裁员 找一个厉害的人，顶替三个不咋样的人 线程有几个状态 123456NEW, # 新生RUNNABLE, # 运行BLOCKED, #阻塞WAITING, # 等待TIMED_WAITING, # 超时等待 等多久然后不等了TERMINATED; # 终止 wait sleep 来自不同的类 wait 是object类的 sleep是Thread独有的 企业中不使用sleep wait会释放锁 ， sleep睡觉了，不会释放锁 使用的范围是不同的 wait必须在同步代码块之中使用 sleep是可以在任何的地方睡 wait不需要捕获异常（有中断异常） ， sleep是需要捕获异常的 Lock（锁 重点） 传统的Synchronized 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.timous.demo;//基本的买票例子/** * 真正的多线程开发 * 1.线程就是一个单独的资源类，没有任何一个附属的操作 属性，方法 */public class SaleTicket &#123; public static void main(String[] args) &#123; Tickets ticket = new Tickets(); //多个线程操作同一个资源类 把资源类丢给线程 //@FunctionalInterface 函数是接口 lambda (参数)-&gt;&#123; &#125; new Thread(()-&gt;&#123; for (int i = 1; i &lt; 110; i++) &#123; ticket.sale(); &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 1; i &lt; 110; i++) &#123; ticket.sale(); &#125; &#125;,&quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 1; i &lt; 110; i++) &#123; ticket.sale(); &#125; &#125;,&quot;C&quot;).start(); &#125;&#125;/*class MyThead implements Runnable&#123; @Override public void run() &#123; &#125;&#125;*///资源类 OOP 基本的面向对象 降低耦合性// 下面只防止属性和方法class Tickets&#123; private int number = 100 ; //买票的方式 //synchronized 本质就是队列和锁 锁 ， 一个是对象 ， 一个是class public synchronized void sale()&#123; if(number &gt; 0)&#123; number--; System.out.println(Thread.currentThread().getName()+&quot;卖出了&quot;+(100-number)+&quot;张票！，剩余&quot;+number+&quot;张票&quot;); &#125; &#125;&#125; lock 接口 ReenTrantLock 可重入锁 ReentrantReadWriteLock.ReadLock 读锁 ReentrantReadWriteLock.WriteLock 写锁 12非公平锁 十分不公平，可以插队 （默认）公平锁 十分公平 ， 不能插队 3s 3h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.timous.demo;//基本的买票例子import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 真正的多线程开发 * 1.线程就是一个单独的资源类，没有任何一个附属的操作 属性，方法 * * Lock l = ...; l.lock(); try &#123; // access the resource protected by this lock &#125; finally &#123; l.unlock(); &#125; */public class SaleTicket02 &#123; public static void main(String[] args) &#123; Tickets2 ticket = new Tickets2(); //多个线程操作同一个资源类 把资源类丢给线程 //@FunctionalInterface 函数是接口 lambda (参数)-&gt;&#123; &#125; new Thread(()-&gt;&#123; for (int i = 1; i &lt; 110; i++) &#123; ticket.sale(); &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 1; i &lt; 110; i++) &#123; ticket.sale(); &#125; &#125;,&quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 1; i &lt; 110; i++) &#123; ticket.sale(); &#125; &#125;,&quot;C&quot;).start(); &#125;&#125;/*class MyThead implements Runnable&#123; @Override public void run() &#123; &#125;&#125;*///资源类 OOP 基本的面向对象 降低耦合性// 下面只防止属性和方法//lockclass Tickets2&#123; private int number = 100 ; Lock lock = new ReentrantLock(); /** * 非公平锁 十分不公平，可以插队 （默认） * 公平锁 十分公平 ， 不能插队 3s 3h * * public ReentrantLock() &#123; * sync = new NonfairSync(); 非公平锁 * &#125; * * public ReentrantLock(boolean fair) &#123; 可以设置是否为公平锁 * sync = fair ? new FairSync() : new NonfairSync(); * &#125; */ /** * 三部曲 * new 锁 * * 加锁 * * 解锁 */ public void sale()&#123; lock.lock(); try &#123; // 业务代码 if(number &gt; 0)&#123; number--; System.out.println(Thread.currentThread().getName()+&quot;卖出了&quot;+(100-number)+&quot;张票！，剩余&quot;+number+&quot;张票&quot;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; Lock和Synchronized的区别： Synchronized是一个内置的java关键字 Lock是一个java类 Synchronized无法判断获取锁的状态 Lock可以判断是否获取到了锁 Synchronized会自动释放锁 Lock需要手动释放锁如果不释放锁会造成死锁 Synchronized 线程2（会一直等待） 线程1（获得锁） 就算是1阻塞，2也会一直等待 ， 如果是lock不会一直等待lock.tryLock() Synchronized 可重入锁 不可以中断 非公平 Lock 可重入锁 可以判断锁 ， 非公平（可以自己设置） Synchronized 适合锁少量的代码同步问题 Lock 适合锁大量的代码 锁是什么 ， 如何判断锁 锁的是谁 生产者和消费者问题Synchronized 和 lock 生产者和消费者问题Synchronized有虚假等待12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.timous.pc;/** * 线程交替执行 通信问题 生产者和消费者问题 * 等待唤醒 通知唤醒 * A B 操作同一个变量 num = 0 * A + 1 B - 1 */public class Test &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;B&quot;).start(); &#125;&#125;//等待 业务 通知class Data&#123; private int num = 0; //+1 public synchronized void increment() throws InterruptedException &#123; if(num!=0)&#123; //等待操作 wait(); &#125; num++; System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+num); //通知其他线程 ， +1完毕 notifyAll(); &#125; //-1 public synchronized void decrement() throws InterruptedException &#123; if(num==0)&#123; //等待操作 wait(); &#125; num--; System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+num); //通知其他线程 ， -1完毕 notifyAll(); &#125;&#125; 测试结果： 问题存在 A B C D 多的线程是不是还是安全的？ 在有c或者是D的时候回出现问题 ， 会出现虚假唤醒，应该使用while ， 防止虚假唤醒 测试： 防止虚假唤醒的代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.timous.pc;/** * 线程交替执行 通信问题 生产者和消费者问题 * 等待唤醒 通知唤醒 * A B 操作同一个变量 num = 0 * A + 1 B - 1 */public class Test &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;C&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;D&quot;).start(); &#125;&#125;//等待 业务 通知class Data&#123; private int num = 0; //+1 public synchronized void increment() throws InterruptedException &#123; while(num!=0)&#123; //等待操作 wait(); &#125; num++; System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+num); //通知其他线程 ， +1完毕 notifyAll(); &#125; //-1 public synchronized void decrement() throws InterruptedException &#123; while(num==0)&#123; //等待操作 wait(); &#125; num--; System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+num); //通知其他线程 ， -1完毕 notifyAll(); &#125;&#125; JUC版的生产者和消费者 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.timous.pc;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 线程交替执行 通信问题 生产者和消费者问题 * 等待唤醒 通知唤醒 * A B 操作同一个变量 num = 0 * A + 1 B - 1 */public class Test1 &#123; public static void main(String[] args) &#123; Data1 data = new Data1(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;C&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;D&quot;).start(); &#125;&#125;//等待 业务 通知class Data1&#123; private int num = 0; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); //+1 public void increment() throws InterruptedException &#123; try &#123; lock.lock(); while(num!=0)&#123; //等待操作 condition.await();/* condition.await(); //等待 condition.signal(); //唤醒*/ &#125; num++; System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+num); //通知其他线程 ， +1完毕 condition.signalAll(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; //-1 public void decrement() throws InterruptedException &#123; try &#123; lock.lock(); //业务代码 while(num==0)&#123; //等待操作 condition.await(); &#125; num--; System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+num); //通知其他线程 ， -1完毕 condition.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; //做完释放锁 lock.unlock(); &#125; &#125;&#125; 任何的新技术 绝对会只是覆盖原来的技术 condition的优势 代码测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.timous.pc;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * A 执行玩 调用B b之后调用C */public class Test2 &#123; public static void main(String[] args) &#123; Date3 date3 = new Date3(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; date3.printA(); &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; date3.printB(); &#125; &#125;,&quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; date3.printC(); &#125; &#125;,&quot;C&quot;).start(); &#125;&#125;//资源类class Date3&#123; private Lock lock = new ReentrantLock(); private int num = 1; private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); public void printA()&#123; try &#123; lock.lock(); //判断 业务 执行 通知 while (num != 1)&#123; condition1.await(); &#125; System.out.println(Thread.currentThread().getName()+&quot;===AAAAAAAAAA&quot;); // 唤醒指定的值 num = 2; condition2.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printB()&#123; try &#123; lock.lock(); while(num != 2)&#123; condition2.await(); &#125; System.out.println(Thread.currentThread().getName()+&quot;===BBBBB&quot;); num = 3; condition3.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printC()&#123; try &#123; lock.lock(); while(num != 3 )&#123; condition3.await(); &#125; System.out.println(Thread.currentThread().getName()+&quot;===CCCCCCC&quot;); num = 1; condition1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;//生产线 购物 下单 支付 交易 物流 思路 &#125; 8锁现象如何判断锁 ， 锁的是谁 对象 和 class 深刻理解锁 第一组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.timous.lock8;import java.util.concurrent.TimeUnit;/** * 8锁 就是关于锁的8个问题 * 1. 标准情况下是打电话还是发短息 发短信 打电话 * 2.发短信延时四秒是哪个先 发短信 打电话 */public class Test1 &#123; public static void main(String[] args) &#123; Phone1 phone = new Phone1(); //这个是先调用的是错误的 是有锁的问题 new Thread(()-&gt;&#123; phone.sendmsm(); &#125;,&quot;A&quot;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; phone.call(); &#125;,&quot;B&quot;).start(); &#125;&#125;class Phone1&#123; //synchronized 修饰的对象锁的是方法的调用者 //两个方法用的是同一个锁 谁先拿到谁执行 public synchronized void sendmsm()&#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; public synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125;&#125; 第二组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.timous.lock8;import java.util.concurrent.TimeUnit;/** * 8锁 就是关于锁的8个问题 * 3. 执行完之后是发短信还是 hello hello是一个普通的方法 因为hello没有锁，可以直接使用 * 4. 使用两个对象的时候 ， 两个对象分别调用打电话和发短信的时候 会是打电话 * 因为 synchronized锁的是方法的调用者 相当于是两把锁 ，不需要去进行 争夺锁 */public class Test2 &#123; public static void main(String[] args) &#123; //两个对象 Phone2 phone = new Phone2(); Phone2 phone1 = new Phone2(); Phone2 phone2 = new Phone2(); //这个是先调用的是错误的 是有锁的问题 new Thread(()-&gt;&#123; phone1.sendmsm(); &#125;,&quot;A&quot;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; phone2.call(); &#125;,&quot;B&quot;).start(); &#125;&#125;class Phone2&#123; //synchronized 修饰的对象锁的是方法的调用者 //两个方法用的是同一个锁 谁先拿到谁执行 public synchronized void sendmsm()&#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; public synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125; //这里没有锁 ， 因此在调用的时候可以直接输出 ， 不受锁的影响 public void hello()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 第三组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.timous.lock8;import java.util.concurrent.TimeUnit;/** * 8锁 就是关于锁的8个问题 * 5.增加两个静态的同步方法 是先打电话还是先发短信 是先发短信 跟前面的是不一样的 * 6. 两个对象 两个方法 这个时候的话 还是发短信 不是打电话 * 因为锁的是模板 不是方法的调用者 两个的class是一样的锁的是class */public class Test3 &#123; public static void main(String[] args) &#123; //两个对象 Phone3 phone3 = new Phone3(); Phone3 phone4 = new Phone3(); //这个是先调用的是错误的 是有锁的问题 new Thread(()-&gt;&#123; phone3.sendmsm(); &#125;,&quot;A&quot;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; phone4.call(); &#125;,&quot;B&quot;).start(); &#125;&#125;//Phone3 只有唯一的class 全局唯一class Phone3&#123; //static 在设置的时候锁的是class 类一加载就有了 是模板 public static synchronized void sendmsm()&#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; public static synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125; //这里没有锁 ， 因此在调用的时候可以直接输出 ， 不受锁的影响 public void hello()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 第四组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.timous.lock8;import java.util.concurrent.TimeUnit;/** * 8锁 就是关于锁的8个问题 * 7. 一个静态同步方法 一个普通的同步方法 先打电话 然后 再发短信 * 8.两个对象，输出的是啥 依然是打电话 然后发短信 */public class Test4 &#123; public static void main(String[] args) &#123; //两个对象 Phone4 phone = new Phone4(); Phone4 phone1 = new Phone4(); //这个是先调用的是错误的 是有锁的问题 new Thread(()-&gt;&#123; phone.sendmsm(); &#125;,&quot;A&quot;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; phone1.call(); &#125;,&quot;B&quot;).start(); &#125;&#125;//Phone3 只有唯一的class 全局唯一class Phone4&#123; //锁的类模板 //静态的同步方法 public static synchronized void sendmsm()&#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; //普通的同步方法 //锁的是方法的调用者 public synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125; //这里没有锁 ， 因此在调用的时候可以直接输出 ， 不受锁的影响 public void hello()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 小结new this 具体的一个手机 static 是唯一的一个模板 集合类不安全单线程Array安全 List不安全 12345678910111213141516171819202122232425262728293031323334353637package com.timous.unsafe;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.UUID;import java.util.concurrent.CopyOnWriteArrayList;/** * java.util.ConcurrentModificationException 并发修改异常 * 并发下arraylist是不安全的 解决方案 Vector 默认就是安全的 synchronized 解决 * 1. List&lt;String&gt; list = new Vector&lt;&gt;(); 就不会报错了 不要回答这个 @since JDK1.0 * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); * 3. List&lt;String&gt; list = new CopyOnWriteArrayList(); * CopyOnWriteArrayList 比 Vector 好在哪里 Vector 是synchronized 的 所以效率会比较低 */public class ListTest &#123; public static void main(String[] args) &#123;/* List&lt;String&gt; lists = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;); lists.forEach(System.out::println);*/ //collections // CopyOnWrite 写入时复制 COW 计算机程序设计领域的一种优化策略 //多个线程调用的时候 ， list是唯一的 读取的是一个固定的 ， 写入的时候可能会出现覆盖的操作 //写入的时候避免覆盖造成数据问题 写入的时候 复制出来 写完之后吧它set回去 //读写分离 mycat 这些都是读些分离的出来 List&lt;String&gt; list = new CopyOnWriteArrayList(); for (int i = 1; i &lt;= 10; i++) &#123;// list.add(UUID.randomUUID().toString().substring(0,5));// System.out.println(list); new Thread(()-&gt;&#123; list.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(list); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; Set不安全 12345678910111213141516171819202122232425262728package com.timous.unsafe;import java.util.Collections;import java.util.HashSet;import java.util.Set;import java.util.UUID;import java.util.concurrent.CopyOnWriteArraySet;/** * 同理可证 java.util.ConcurrentModificationException 并发修改异常 * Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); * Set&lt;String&gt; set = new CopyOnWriteArraySet(); */public class SetTest &#123; public static void main(String[] args) &#123; //Set&lt;String&gt; set = new HashSet&lt;&gt;();// Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); Set&lt;String&gt; set = new CopyOnWriteArraySet(); for (int i = 1; i &lt;= 30; i++) &#123; new Thread(()-&gt;&#123; set.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(set); &#125; , String.valueOf(i)).start(); &#125; &#125;&#125; hashset的底层是啥HashMap ， 就是用了hashmap的key 1234//set的本质是 map 的 key是无法重复的 PRESENT 是一个固定的数值public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; Map不安全 12345678910111213141516171819202122232425262728293031323334package com.timous.unsafe;import java.util.Collections;import java.util.HashMap;import java.util.Map;import java.util.UUID;import java.util.concurrent.ConcurrentHashMap;/** * static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 * 16 默认的容量 是通过位运算来进行的 *static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; * 最大的容量 也是通过位运算来进行的 *static final float DEFAULT_LOAD_FACTOR = 0.75f; * 加载因子 ， 默认是0.75 * * java.util.ConcurrentModificationException 依然会出现并发安修改异常 企业的开发一般都是有并发问题的 * 1. Map&lt;String, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;()); * 2. Map&lt;String, Object&gt; map = new ConcurrentHashMap&lt;&gt;(); */public class MapTest &#123; public static void main(String[] args) &#123; //map是这样用的吗 默认等价于什么 //工作中不用这个 默认的是原始的参数 0.75 默认的加载因子 16// Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();// Map&lt;String, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;()); Map&lt;String, Object&gt; map = new ConcurrentHashMap&lt;&gt;(); //加载因子 初始化容量 for (int i = 1; i &lt;= 30; i++) &#123; new Thread(()-&gt;&#123; map.put(Thread.currentThread().getName() , UUID.randomUUID().toString().substring(0 ,5)); System.out.println(map); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; Callable 特点 可以有返回值 可以跑出异常 方法不同 run是普通的Runnable 这个是call 关系 代码实现12345678910111213141516171819202122232425262728293031323334353637package com.timous.Callable;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //这种方式不要用了// new Thread(new MyThread()).start();// new Thread().start(); //怎么启动callable MyThread myThread = new MyThread(); //适配类 FutureTask futureTask = new FutureTask(myThread); //会打印几个call 结果会被缓存 也就是直接 去打印一次 第二次就在缓存里面了 new Thread(futureTask , &quot;A&quot;).start(); new Thread(futureTask , &quot;B&quot;).start(); Integer o = (Integer) futureTask.get(); //返回callable的结果 //get方法可能会产生阻塞 把它放大最后 或者使用异步通信 System.out.println(o); &#125;&#125;//class MyThread implements Runnable&#123;////// @Override// public void run() &#123;//// &#125;//&#125;class MyThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(&quot;call()&quot;); return 1024; &#125;&#125; 细节： 有缓存 结果可能需要等待 ， 阻塞 常用的辅助类 CountDownLatch 允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。 123456789101112131415161718192021222324package com.timous.add;import java.util.concurrent.CountDownLatch;//技术器public class CountDownLatchTest &#123; public static void main(String[] args) throws InterruptedException &#123; //总数是6 倒计时 //必须要执行任务的时候用这个 CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i &lt;= 6; i++) &#123; new Thread(()-&gt;&#123; countDownLatch.countDown(); // -1 System.out.println(Thread.currentThread().getName()+&quot;走了！！！&quot;); &#125;).start(); &#125; countDownLatch.await(); //等待计数器归0 然后向下执行 System.out.println(&quot;关门！！！！&quot;); &#125;&#125; 原理: countDownLatch.countDown(); &#x2F;&#x2F; -1 countDownLatch.await(); &#x2F;&#x2F;等待计数器归0 然后向下执行 每次线程调用countDown的时候计数器会减一，假设计数器变为，countDownLatch.await()就会被唤醒执行下面的操作 CyclicBarrier 加法计数器 允许一组线程全部等待彼此达到共同屏障点的同步辅助。 循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。 屏障被称为循环 ，因为它可以在等待的线程被释放之后重新使用。 12345678910111213141516171819202122232425262728package com.timous.add;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierTest &#123; /** * 集齐7个龙珠 然后完成任务 */ public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123; System.out.println(&quot;成功&quot;); &#125;); for (int i = 1; i &lt;= 7; i++) &#123; //lambda能不能操作到变量 i 不能 通过 final 来进行获取 final int temp = i; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + &quot;收集了&quot; +temp+&quot;颗龙珠&quot;); //这个时候回报错 try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;,&quot;A&quot;).start(); &#125; &#125;&#125; SemaPhore 抢车位： 6 量车 3个车位 12345678910111213141516171819202122232425262728293031package com.timous.add;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;public class SemaPhoreTest &#123; public static void main(String[] args) &#123; //线程数量 停车位 Semaphore semaphore = new Semaphore(3); for (int i = 1; i &lt;= 6; i++) &#123; /** * acquire() 得到 * release() 释放 */ new Thread(()-&gt;&#123; try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName()+&quot;得到了车位&quot;); TimeUnit.SECONDS.sleep(2); System.out.println(Thread.currentThread().getName()+&quot;离开了车位&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; semaphore.release(); &#125; &#125; , String.valueOf(i)).start(); &#125; &#125;&#125; 原理： acquire() 得到 已经满了 ， 等待被释放 -1 release() 释放 会将当前的信号量释放 + 1 然后唤醒等待的操作 作用： 多个共享资源互斥的使用！ 控制最大的线程数 读写锁ReadWriteLock 读：可以被多个线程同时读 写： 只能有一个线程去写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.timous.rw;import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * 独占锁 写锁 一次只能被一个线程使用 * 共享锁 读锁 一次可以被多个线程进行读写的 * ReadWriteLock * 读 - 写 不能共存 * 读 - 读 可以共存 * 写 - 写 不能共存 */public class ReadWriteLockTest &#123; public static void main(String[] args) &#123; MyCache myCache = new MyCache(); //写入 for (int i = 1; i &lt;= 5; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; myCache.put(temp+&quot;&quot; , temp+&quot;&quot;); &#125; , String.valueOf(i)).start(); &#125; //读取 for (int i = 1; i &lt;= 5; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; myCache.get(temp+&quot;&quot;); &#125; , String.valueOf(i)).start(); &#125; &#125;&#125;class MyCache1&#123; private volatile Map&lt;String , Object&gt; map = new HashMap&lt;&gt;(); //存 public void put(String key, Object value)&#123; System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key); map.put(key , value); System.out.println(Thread.currentThread().getName() + &quot;写入ok&quot;); &#125; //取 public void get(String key)&#123; System.out.println(Thread.currentThread().getName() + &quot;读出&quot; + key); map.get(key); System.out.println(Thread.currentThread().getName() + &quot;读出ok&quot;); &#125;&#125;/** * 加锁 */class MyCache&#123; private volatile Map&lt;String , Object&gt; map = new HashMap&lt;&gt;(); //读写锁 相当于是更加细粒度的操作 private ReadWriteLock readWriteLock= new ReentrantReadWriteLock(); //存 public void put(String key, Object value)&#123; try &#123; readWriteLock.writeLock().lock(); System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key); map.put(key , value); System.out.println(Thread.currentThread().getName() + &quot;写入ok&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; readWriteLock.writeLock().unlock(); &#125; &#125; //取 public void get(String key)&#123; try &#123; readWriteLock.readLock().lock(); System.out.println(Thread.currentThread().getName() + &quot;读出&quot; + key); map.get(key); System.out.println(Thread.currentThread().getName() + &quot;读出ok&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; readWriteLock.readLock().unlock(); &#125; &#125;&#125; 阻塞队列 BlockingQueue ： 不是新的东西 什么情况下 ， 我们会如何使用阻塞队列： 多线程 线程池并发处理 学会使用队列.添加 移除 四组API 抛出异常 不会抛出异常‘ 阻塞等待 超时等待 方式 抛出异常 有返回值 ， 不抛出异常 阻塞等待 超时等待 添加 add offer put offer带参数 移除 remove poll take poll带参数 检测队首元素 element peek 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.timous.bq;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.TimeUnit;public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; test3(); &#125; /** * 抛出异常 */ public static void test()&#123; //队列的大小 ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(arrayBlockingQueue.add(&quot;a&quot;)); System.out.println(arrayBlockingQueue.add(&quot;b&quot;)); System.out.println(arrayBlockingQueue.add(&quot;c&quot;)); System.out.println(&quot;-------------------------&quot;); System.out.println(arrayBlockingQueue.element());// System.out.println(arrayBlockingQueue.add(&quot;d&quot;)); System.out.println(arrayBlockingQueue.remove()); System.out.println(arrayBlockingQueue.remove()); System.out.println(arrayBlockingQueue.remove()); System.out.println(arrayBlockingQueue.remove()); &#125; /** * 有返回值 但是不抛出异常 */ public static void test1() &#123; //队列的大小 ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(arrayBlockingQueue.offer(&quot;a&quot;)); System.out.println(arrayBlockingQueue.offer(&quot;b&quot;)); System.out.println(arrayBlockingQueue.offer(&quot;c&quot;));// System.out.println(arrayBlockingQueue.offer(&quot;d&quot;)); System.out.println(arrayBlockingQueue.peek()); //返回队首的元素 System.out.println(arrayBlockingQueue.poll()); System.out.println(arrayBlockingQueue.poll()); System.out.println(arrayBlockingQueue.poll()); System.out.println(arrayBlockingQueue.poll()); // null 不抛出异常 &#125; /** * 等待阻塞 * 一直 * 等待超时 */ public static void test2() throws InterruptedException &#123; //队列的大小 ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3); // 一直阻塞 arrayBlockingQueue.put(&quot;a&quot;); arrayBlockingQueue.put(&quot;b&quot;); arrayBlockingQueue.put(&quot;c&quot;);// arrayBlockingQueue.put(&quot;d&quot;);//队列没有位置了会一直等待 一直阻塞 下面会一直等待 System.out.println(arrayBlockingQueue.take()); System.out.println(arrayBlockingQueue.take()); System.out.println(arrayBlockingQueue.take()); &#125; /** * 超时退出 */ public static void test3() throws InterruptedException &#123; //队列的大小 ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(arrayBlockingQueue.offer(&quot;a&quot;)); System.out.println(arrayBlockingQueue.offer(&quot;b&quot;)); System.out.println(arrayBlockingQueue.offer(&quot;c&quot;)); System.out.println(arrayBlockingQueue.offer(&quot;d&quot; , 2 , TimeUnit.SECONDS));//超过2秒直接返回没有加入false System.out.println(arrayBlockingQueue.poll(2, TimeUnit.SECONDS)); System.out.println(arrayBlockingQueue.poll(2, TimeUnit.SECONDS)); System.out.println(arrayBlockingQueue.poll(2, TimeUnit.SECONDS)); System.out.println(arrayBlockingQueue.poll(2, TimeUnit.SECONDS));//超时直接返回null &#125;&#125; SynchronousQueue 进去一个元素 必须取出来然后再在里面放置元素 1234567891011121314151617181920212223242526272829303132333435363738package com.timous.bq;import java.util.concurrent.SynchronousQueue;/** * 同步队列的测试 */public class SynchronousQueueTest &#123; public static void main(String[] args) &#123; /** * 和其他的是不一样的 ， 我们这个是不存储元素的 只要put 一个元素 ， 必须从里面先取出来一个元素，否则 不能再加入元素 */ SynchronousQueue synchronousQueue = new SynchronousQueue&lt;String&gt;(); //同步队列 //放入值 new Thread(()-&gt;&#123; try &#123; System.out.println(Thread.currentThread().getName()+&quot;put 1&quot;); synchronousQueue.put(&quot;1&quot;); System.out.println(Thread.currentThread().getName()+&quot;put 1&quot;); synchronousQueue.put(&quot;2&quot;); System.out.println(Thread.currentThread().getName()+&quot;put 1&quot;); synchronousQueue.put(&quot;3&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; , &quot;t1&quot;).start(); //取出值 new Thread(()-&gt;&#123; try &#123; System.out.println(Thread.currentThread().getName()+&quot;====&quot;+synchronousQueue.take()); System.out.println(Thread.currentThread().getName()+&quot;====&quot;+synchronousQueue.take()); System.out.println(Thread.currentThread().getName()+&quot;====&quot;+synchronousQueue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; , &quot;t2&quot;).start(); &#125;&#125; 学了技术不会用 ， 看的少 ， 我们要多看多学 ， 多看视频 ， 不敲代码也可以 线程池（重点） 池化技术 程序的运行 ， 本质： 占用系统资源 ！ 优化资源的使用 ， 每次在创建线程和销毁的时候都会耗费大量资源 - 》 池化技术 线程池 连接池 内存池 对象池 jdbc 最大的 最小的 不让不停地开和关 池化技术： 实现准备好一些资源 ， 有人要用的话 ， 就到哪去拿 ， 用完之后 ， 再还给它 默认是：2 max 根据电脑去设置 cpu密集和io密集 线程池的好处： 降低资源的消耗 提高响应的速度 方便管理 &#x3D;&#x3D;线程可以服用 ， 可以控制最大并发数 ， 可以管理我们的线程&#x3D;&#x3D; 线程池三大方法、七大参数 、四种拒绝策略 [强制] 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则 ， 规避资源的耗尽的风险 ， 说明： Executors返回的线程池对象的弊端如下： FixedThreadPool 和SingleThreadPool 允许请求队列长度为Integer.MAX_VALUE,可能会堆积大量的请求 ， 从而导致OOM CacheThreadPool和ScheduledThreadPool 允许创建线程数量为Integer.MAX_VALUE ， 可能会创建大量的线程 ， 导致OOM 三大方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.timous.pool;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Executors * 使用了线程池之后， 要使用线程池创建 */public class Test01 &#123; public static void main(String[] args) &#123;// ExecutorService executorService = Executors.newSingleThreadExecutor();//创建单个线程 ExecutorService executorService = Executors.newFixedThreadPool(5);//创建一个固定数量的线程池// ExecutorService executorService = Executors.newCachedThreadPool();//遇强则强 ， 遇弱则弱 try &#123; for (int i = 1; i &lt;= 100; i++) &#123; executorService.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;ok&quot;); &#125;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; executorService.shutdown(); &#125; &#125;&#125;//newSingleThreadExecutorpublic static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;//newFixedThreadPoolpublic static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;//newCachedThreadPoolpublic static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;//本质：ThreadPoolExecutorpublic ThreadPoolExecutor(int corePoolSize, //核心线程池带下 int maximumPoolSize,//最大的线程池大小 long keepAliveTime,//超时没有人调用就会释放 TimeUnit unit,//超时的单位 BlockingQueue&lt;Runnable&gt; workQueue,// 阻塞队列 ThreadFactory threadFactory, // 线程工厂 创建线程的 一般不用动 RejectedExecutionHandler handler // 拒绝策略 ) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 七大参数和四种拒绝策略1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.timous.pool;import java.util.concurrent.Executors;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Test2 &#123; public static void main(String[] args) &#123; /** * 自定义线程池 */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 5, 3, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(3), Executors.defaultThreadFactory(),// new ThreadPoolExecutor.CallerRunsPolicy()//那来的去哪里// new ThreadPoolExecutor.AbortPolicy() // 银行满了 ， 还有人进来 如果队列满了 ， 还有人进来 ， 就抛出异常// new ThreadPoolExecutor.DiscardOldestPolicy() // 队列满了 ， 不会抛出异常 ， 丢掉任务 new ThreadPoolExecutor.DiscardOldestPolicy() // 和第一个尝试竞争 ， 如果成功就会执行 ， 不成功就会丢掉 ， 不会抛出异常 ); /** * 测试 */ try &#123; // 最大 ： Deque + max //超过 java.util.concurrent.RejectedExecutionException 会跑出异常 for (int i = 1; i &lt;= 9; i++) &#123; threadPoolExecutor.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;ok&quot;); &#125;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; threadPoolExecutor.shutdown(); &#125; &#125;&#125; 小结和拓展最大的线程池如何去定义 最大线程到底该如何定义： CPU密集型 4核 4条线程同时执行 几核的CPU就定义为几 ， 可以保证CPU的效率最高Runtime.getRuntime().availableProcessors() IO密集型 程序 15 个大型任务 ， IO十分占用资源 ， 至少留15个线程 判断程序中十分耗IO的线程有多少个 ， 只要大于这个就行 ， 一般设置为两倍 ， 不会造成系统的阻塞 四大函数式接口（重要）新时代的程序员 ， 必须要会的操作 lambda表达式 ， 链式编程 ， 函数式接口 ， Stream流式计算 函数式接口是什么东西？只有一个方法的接口 123456789@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125;//会有很多的FunctionalInterface//简化编程模型 ， 在新版本的框架 ， 底层大量应用//消费者类的函数式接口public void forEach(Consumer&lt;? super E&gt; action) 代码测试：Function函数式接口 123456789101112131415161718192021222324252627package com.timous.function;import java.util.function.Consumer;import java.util.function.Function;/** * Function * 有一个输入参数 ， 有一个输出 */public class Test01 &#123; public static void main(String[] args) &#123;// // 输出输入的值// Function function = new Function&lt;String , String&gt;() &#123;// @Override// public String apply(String str) &#123;// return str;// &#125;// &#125;;//// System.out.println(function.apply(&quot;123&quot;)); Function function = (str) -&gt; &#123; return &quot;123&quot;; &#125;; System.out.println(function.apply(&quot;123&quot;)); &#125;&#125; Predict断定性接口 1234567891011121314151617181920package com.timous.function;import java.util.function.Predicate;public class Test02 &#123; public static void main(String[] args) &#123;// Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;()&#123;// //判断字符串是够为空// @Override// public boolean test(String str) &#123;// return str.isEmpty();// &#125;// &#125;; Predicate&lt;String&gt; predicate = (str)-&gt;&#123; return str.isEmpty(); &#125;; System.out.println(predicate.test(&quot;123&quot;)); &#125;&#125; Consumer 消费型接口 1234567891011121314151617181920212223package com.timous.function;import java.util.function.Consumer;/** * Consumer 消费型接口 只有输入 ， 没有返回值 */public class Test03 &#123; public static void main(String[] args) &#123;// Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;()&#123;// @Override// public void accept(String str) &#123;// System.out.println(str);// &#125;// &#125;; Consumer&lt;String&gt; consumer = (str)-&gt;&#123; System.out.println(str); &#125;; consumer.accept(&quot;123212&quot;); &#125;&#125; 可以打印字符串 Supplier供给型接口 123456789101112131415161718package com.timous.function;import java.util.function.Supplier;public class Test04 &#123; public static void main(String[] args) &#123;// Supplier supplier = new Supplier&lt;Integer&gt;()&#123;// @Override// public Integer get() &#123;// return 1024;// &#125;// &#125;; Supplier supplier = ()-&gt;&#123; return 1024; &#125;; System.out.println(supplier.get()); &#125;&#125; Stream流式计算什么是Stream流式计算 存储 计算存储： mysql 等 本质是用来存储的 计算： 我们要交给流来操作 Scales 123456789101112131415161718192021222324252627282930313233package com.timous.stream;import java.util.Arrays;import java.util.List;import java.util.stream.Stream;/** * 题目要求： 一分钟内完成此题，只能用一行代码来实现 * 现在有5个用户 ， 筛选 * 1. ID 必须是偶数 * 2. 年龄必须大于23岁 * 3. 用户名转为大写字母 * 4. 用户名字母倒着排序 * 5. 只输出一个用户 */public class Test &#123; public static void main(String[] args) &#123; User user1 = new User(1 , &quot;a&quot;,21); User user2 = new User(2 , &quot;b&quot;,22); User user3 = new User(3 , &quot;c&quot;,23); User user4 = new User(4 , &quot;d&quot;,24); User user5 = new User(6, &quot;e&quot;,25); //集合就是存储 List&lt;User&gt; list = Arrays.asList(user1 , user2 , user3 , user4 , user5); //计算就是交给Stream流 来进行的 //链式编程 list.stream() .filter(u-&gt;&#123;return u.getId()%2==0;&#125;) .filter(u-&gt;&#123;return u.getAge() &gt; 23;&#125;) .map(u-&gt;&#123;return u.getName().toUpperCase();&#125;) .sorted((u1 , u2)-&gt;&#123; return u2.compareTo(u1);&#125;) .limit(1) .forEach(System.out::println); &#125;&#125; ForkJoin什么是ForkJoin在jdk1.7就有了 ， 开始执行任务 ， 提高效率 ， 大数据量 大数据： 把大人物拆分成为小任务 ForkJoin工作特点： 工作窃取 例子 测试123456789101112131415161718192021222324252627282930313233343536373839404142package com.timous.forkjoin;import java.util.concurrent.RecursiveTask;/** * forkjoin stream * 使用 forkjoin * 1. forkjoinPool * 2. 继承RecursiveTask * 3. 任务拆分 */public class forkjoindemo extends RecursiveTask&lt;Long&gt; &#123; private Long start; private Long end; //临界值 private Long temp = 10000l; public forkjoindemo(Long start, Long end) &#123; this.start = start; this.end = end; &#125; //计算方法 @Override protected Long compute() &#123; if (end - start &lt; temp)&#123; Long sum = 0l; for (Long i = start; i &lt;= end; i++) &#123; sum += i; &#125; return sum; &#125;else &#123; //forkjoin Long middle = (start+end)/2; forkjoindemo task1 = new forkjoindemo(start, middle); //拆分任务 ， 吧任务压入线程队列 task1.fork(); forkjoindemo task2 = new forkjoindemo(middle+1, end); task2.fork(); Long sum = task1.join() + task2.join(); return sum; &#125; &#125;&#125; 测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.timous.forkjoin;import com.timous.tools.Times;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.stream.LongStream;public class Test &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; test(); test1(); test2(); &#125; public static void test() throws ExecutionException, InterruptedException &#123; Times.test(&quot;test&quot;, new Times.Task() &#123; @Override public void execute() &#123; Long sum = 0l; for (Long i = 0l; i &lt;= 10_0000_0000; i++) &#123; sum += i; &#125; System.out.println(sum); &#125; &#125;); &#125; public static void test1() throws ExecutionException, InterruptedException &#123; Times.test(&quot;test1&quot;, new Times.Task() &#123; @Override public void execute() throws ExecutionException, InterruptedException &#123; ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask&lt;Long&gt; task = new forkjoindemo(0l, 10_0000_0000l); ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task); Long sum = submit.get(); System.out.println(sum); &#125; &#125;); &#125; public static void test2() throws ExecutionException, InterruptedException &#123; Times.test(&quot;test2&quot;, new Times.Task() &#123; @Override public void execute() &#123; // Stream 并行流 long reduce = LongStream.rangeClosed(0l, 10_0000_0000l).parallel().reduce(0, Long::sum); System.out.println(reduce); &#125; &#125;); &#125;&#125; forkjoin在大数据量的时候使用 ， 小的数据不会去使用这些 异步回调Future 未来： 可以对将来的某个时间的结果进行建模 ， 1234567891011121314151617181920212223242526272829303132333435363738package com.timous.future;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;/** * 异步调用Ajax * 异步执行 * 成功回调 * 失败回调 */public class Test &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //发起一个请求 //没有返回值的runAsync 异步回调// CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(()-&gt;&#123;//// System.out.println(Thread.currentThread().getName()+&quot;runAsync&quot;);// &#125;);//// System.out.println(21111);// //阻塞获取执行结果// completableFuture.get(); CompletableFuture&lt;Integer&gt; uCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(Thread.currentThread().getName()+&quot;supplyAsync-&gt;Integer&quot;); int i = 10/0; return 1024; &#125;); System.out.println(uCompletableFuture.whenComplete((T, U) -&gt; &#123; System.out.println(&quot;T:&quot; + T + &quot;,U:&quot; + U); //java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero &#125;).exceptionally((e) -&gt; &#123; e.getMessage(); return 233;//可以获得错误的返回结果 &#125;).get()); &#125;&#125; 理解JMM请你谈谈你对Volatile的理解 Volatile是一个java的虚拟机提供的一个&#x3D;&#x3D;轻量级&#x3D;&#x3D;的同步机制 Sychronized 保证可见性 不保证原子性 禁止指令重排 什么是JMM？ JVM是java虚拟机 JMM是java内存模行 ， 不存在的东西 ， 概念 ， 约定 关于JMM的约定： 线程的解锁必须把共享变量&#x3D;&#x3D;立刻&#x3D;&#x3D; 线程加锁前 ， 必须读取主存中的最新值到工作内存当中去 加的锁和解得锁必须是同一把锁 线程： 工作内存 、 主内存 线程B修改了值 ， 但是A不会不会立即更新这个值 内存交互操作 内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外） lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态 unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用 load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中 use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令 assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中 store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用 write （写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中 JMM对这八种指令的使用，制定了如下规则： 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存 不允许一个线程将没有assign的数据从工作内存同步回主内存 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量 对一个变量进行unlock操作之前，必须把此变量同步回主内存 程序不知道主内存已经改变了 ， 我们需要改变 Volatile保证可见性12345678910111213141516171819202122package com.timous.Volatile;import java.util.concurrent.TimeUnit;public class JmmDemo &#123; private volatile static int num=0;// 不加volatile 就会死循环 ， 也就是没有可见性 public static void main(String[] args) &#123;//main线程 new Thread(()-&gt;&#123; // 线程的主内存这里不知道 while (num == 0)&#123; &#125; &#125;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; num = 1; System.out.println(num); &#125;&#125; 不保证原子性不可分割 线程A 在执行业务的时候是不能被干扰的 ， 也不能被分割要么同时成功 ， 要么同时失败 12345678910111213141516171819202122232425package com.timous.Volatile;// 不保证原子性public class VDemo &#123; private volatile static int num = 0; //看出来不能保证原子性 如果在add方法前面加上synchronized的话是可以成功的 public static void add()&#123; num++; &#125; public static void main(String[] args) &#123; //理论上 num是20000 ， 但是 在多线程里面就会出现问题 for (int i = 1; i &lt;= 20; i++) &#123; new Thread(()-&gt;&#123; for (int j = 1; j &lt;= 1000; j++) &#123; add(); &#125; &#125;).start(); &#125; while(Thread.activeCount()&gt;2)&#123; Thread.yield(); &#125; System.out.println(Thread.currentThread().getName()+&quot;&quot;+num); &#125;&#125; 如果不加Lock和synchronized ， 如何保证原子性？ num++ 不是一个原子性操作 会使用这个来进行处理我们的各种变量 ， 解决原子性问题 原子类为啥能折磨做？ 1num.getAndIncrement(); // +1方法 并不是一个简单的+1操作 ， CAS 这些类的底层都和底层的操作系统相关 ， UnSafe类是一个很特殊的存在 ， CAS里会讲 禁止指令重排：什么是指令重排： 你写的程序 ， 计算机并不是按照你写的那样执行的。 源代码 编译器优化你的代码 指令并行也可能会重排 内存系统可能也会进行重排 &#x3D;&#x3D;处理器在进行指令重排的时候会考虑： 数据之间的依赖性&#x3D;&#x3D; 12345int x = 1 ;int y = 2 ;x = x + 5 ;y = x * x ;//我们所期望的是 从上到下 可能是 2 1 3 4 或者是其他的顺序 可能造成影响的结果: A , B ,X , Y 默认都是0 线程A 线程B x &#x3D; A Y &#x3D; B B &#x3D; 1 A &#x3D; 2 x 0 y 0 , 但是在指令重排的时候会出现问题 ， 因此 ， 这个时候会禁止指令重排的 1000万次 ， 不一定出现一次 ， 可以避免指令重排 ？ 非计算机专业 ， 不要听懂了 ， CPU ， 内存屏障，CPU指令作用; 保证特定的操作的执行顺序 可以保证某些变量的内存可见性 利用这些特性 ， 我们的volatile就会有可见性 Volatile能够保证我们的可见性 ， 不能保证原子性， 由于我们的内存屏障 ， 可以避免我们的 ， 在单例模式使用的最多 彻底玩转单例模式饿汉式 ， DCL懒汉式 123456789101112131415161718package com.timous.single;/** * 饿汉式单例模式 */public class Hungry &#123; private byte[] data1 = new byte[1024*1024] ; private byte[] data2 = new byte[1024*1024] ; private byte[] data3 = new byte[1024*1024] ; private byte[] data4 = new byte[1024*1024] ; private Hungry()&#123; &#125; private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance()&#123; return HUNGRY; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.timous.single;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.time.Instant;/** * 懒汉式单例模式 DCL 道高一尺 ， 魔高一丈 */public class Lazy &#123; private static boolean timous = false; private Lazy()&#123; synchronized (Lazy.class)&#123; if (timous == false)&#123; timous = true; &#125;else&#123; throw new RuntimeException(&quot;不要试图使用反射区破坏单例！！！&quot;); &#125; if(lazy != null)&#123; throw new RuntimeException(&quot;不要试图使用反射区破坏单例！！！&quot;); &#125; &#125; System.out.println(Thread.currentThread().getName()+&quot;ok&quot;); &#125; private volatile static Lazy lazy; //双重检测锁模式的懒汉式单例 DCL懒汉式单例 public static Lazy getInstance()&#123; if (lazy == null)&#123; synchronized (Lazy.class)&#123; if(lazy == null)&#123; lazy = new Lazy(); // 不是一个原子性操作 // 分配内存空间 执行构造方法（初始化对象） 吧这个对象只想空间 指令重排 &#125; &#125;; &#125; return lazy;//此时lazy 没有完成构造 我们要保证避免指令重排 &#125; //单线程下 单例是可以的 ，我们在进行多线程的时候就会出现问题// public static void main(String[] args) &#123;// for (int i = 0; i &lt; 10; i++) &#123;// new Thread(()-&gt;&#123;// Lazy.getInstance();// &#125;).start();// &#125;// &#125; //反射 public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;// Lazy lazy = Lazy.getInstance(); Field timous = Lazy.class.getDeclaredField(&quot;timous&quot;); timous.setAccessible(true); Constructor&lt;Lazy&gt; declaredConstructor = Lazy.class.getDeclaredConstructor(null); declaredConstructor.setAccessible(true); Lazy lazy1 = declaredConstructor.newInstance(); timous.set(lazy1 , false); Lazy lazy2 = declaredConstructor.newInstance(); System.out.println(lazy2); System.out.println(lazy1); &#125;&#125; 静态内部类1234567891011121314151617181920212223242526package com.timous.single;import com.sun.org.apache.bcel.internal.generic.RET;import java.util.PrimitiveIterator;/** * 静态内部类 * * 这些都是不安全的 */public class Holder &#123; private Holder()&#123; &#125; public static Holder getInstance()&#123; return InnerClass.HOLDER; &#125; public static class InnerClass&#123; private static final Holder HOLDER = new Holder(); &#125;&#125; 单例模式不安全 ，因为有反射 ， 枚举：12345678910111213141516171819202122232425262728293031package com.timous.single;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * enum 是一个什么 本身也是一个class类 */public enum EnumSingle &#123; INSTANCE; public EnumSingle getInstance()&#123; return INSTANCE; &#125;&#125;class Test&#123; //会产生一个午餐的构造方法 public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;// EnumSingle instance1 = EnumSingle.INSTANCE;// EnumSingle instance2 = EnumSingle.INSTANCE;// System.out.println(instance1);// System.out.println(instance2); EnumSingle instance = EnumSingle.INSTANCE; Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class , int.class); declaredConstructor.setAccessible(true); EnumSingle instance1 = declaredConstructor.newInstance(); //java.lang.NoSuchMethodException 我们的探究失败了 通过反编译也看到 ， 我们的也是有一个空参的构造 System.out.println(instance); System.out.println(instance1); &#125;&#125; 枚举类型的最终反编译源码是没有一个空参的构造方式 ， 只有一个String ， int的构造方法 深入理解CAS什么是CAS为啥要学CAS ， 大厂必须要会这些底层的东西 ！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336/* * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * * * * * * * * * * * * * * * * * * * *//* * * * * * * Written by Doug Lea with assistance from members of JCP JSR-166 * Expert Group and released to the public domain, as explained at * http://creativecommons.org/publicdomain/zero/1.0/ */package java.util.concurrent.atomic;import java.util.function.IntUnaryOperator;import java.util.function.IntBinaryOperator;import sun.misc.Unsafe;/** * An &#123;@code int&#125; value that may be updated atomically. See the * &#123;@link java.util.concurrent.atomic&#125; package specification for * description of the properties of atomic variables. An * &#123;@code AtomicInteger&#125; is used in applications such as atomically * incremented counters, and cannot be used as a replacement for an * &#123;@link java.lang.Integer&#125;. However, this class does extend * &#123;@code Number&#125; to allow uniform access by tools and utilities that * deal with numerically-based classes. * * @since 1.5 * @author Doug Lea*/public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; /** * Creates a new AtomicInteger with the given initial value. * * @param initialValue the initial value */ public AtomicInteger(int initialValue) &#123; value = initialValue; &#125; /** * Creates a new AtomicInteger with initial value &#123;@code 0&#125;. */ public AtomicInteger() &#123; &#125; /** * Gets the current value. * * @return the current value */ public final int get() &#123; return value; &#125; /** * Sets to the given value. * * @param newValue the new value */ public final void set(int newValue) &#123; value = newValue; &#125; /** * Eventually sets to the given value. * * @param newValue the new value * @since 1.6 */ public final void lazySet(int newValue) &#123; unsafe.putOrderedInt(this, valueOffset, newValue); &#125; /** * Atomically sets to the given value and returns the old value. * * @param newValue the new value * @return the previous value */ public final int getAndSet(int newValue) &#123; return unsafe.getAndSetInt(this, valueOffset, newValue); &#125; /** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful. False return indicates that * the actual value was not equal to the expected value. */ public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; /** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * &lt;p&gt;&lt;a href=&quot;package-summary.html#weakCompareAndSet&quot;&gt;May fail * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is * only rarely an appropriate alternative to &#123;@code compareAndSet&#125;. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful */ public final boolean weakCompareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; /** * Atomically increments by one the current value. * * @return the previous value */ public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1); &#125; /** * Atomically decrements by one the current value. * * @return the previous value */ public final int getAndDecrement() &#123; return unsafe.getAndAddInt(this, valueOffset, -1); &#125; /** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the previous value */ public final int getAndAdd(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta); &#125; /** * Atomically increments by one the current value. * * @return the updated value */ public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1; &#125; /** * Atomically decrements by one the current value. * * @return the updated value */ public final int decrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, -1) - 1; &#125; /** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the updated value */ public final int addAndGet(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta) + delta; &#125; /** * Atomically updates the current value with the results of * applying the given function, returning the previous value. The * function should be side-effect-free, since it may be re-applied * when attempted updates fail due to contention among threads. * * @param updateFunction a side-effect-free function * @return the previous value * @since 1.8 */ public final int getAndUpdate(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return prev; &#125; /** * Atomically updates the current value with the results of * applying the given function, returning the updated value. The * function should be side-effect-free, since it may be re-applied * when attempted updates fail due to contention among threads. * * @param updateFunction a side-effect-free function * @return the updated value * @since 1.8 */ public final int updateAndGet(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return next; &#125; /** * Atomically updates the current value with the results of * applying the given function to the current and given values, * returning the previous value. The function should be * side-effect-free, since it may be re-applied when attempted * updates fail due to contention among threads. The function * is applied with the current value as its first argument, * and the given update as the second argument. * * @param x the update value * @param accumulatorFunction a side-effect-free function of two arguments * @return the previous value * @since 1.8 */ public final int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction) &#123; int prev, next; do &#123; prev = get(); next = accumulatorFunction.applyAsInt(prev, x); &#125; while (!compareAndSet(prev, next)); return prev; &#125; /** * Atomically updates the current value with the results of * applying the given function to the current and given values, * returning the updated value. The function should be * side-effect-free, since it may be re-applied when attempted * updates fail due to contention among threads. The function * is applied with the current value as its first argument, * and the given update as the second argument. * * @param x the update value * @param accumulatorFunction a side-effect-free function of two arguments * @return the updated value * @since 1.8 */ public final int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction) &#123; int prev, next; do &#123; prev = get(); next = accumulatorFunction.applyAsInt(prev, x); &#125; while (!compareAndSet(prev, next)); return next; &#125; /** * Returns the String representation of the current value. * @return the String representation of the current value */ public String toString() &#123; return Integer.toString(get()); &#125; /** * Returns the value of this &#123;@code AtomicInteger&#125; as an &#123;@code int&#125;. */ public int intValue() &#123; return get(); &#125; /** * Returns the value of this &#123;@code AtomicInteger&#125; as a &#123;@code long&#125; * after a widening primitive conversion. * @jls 5.1.2 Widening Primitive Conversions */ public long longValue() &#123; return (long)get(); &#125; /** * Returns the value of this &#123;@code AtomicInteger&#125; as a &#123;@code float&#125; * after a widening primitive conversion. * @jls 5.1.2 Widening Primitive Conversions */ public float floatValue() &#123; return (float)get(); &#125; /** * Returns the value of this &#123;@code AtomicInteger&#125; as a &#123;@code double&#125; * after a widening primitive conversion. * @jls 5.1.2 Widening Primitive Conversions */ public double doubleValue() &#123; return (double)get(); &#125;&#125; CAS比较当前工作内存中的值 ， 和主内存中的值 ， 如果这个值是期望的 ， 那么就执行操作！ 如果不是就一直循环！！！ 缺点： 循环会耗时 一次性只能保证一个共享变量的原子性 ABA问题 cas ABA问题（狸猫换太子） 1234567891011121314151617181920212223242526package com.timous.cas;import java.util.concurrent.atomic.AtomicInteger;public class CasDemo &#123; //cas public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(2020); /** * expect 期望 update 更新 * public final boolean compareAndSet(int expect, int update) &#123; * return unsafe.compareAndSwapInt(this, valueOffset, expect, update); * &#125; * 如果期望的值达到了 ， 就更新 ， 否则 ， 不更新 cas 是 CPU的并发原语 */ // 对于我们平时写的sql 乐观锁 System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(2021, 2020)); System.out.println(atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(2020, 6666)); System.out.println(atomicInteger.get()); &#125;&#125; 如何解决 原子引用带版本号的原子操作 对应的是乐观锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.timous.cas;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicStampedReference;public class CasDemo &#123; //cas public static void main(String[] args) &#123;// AtomicInteger atomicInteger = new AtomicInteger(2020); //注意： 如果泛型是一个包装类 ， 注意引用的问题 乐观锁的原理相同 AtomicStampedReference&lt;Integer&gt; atomicInteger = new AtomicStampedReference&lt;&gt;(1, 1); new Thread(()-&gt;&#123; int stamp = atomicInteger.getStamp(); // 获得版本号 System.out.println(stamp); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicInteger.compareAndSet(1, 2, atomicInteger.getStamp(), atomicInteger.getStamp() + 1)); int stamp2 = atomicInteger.getStamp(); // 获得版本号 System.out.println(stamp2); System.out.println(&quot;-----&gt;&quot;+atomicInteger.compareAndSet(2, 1, atomicInteger.getStamp(), atomicInteger.getStamp() + 1)); &#125; , &quot;A&quot;).start(); new Thread(()-&gt;&#123; int stamp = atomicInteger.getStamp(); // 获得版本号 System.out.println(&quot;=====&quot;+stamp); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicInteger.compareAndSet(1, 66, stamp, stamp + 1)); int stamp1 = atomicInteger.getStamp(); System.out.println(stamp1); &#125; , &quot;B&quot;).start(); /** * * expect 期望 update 更新 * public final boolean compareAndSet(int expect, int update) &#123; * return unsafe.compareAndSwapInt(this, valueOffset, expect, update); * &#125; * 如果期望的值达到了 ， 就更新 ， 否则 ， 不更新 cas 是 CPU的并发原语 */ // 对于我们平时写的sql 乐观锁// System.out.println(atomicInteger.compareAndSet(2020, 2021));// System.out.println(atomicInteger.get());// System.out.println(atomicInteger.compareAndSet(2021, 2020));// System.out.println(atomicInteger.get());// System.out.println(atomicInteger.compareAndSet(2020, 6666));// System.out.println(atomicInteger.get()); &#125;&#125; 各种锁的理解公平锁 ， 非公平锁公平锁： 非常公平 ， 不能插队 非公平锁：非常不公平 ， 可以插队 ， 后面的可以插到前面的 （默认都是非公平的） 可重入锁递归锁 ， 也就是可重入锁 拿到了外面的锁 ， 就可以拿到里面的锁 ， 是自动获取的 Demo01 123456789101112131415161718192021222324252627282930313233343536package com.timous.lock;import java.util.concurrent.TimeUnit;// sychronizedpublic class Demo01 &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); new Thread(()-&gt;&#123; try &#123; phone.sms(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; , &quot;A&quot;).start(); new Thread(()-&gt;&#123; try &#123; phone.sms(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; , &quot;B&quot;).start(); &#125;&#125;class Phone&#123; public synchronized void sms() throws InterruptedException &#123; System.out.println(Thread.currentThread().getName()+&quot;sms&quot;); TimeUnit.SECONDS.sleep(2); call(); &#125; public synchronized void call()&#123; System.out.println(Thread.currentThread().getName()+&quot;call&quot;); &#125;&#125; lock 123456789101112131415161718192021222324252627282930313233343536373839404142package com.timous.lock;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Demo02 &#123; public static void main(String[] args) &#123; Phone1 phone1 = new Phone1(); new Thread(()-&gt;&#123; phone1.sms(); &#125; , &quot;A&quot;).start(); new Thread(()-&gt;&#123; phone1.sms(); &#125; , &quot;B&quot;).start(); &#125;&#125;class Phone1&#123; Lock lock = new ReentrantLock(); // lock 必须配对 ， 否则必须配对 public void sms()&#123; try &#123; lock.lock(); System.out.println(Thread.currentThread().getName()+&quot;sms&quot;); call(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; private void call() &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName()+&quot;call&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; 自旋锁 会不断尝试 ， 一直到成功 自定义的自旋锁 123456789101112131415161718192021222324252627package com.timous.lock;import java.util.concurrent.atomic.AtomicReference;/** * 自旋锁 */public class SpinLockDemo &#123; // Thread null AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); //加锁 public void mylock()&#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName()+&quot;----&gt; mylock&quot;); //自旋锁 while (!atomicReference.compareAndSet(null , thread))&#123; &#125; &#125; //解锁 public void myunlock()&#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName()+&quot;----&gt; myunlock&quot;); //自旋锁 atomicReference.compareAndSet(thread , null); &#125;&#125; 测试： 1234567891011121314151617181920212223242526272829303132package com.timous.lock;import com.timous.single.EnumSingle;import java.util.concurrent.TimeUnit;public class Test &#123; public static void main(String[] args) &#123; SpinLockDemo lock = new SpinLockDemo(); new Thread(()-&gt;&#123; lock.mylock(); try &#123; TimeUnit.SECONDS.sleep(3); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.myunlock(); &#125; &#125; , &quot;A&quot;).start(); new Thread(()-&gt;&#123; lock.mylock(); try &#123; TimeUnit.SECONDS.sleep(1); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.myunlock(); &#125; &#125; , &quot;B&quot;).start(); &#125;&#125; 死锁死锁是什么？ 两个线程相互争夺资源 排查死锁 ， 解决问题 jdk bin 1.jps定位进程号 jps -l 2.jstack 进程号 查看思索的信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112C:\\Program Files\\Java\\jdk1.8.0_201\\bin&gt;jstack 162442020-11-01 22:06:42Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.201-b09 mixed mode):&quot;DestroyJavaVM&quot; #13 prio=5 os_prio=0 tid=0x0000000002943800 nid=0x3f0c waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;T2&quot; #12 prio=5 os_prio=0 tid=0x0000000018ab6800 nid=0x11a4 waiting for monitor entry [0x00000000196af000] java.lang.Thread.State: BLOCKED (on object monitor) at com.timous.lock.MyThread.run(DeadLock.java:39) - waiting to lock &lt;0x00000000d63a2b98&gt; (a java.lang.String) - locked &lt;0x00000000d63a2bd0&gt; (a java.lang.String) at java.lang.Thread.run(Thread.java:748)&quot;T1&quot; #11 prio=5 os_prio=0 tid=0x0000000018ab6000 nid=0x37fc waiting for monitor entry [0x00000000195af000] java.lang.Thread.State: BLOCKED (on object monitor) at com.timous.lock.MyThread.run(DeadLock.java:39) - waiting to lock &lt;0x00000000d63a2bd0&gt; (a java.lang.String) - locked &lt;0x00000000d63a2b98&gt; (a java.lang.String) at java.lang.Thread.run(Thread.java:748)&quot;Service Thread&quot; #10 daemon prio=9 os_prio=0 tid=0x00000000189bf800 nid=0x1ce8 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C1 CompilerThread2&quot; #9 daemon prio=9 os_prio=2 tid=0x0000000018929000 nid=0x2880 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C2 CompilerThread1&quot; #8 daemon prio=9 os_prio=2 tid=0x0000000018925800 nid=0x3684 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C2 CompilerThread0&quot; #7 daemon prio=9 os_prio=2 tid=0x000000001891f800 nid=0x3d38 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Monitor Ctrl-Break&quot; #6 daemon prio=5 os_prio=0 tid=0x00000000188ee000 nid=0x3204 runnable [0x0000000018fae000] java.lang.Thread.State: RUNNABLE at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) - locked &lt;0x00000000d642bf08&gt; (a java.io.InputStreamReader) at java.io.InputStreamReader.read(InputStreamReader.java:184) at java.io.BufferedReader.fill(BufferedReader.java:161) at java.io.BufferedReader.readLine(BufferedReader.java:324) - locked &lt;0x00000000d642bf08&gt; (a java.io.InputStreamReader) at java.io.BufferedReader.readLine(BufferedReader.java:389) at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:61)&quot;Attach Listener&quot; #5 daemon prio=5 os_prio=2 tid=0x0000000017500800 nid=0x4dc waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=2 tid=0x00000000174ff800 nid=0xb54 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 tid=0x0000000002a36800 nid=0x1db4 in Object.wait() [0x000000001884e000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000000d6208ed0&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144) - locked &lt;0x00000000d6208ed0&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165) at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=2 tid=0x0000000002a33000 nid=0x4680 in Object.wait() [0x000000001874f000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000000d6206bf8&gt; (a java.lang.ref.Reference$Lock) at java.lang.Object.wait(Object.java:502) at java.lang.ref.Reference.tryHandlePending(Reference.java:191) - locked &lt;0x00000000d6206bf8&gt; (a java.lang.ref.Reference$Lock) at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)&quot;VM Thread&quot; os_prio=2 tid=0x00000000174b7800 nid=0x36c0 runnable&quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x0000000002959000 nid=0x3890 runnable&quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x000000000295a800 nid=0x271c runnable&quot;GC task thread#2 (ParallelGC)&quot; os_prio=0 tid=0x000000000295c000 nid=0x1b74 runnable&quot;GC task thread#3 (ParallelGC)&quot; os_prio=0 tid=0x000000000295e800 nid=0x3dc8 runnable&quot;VM Periodic Task Thread&quot; os_prio=2 tid=0x00000000189da800 nid=0x24fc waiting on conditionJNI global references: 12Found one Java-level deadlock:=============================&quot;T2&quot;: waiting to lock monitor 0x00000000174ddc48 (object 0x00000000d63a2b98, a java.lang.String), which is held by &quot;T1&quot;&quot;T1&quot;: waiting to lock monitor 0x00000000174e0638 (object 0x00000000d63a2bd0, a java.lang.String), which is held by &quot;T2&quot;Java stack information for the threads listed above:===================================================&quot;T2&quot;: at com.timous.lock.MyThread.run(DeadLock.java:39) - waiting to lock &lt;0x00000000d63a2b98&gt; (a java.lang.String) - locked &lt;0x00000000d63a2bd0&gt; (a java.lang.String) at java.lang.Thread.run(Thread.java:748)&quot;T1&quot;: at com.timous.lock.MyThread.run(DeadLock.java:39) - waiting to lock &lt;0x00000000d63a2bd0&gt; (a java.lang.String) - locked &lt;0x00000000d63a2b98&gt; (a java.lang.String) at java.lang.Thread.run(Thread.java:748)Found 1 deadlock. 面试工作中 ， 发现是否有异常 ， &#x3D;&#x3D;查看日志&#x3D;&#x3D; ， &#x3D;&#x3D;查看堆栈的信息&#x3D;&#x3D;","tags":["多线程"]},{"title":"equals和异常","path":"/2021/03/26/equals和异常/","content":"equals和异常equals详解两个对象的值相等，但却可能有不同的hashcode，这句话对不对？两个对象x , y如果满足x.equals（y）&#x3D;&#x3D; true , 它们的哈希码（hashcode）应当相同。Java对于equals方法和hashcode是这样规定的： 如果两个对象相同（equals方法返回true），那么它们的hashcode值一定相同。 如果两个对象的hashcode值相同，它们并不一定相同。当然，你未必按照要求去做，但是如果你违背了上述的原则就会发现使用容器的时候，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希频繁的冲突会造成存取性能几句下降） 异常处理Java异常的分类按照异常处理的时机分类的话有 编译时异常（强制性异常）也叫CheckedException 运行时异常（非强制异常）也叫RunTimeException 异常处理 当前方法知道如何处理该异常，则用 try…catch 块来处理该异常。 当前方法不知道如何处理，则在定义该方法是声明抛出该异常。 测试12345678910public int getNum()&#123; try&#123; int a = 1/0; return 1; &#125;catch(Exception e)&#123; return 2; &#125;finally&#123; return 3; &#125;&#125; 测试 结果为3，代码在遇到第三行的时候遇到异常，会到catch语句中，执行第六行，但是异常机制有这么一个原则，在catch中遇到return的或者异常能够使该函数终止的话，finally就必须先执行完，所以第六行不会返回值，返回的是第八行的值。真正返回的值是3。 常见的RuntimeException java.lang.NullPointerException空指针异常；出现原因是：调用了未经初始化的对象或者是不存在的对象 java.lang.ClassNotFoundException指定的类找不到；出现原因是：类的名称和路径加载错误，通常都是程序试图通过字符串来加载某个类时所发生的异常。 java.lang.NumberFormatException字符串转化为数字异常；出现原因： 字符型数据中包含非数字型字符。 java.langIndexOutOfBoundsException数组角标越界异常，常见于操作数组对象是发生。 java.lang.IllegalArgumentException方法传递参数错误。 java.lang.ClassCastException数据类型转换异常。 java.lang.NoClassDefFoundException未找到类定义错误。 SQLException异常，常见于操作数据库是的SQL语句错误。 java.lang.InstantiationException实例化异常 java.lang.NoSuchMerthodException方法不存在异常。","tags":["面试题"]}]